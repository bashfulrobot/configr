
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>configr: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bashfulrobot/configr/cmd/configr/apply.go (3.2%)</option>
				
				<option value="file1">github.com/bashfulrobot/configr/cmd/configr/cache.go (6.5%)</option>
				
				<option value="file2">github.com/bashfulrobot/configr/cmd/configr/completion.go (20.0%)</option>
				
				<option value="file3">github.com/bashfulrobot/configr/cmd/configr/includes.go (4.4%)</option>
				
				<option value="file4">github.com/bashfulrobot/configr/cmd/configr/init.go (12.2%)</option>
				
				<option value="file5">github.com/bashfulrobot/configr/cmd/configr/man.go (81.4%)</option>
				
				<option value="file6">github.com/bashfulrobot/configr/cmd/configr/packages.go (6.0%)</option>
				
				<option value="file7">github.com/bashfulrobot/configr/cmd/configr/restore.go (7.7%)</option>
				
				<option value="file8">github.com/bashfulrobot/configr/cmd/configr/root.go (83.3%)</option>
				
				<option value="file9">github.com/bashfulrobot/configr/cmd/configr/validate.go (7.7%)</option>
				
				<option value="file10">github.com/bashfulrobot/configr/internal/config/advanced_loader.go (77.8%)</option>
				
				<option value="file11">github.com/bashfulrobot/configr/internal/config/config.go (30.8%)</option>
				
				<option value="file12">github.com/bashfulrobot/configr/internal/config/defaults.go (100.0%)</option>
				
				<option value="file13">github.com/bashfulrobot/configr/internal/config/formatter_enhanced.go (0.0%)</option>
				
				<option value="file14">github.com/bashfulrobot/configr/internal/config/formatter_simple.go (93.8%)</option>
				
				<option value="file15">github.com/bashfulrobot/configr/internal/config/inheritance.go (0.0%)</option>
				
				<option value="file16">github.com/bashfulrobot/configr/internal/config/loader.go (78.5%)</option>
				
				<option value="file17">github.com/bashfulrobot/configr/internal/config/logger.go (20.0%)</option>
				
				<option value="file18">github.com/bashfulrobot/configr/internal/config/package_entry.go (52.8%)</option>
				
				<option value="file19">github.com/bashfulrobot/configr/internal/config/parser.go (7.7%)</option>
				
				<option value="file20">github.com/bashfulrobot/configr/internal/config/splitting.go (0.0%)</option>
				
				<option value="file21">github.com/bashfulrobot/configr/internal/config/templates.go (0.0%)</option>
				
				<option value="file22">github.com/bashfulrobot/configr/internal/config/validation.go (78.7%)</option>
				
				<option value="file23">github.com/bashfulrobot/configr/internal/pkg/apt.go (28.4%)</option>
				
				<option value="file24">github.com/bashfulrobot/configr/internal/pkg/cache.go (81.2%)</option>
				
				<option value="file25">github.com/bashfulrobot/configr/internal/pkg/dconf.go (44.2%)</option>
				
				<option value="file26">github.com/bashfulrobot/configr/internal/pkg/files.go (21.7%)</option>
				
				<option value="file27">github.com/bashfulrobot/configr/internal/pkg/flatpak.go (41.4%)</option>
				
				<option value="file28">github.com/bashfulrobot/configr/internal/pkg/interactive.go (13.7%)</option>
				
				<option value="file29">github.com/bashfulrobot/configr/internal/pkg/optimized_apt.go (1.0%)</option>
				
				<option value="file30">github.com/bashfulrobot/configr/internal/pkg/optimized_loader.go (1.0%)</option>
				
				<option value="file31">github.com/bashfulrobot/configr/internal/pkg/repositories.go (55.7%)</option>
				
				<option value="file32">github.com/bashfulrobot/configr/internal/pkg/snap.go (46.7%)</option>
				
				<option value="file33">github.com/bashfulrobot/configr/internal/pkg/state.go (89.3%)</option>
				
				<option value="file34">github.com/bashfulrobot/configr/internal/pkg/ux.go (24.6%)</option>
				
				<option value="file35">github.com/bashfulrobot/configr/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package configr

import (
        "fmt"
        "os"
        "path/filepath"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/bashfulrobot/configr/internal/pkg"
        "github.com/charmbracelet/log"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        dryRun          bool
        removePackages  bool
        useOptimization bool
        interactiveMode bool
        showPreview     bool
)

var applyCmd = &amp;cobra.Command{
        Use:   "apply [config-file]",
        Short: "Apply configuration changes to the system",
        Long: `Apply loads and applies the configuration to your system.

This command will:
- Remove packages no longer in configuration (if --remove-packages=true)
- Add APT and Flatpak repositories
- Deploy and symlink files to their destinations
- Install APT, Flatpak, and Snap packages
- Apply dconf settings for desktop configuration
- Create backups of existing files when requested
- Track package state for future removal operations
- Interactively resolve file conflicts when --interactive flag is used

Interactive features include:
- Conflict resolution prompts for existing files
- File diff preview before replacement
- Interactive permission and ownership configuration

By default, it looks for 'configr.yaml' in standard locations.`,
        Example: `  configr apply                         # Apply default config
  configr apply my-config.yaml          # Apply specific config
  configr apply --dry-run               # Preview changes without applying
  configr apply --interactive           # Enable interactive prompts
  configr apply --remove-packages=false # Skip package removal
  configr apply --optimize=false        # Disable caching and optimization
  configr --config custom.yaml apply    # Use custom config file`,
        Args: cobra.MaximumNArgs(1),
        RunE: runApply,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(applyCmd)
        
        // Command-specific flags
        applyCmd.Flags().BoolVar(&amp;dryRun, "dry-run", false, "preview changes without applying them")
        applyCmd.Flags().BoolVar(&amp;removePackages, "remove-packages", true, "remove packages that are no longer in configuration")
        applyCmd.Flags().BoolVar(&amp;useOptimization, "optimize", true, "enable caching and optimization for faster runs")
        applyCmd.Flags().BoolVar(&amp;interactiveMode, "interactive", false, "enable interactive prompts for conflicts and permissions")
        applyCmd.Flags().BoolVar(&amp;showPreview, "preview", false, "show configuration preview before applying")
}</span>

func runApply(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Initialize logger
        logger := log.NewWithOptions(os.Stderr, log.Options{
                ReportCaller:    false,
                ReportTimestamp: false,
                Prefix:          "configr",
        })

        // Set log level based on verbose flag
        if viper.GetBool("verbose") </span><span class="cov0" title="0">{
                logger.SetLevel(log.DebugLevel)
        }</span>

        // Initialize UX manager for enhanced user experience
        <span class="cov0" title="0">uxManager := pkg.NewUXManager(logger, dryRun)

        // Disable color if requested  
        // Note: color profile setting would require termenv import

        // Determine config file path
        var configPath string
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                configPath = args[0]
        }</span> else<span class="cov0" title="0"> if viper.GetString("config") != "" </span><span class="cov0" title="0">{
                configPath = viper.GetString("config")
        }</span> else<span class="cov0" title="0"> {
                // Find config file in standard locations
                var err error
                configPath, err = findConfigFile()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find config file: %w", err)
                }</span>
        }

        // Load configuration with enhanced UX
        <span class="cov0" title="0">var cfg *config.Config
        var err error
        configDir := filepath.Dir(configPath)

        // Show loading spinner for configuration
        loadSpinner, loadDone := uxManager.ShowConfigLoadSpinner(useOptimization)
        
        if useOptimization </span><span class="cov0" title="0">{
                logger.Debug("Loading configuration with optimization", "file", configPath)
                
                // Initialize cache manager
                cacheManager := pkg.NewCacheManager(logger)
                optimizedLoader := pkg.NewOptimizedLoader(logger, cacheManager)
                
                cfg, _, err = optimizedLoader.LoadConfigurationOptimized(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        if loadSpinner != nil </span><span class="cov0" title="0">{
                                loadDone &lt;- pkg.SpinnerDoneMsg{Success: false, Error: err}
                                loadSpinner.Kill()
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to load config with optimization: %w", err)</span>
                }
        } else<span class="cov0" title="0"> {
                logger.Debug("Loading configuration (standard mode)", "file", configPath)
                
                // Standard loading
                viper.SetConfigFile(configPath)
                if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                        if loadSpinner != nil </span><span class="cov0" title="0">{
                                loadDone &lt;- pkg.SpinnerDoneMsg{Success: false, Error: err}
                                loadSpinner.Kill()
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to read config file: %w", err)</span>
                }
                
                <span class="cov0" title="0">cfg, err = config.LoadWithIncludes()
                if err != nil </span><span class="cov0" title="0">{
                        if loadSpinner != nil </span><span class="cov0" title="0">{
                                loadDone &lt;- pkg.SpinnerDoneMsg{Success: false, Error: err}
                                loadSpinner.Kill()
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to load config: %w", err)</span>
                }
        }
        
        // Complete loading spinner
        <span class="cov0" title="0">if loadSpinner != nil </span><span class="cov0" title="0">{
                loadDone &lt;- pkg.SpinnerDoneMsg{Success: true}
                loadSpinner.Kill()
        }</span>

        // Validate configuration with enhanced UX
        <span class="cov0" title="0">validationSpinner, validationDone := uxManager.ShowValidationSpinner()
        
        logger.Debug("Validating configuration")
        result := config.Validate(cfg, configPath)
        
        // Complete validation spinner
        if validationSpinner != nil </span><span class="cov0" title="0">{
                validationDone &lt;- pkg.SpinnerDoneMsg{Success: !result.HasErrors()}
                validationSpinner.Kill()
        }</span>
        
        // Show enhanced validation summary
        <span class="cov0" title="0">if result.HasErrors() || len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Fprint(os.Stderr, uxManager.FormatValidationSummary(result))
                if result.HasErrors() </span><span class="cov0" title="0">{
                        return fmt.Errorf("configuration validation failed")
                }</span>
        }

        // Show configuration preview if requested
        <span class="cov0" title="0">if showPreview </span><span class="cov0" title="0">{
                fmt.Print(uxManager.ShowConfigPreview(cfg))
                fmt.Print("\nDo you want to continue? [y/N]: ")
                var response string
                fmt.Scanln(&amp;response)
                if response != "y" &amp;&amp; response != "Y" &amp;&amp; response != "yes" &amp;&amp; response != "Yes" </span><span class="cov0" title="0">{
                        logger.Info("Operation cancelled by user")
                        return nil
                }</span>
        }

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                logger.Info("🏃 Running in dry-run mode - no changes will be made")
        }</span>

        // Get config directory for relative path resolution
        // configDir already declared above

        // Apply repository configurations first (may be needed for package installations)
        <span class="cov0" title="0">if err := applyRepositoryConfigurations(cfg, logger, dryRun); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply repository configurations: %w", err)
        }</span>

        // Apply file configurations
        <span class="cov0" title="0">var deployedFiles []pkg.ManagedFile
        if len(cfg.Files) &gt; 0 </span><span class="cov0" title="0">{
                logger.Info("Applying file configurations")
                fileManager := pkg.NewFileManager(logger, dryRun, configDir)
                
                // Enable interactive mode on all files if global flag is set
                if interactiveMode </span><span class="cov0" title="0">{
                        cfg.Files = enableInteractiveModeOnFiles(cfg.Files)
                }</span>
                
                // Validate file permissions before proceeding
                <span class="cov0" title="0">if err := fileManager.ValidateFilePermissions(cfg.Files); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("permission validation failed: %w", err)
                }</span>

                <span class="cov0" title="0">var err error
                deployedFiles, err = fileManager.DeployFiles(cfg.Files)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to deploy files: %w", err)
                }</span>
        }

        // Apply package configurations
        <span class="cov0" title="0">if err := applyPackageConfigurations(cfg, deployedFiles, logger, dryRun, useOptimization, configDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to apply package configurations: %w", err)
        }</span>

        // Apply dconf configurations
        <span class="cov0" title="0">if len(cfg.DConf.Settings) &gt; 0 </span><span class="cov0" title="0">{
                logger.Debug("Applying dconf configurations", "count", len(cfg.DConf.Settings))
                dconfManager := pkg.NewDConfManager(logger, dryRun)
                
                // Validate dconf settings before applying
                if err := dconfManager.ValidateSettings(cfg.DConf); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("dconf validation failed: %w", err)
                }</span>
                
                <span class="cov0" title="0">if err := dconfManager.ApplySettings(cfg.DConf); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to apply dconf settings: %w", err)
                }</span>
        }

        // Apply backup policy if configured (only in non-dry-run mode)
        <span class="cov0" title="0">if !dryRun &amp;&amp; len(deployedFiles) &gt; 0 </span><span class="cov0" title="0">{
                // Load current state to get all managed files for policy enforcement
                stateManager := pkg.NewStateManager(logger)
                state, err := stateManager.LoadState()
                if err == nil &amp;&amp; cfg.BackupPolicy.AutoCleanup </span><span class="cov0" title="0">{
                        logger.Debug("Applying backup policy")
                        fileManager := pkg.NewFileManager(logger, dryRun, configDir)
                        if err := fileManager.ApplyBackupPolicy(state.Files, cfg.BackupPolicy); err != nil </span><span class="cov0" title="0">{
                                logger.Warn("Backup policy enforcement failed", "error", err)
                                // Don't fail the entire operation for backup policy issues
                        }</span>
                }
        }

        <span class="cov0" title="0">if dryRun </span><span class="cov0" title="0">{
                logger.Info("✓ Dry run completed - no actual changes were made")
        }</span> else<span class="cov0" title="0"> {
                logger.Info("✓ Configuration applied successfully")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// enableInteractiveModeOnFiles enables interactive features on all files
func enableInteractiveModeOnFiles(files map[string]config.File) map[string]config.File <span class="cov0" title="0">{
        for name, file := range files </span><span class="cov0" title="0">{
                file.Interactive = true
                files[name] = file
        }</span>
        <span class="cov0" title="0">return files</span>
}

// findConfigFile searches for a config file in standard locations
func findConfigFile() (string, error) <span class="cov0" title="0">{
        searchPaths := []string{
                "./configr.yaml",
                "~/.config/configr/configr.yaml",
                "~/configr.yaml",
                "/etc/configr/configr.yaml",
                "/usr/local/etc/configr/configr.yaml",
        }

        for _, path := range searchPaths </span><span class="cov0" title="0">{
                // Expand ~ if present
                if path[0] == '~' </span><span class="cov0" title="0">{
                        home, err := os.UserHomeDir()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">path = filepath.Join(home, path[1:])</span>
                }

                <span class="cov0" title="0">if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        return path, nil
                }</span>
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no config file found in standard locations: %v", searchPaths)</span>
}

// applyPackageConfigurations handles package management for all supported package managers
func applyPackageConfigurations(cfg *config.Config, deployedFiles []pkg.ManagedFile, logger *log.Logger, dryRun bool, useOptimization bool, configDir string) error <span class="cov0" title="0">{
        // Initialize state manager for package removal tracking
        stateManager := pkg.NewStateManager(logger)
        
        // Get packages to remove (packages in previous state but not in current config)
        packagesToRemove, err := stateManager.GetPackagesToRemove(cfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Could not determine packages to remove", "error", err)
                // Continue with installation even if removal tracking fails
                packagesToRemove = &amp;pkg.ManagedPackages{}
        }</span>

        // Get files to remove (files in previous state but not in current config)
        <span class="cov0" title="0">filesToRemove, err := stateManager.GetFilesToRemove(cfg)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Could not determine files to remove", "error", err)
                // Continue with deployment even if file removal tracking fails
                filesToRemove = []pkg.ManagedFile{}
        }</span>
        
        // Remove packages and files that are no longer in configuration (if enabled)
        <span class="cov0" title="0">if removePackages </span><span class="cov0" title="0">{
                if err := removePackagesNotInConfig(packagesToRemove, logger, dryRun); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove packages: %w", err)
                }</span>
                <span class="cov0" title="0">if err := removeFilesNotInConfig(filesToRemove, configDir, logger, dryRun); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove files: %w", err)
                }</span>
        } else<span class="cov0" title="0"> {
                logger.Debug("Package and file removal disabled by --remove-packages=false flag")
        }</span>
        // Handle APT packages
        <span class="cov0" title="0">if len(cfg.Packages.Apt) &gt; 0 </span><span class="cov0" title="0">{
                logger.Debug("Applying APT package configurations", "count", len(cfg.Packages.Apt))
                
                if useOptimization </span><span class="cov0" title="0">{
                        cacheManager := pkg.NewCacheManager(logger)
                        aptManager := pkg.NewOptimizedAptManager(logger, dryRun, cacheManager)
                        if err := aptManager.InstallPackagesOptimized(cfg.Packages.Apt, cfg.PackageDefaults); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("APT package installation failed: %w", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        aptManager := pkg.NewAptManager(logger, dryRun)
                        if err := aptManager.InstallPackages(cfg.Packages.Apt, cfg.PackageDefaults); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("APT package installation failed: %w", err)
                        }</span>
                }
        }

        // Handle Flatpak packages
        <span class="cov0" title="0">if len(cfg.Packages.Flatpak) &gt; 0 </span><span class="cov0" title="0">{
                logger.Debug("Applying Flatpak package configurations", "count", len(cfg.Packages.Flatpak))
                flatpakManager := pkg.NewFlatpakManager(logger, dryRun)
                
                // Validate Flatpak package names
                if err := flatpakManager.ValidatePackageNames(cfg.Packages.Flatpak); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Flatpak package validation failed: %w", err)
                }</span>
                
                <span class="cov0" title="0">if err := flatpakManager.InstallPackages(cfg.Packages.Flatpak, cfg.PackageDefaults); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Flatpak package installation failed: %w", err)
                }</span>
        }

        // Handle Snap packages
        <span class="cov0" title="0">if len(cfg.Packages.Snap) &gt; 0 </span><span class="cov0" title="0">{
                logger.Debug("Applying Snap package configurations", "count", len(cfg.Packages.Snap))
                snapManager := pkg.NewSnapManager(logger, dryRun)
                
                // Validate Snap package names
                if err := snapManager.ValidatePackageNames(cfg.Packages.Snap); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Snap package validation failed: %w", err)
                }</span>
                
                <span class="cov0" title="0">if err := snapManager.InstallPackages(cfg.Packages.Snap, cfg.PackageDefaults); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Snap package installation failed: %w", err)
                }</span>
        }

        // Update state file with current configuration (only if not dry-run)
        <span class="cov0" title="0">if !dryRun </span><span class="cov0" title="0">{
                if err := stateManager.UpdateState(cfg, deployedFiles); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to update state", "error", err)
                        // Don't fail the entire operation for state tracking issues
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// removePackagesNotInConfig removes packages that are no longer in the configuration
func removePackagesNotInConfig(packagesToRemove *pkg.ManagedPackages, logger *log.Logger, dryRun bool) error <span class="cov0" title="0">{
        // Remove APT packages
        if len(packagesToRemove.Apt) &gt; 0 </span><span class="cov0" title="0">{
                logger.Info("Removing APT packages no longer in configuration", "count", len(packagesToRemove.Apt))
                aptManager := pkg.NewAptManager(logger, dryRun)
                if err := aptManager.RemovePackages(packagesToRemove.Apt); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("APT package removal failed: %w", err)
                }</span>
        }

        // Remove Flatpak packages
        <span class="cov0" title="0">if len(packagesToRemove.Flatpak) &gt; 0 </span><span class="cov0" title="0">{
                logger.Info("Removing Flatpak packages no longer in configuration", "count", len(packagesToRemove.Flatpak))
                flatpakManager := pkg.NewFlatpakManager(logger, dryRun)
                if err := flatpakManager.RemovePackages(packagesToRemove.Flatpak); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Flatpak package removal failed: %w", err)
                }</span>
        }

        // Remove Snap packages
        <span class="cov0" title="0">if len(packagesToRemove.Snap) &gt; 0 </span><span class="cov0" title="0">{
                logger.Info("Removing Snap packages no longer in configuration", "count", len(packagesToRemove.Snap))
                snapManager := pkg.NewSnapManager(logger, dryRun)
                if err := snapManager.RemovePackages(packagesToRemove.Snap); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Snap package removal failed: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// removeFilesNotInConfig removes files that are no longer in the configuration
func removeFilesNotInConfig(filesToRemove []pkg.ManagedFile, configDir string, logger *log.Logger, dryRun bool) error <span class="cov0" title="0">{
        if len(filesToRemove) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">logger.Info("Removing files no longer in configuration", "count", len(filesToRemove))
        fileManager := pkg.NewFileManager(logger, dryRun, configDir)
        
        return fileManager.RemoveFiles(filesToRemove)</span>
}

// applyRepositoryConfigurations handles repository management for all supported repository types
func applyRepositoryConfigurations(cfg *config.Config, logger *log.Logger, dryRun bool) error <span class="cov0" title="0">{
        // Check if there are any repositories to process
        if len(cfg.Repositories.Apt) == 0 &amp;&amp; len(cfg.Repositories.Flatpak) == 0 </span><span class="cov0" title="0">{
                logger.Debug("No repositories to process")
                return nil
        }</span>

        <span class="cov0" title="0">logger.Debug("Applying repository configurations", 
                "apt_count", len(cfg.Repositories.Apt), 
                "flatpak_count", len(cfg.Repositories.Flatpak))
        
        repoManager := pkg.NewRepositoryManager(logger, dryRun)
        if err := repoManager.AddRepositories(cfg.Repositories); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("repository management failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package configr

import (
        "fmt"
        "os"

        "github.com/bashfulrobot/configr/internal/pkg"
        "github.com/charmbracelet/log"
        "github.com/spf13/cobra"
)

var cacheCmd = &amp;cobra.Command{
        Use:   "cache",
        Short: "Manage configuration and system state cache",
        Long: `Cache management commands for configr optimization system.

The cache stores parsed configurations and system state to speed up repeated runs.
Cache data is stored in ~/.cache/configr/ by default.`,
        Example: `  configr cache stats    # Show cache statistics
  configr cache clear    # Clear all cached data
  configr cache info     # Show cache information`,
}

var cacheStatsCmd = &amp;cobra.Command{
        Use:   "stats",
        Short: "Show cache usage statistics",
        Long: `Display statistics about cache usage including file count, total size,
and last modification time.`,
        RunE: runCacheStats,
}

var cacheClearCmd = &amp;cobra.Command{
        Use:   "clear",
        Short: "Clear all cached data",
        Long: `Remove all cached configuration and system state data.
This will force the next run to rebuild all caches.`,
        RunE: runCacheClear,
}

var cacheInfoCmd = &amp;cobra.Command{
        Use:   "info",
        Short: "Show cache system information",
        Long: `Display information about the cache system including cache directory
location and current optimization settings.`,
        RunE: runCacheInfo,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(cacheCmd)
        
        // Add subcommands
        cacheCmd.AddCommand(cacheStatsCmd)
        cacheCmd.AddCommand(cacheClearCmd)
        cacheCmd.AddCommand(cacheInfoCmd)
}</span>

func runCacheStats(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        logger := log.NewWithOptions(os.Stderr, log.Options{
                ReportCaller:    false,
                ReportTimestamp: false,
                Prefix:          "configr",
        })

        cacheManager := pkg.NewCacheManager(logger)
        stats, err := cacheManager.GetCacheStats()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get cache stats: %w", err)
        }</span>

        // Display cache statistics
        <span class="cov0" title="0">fmt.Printf("Cache Statistics\n")
        fmt.Printf("================\n\n")
        fmt.Printf("Cache Directory: %s\n", stats.CacheDir)
        fmt.Printf("Total Files:     %d\n", stats.TotalFiles)
        fmt.Printf("Total Size:      %s\n", formatBytes(stats.TotalSize))
        
        if !stats.LastModified.IsZero() </span><span class="cov0" title="0">{
                fmt.Printf("Last Modified:   %s\n", stats.LastModified.Format("2006-01-02 15:04:05"))
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Last Modified:   Never\n")
        }</span>

        <span class="cov0" title="0">if stats.TotalFiles == 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n💡 Cache is empty. Run 'configr apply --optimize' to build cache.\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\n✓ Cache contains %d files (%s total)\n", stats.TotalFiles, formatBytes(stats.TotalSize))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func runCacheClear(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        logger := log.NewWithOptions(os.Stderr, log.Options{
                ReportCaller:    false,
                ReportTimestamp: false,
                Prefix:          "configr",
        })

        cacheManager := pkg.NewCacheManager(logger)
        
        // Get stats before clearing
        stats, err := cacheManager.GetCacheStats()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to get cache stats before clearing", "error", err)
        }</span>

        <span class="cov0" title="0">if err := cacheManager.ClearCache(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear cache: %w", err)
        }</span>

        <span class="cov0" title="0">if stats != nil &amp;&amp; stats.TotalFiles &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("✓ Cleared cache: %d files (%s) removed\n", stats.TotalFiles, formatBytes(stats.TotalSize))
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✓ Cache cleared (was already empty)\n")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func runCacheInfo(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        logger := log.NewWithOptions(os.Stderr, log.Options{
                ReportCaller:    false,
                ReportTimestamp: false,
                Prefix:          "configr",
        })

        cacheManager := pkg.NewCacheManager(logger)
        stats, err := cacheManager.GetCacheStats()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get cache info: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Cache System Information\n")
        fmt.Printf("========================\n\n")
        fmt.Printf("Cache Directory:     %s\n", stats.CacheDir)
        fmt.Printf("Optimization:        Enabled by default\n")
        fmt.Printf("Cache TTL:           1 hour (system state)\n")
        fmt.Printf("Config Cache:        Persistent until files change\n")
        fmt.Printf("Package Cache:       10 minutes (installation status)\n")
        
        fmt.Printf("\nCache Types:\n")
        fmt.Printf("- Configuration Cache: Parsed YAML configurations\n")
        fmt.Printf("- System State Cache:  Package installation status\n")
        fmt.Printf("- File State Cache:    File modification tracking\n")
        
        fmt.Printf("\nCommands:\n")
        fmt.Printf("- Enable:  configr apply --optimize=true (default)\n")
        fmt.Printf("- Disable: configr apply --optimize=false\n")
        fmt.Printf("- Clear:   configr cache clear\n")
        fmt.Printf("- Stats:   configr cache stats\n")

        return nil</span>
}

// formatBytes formats byte count as human-readable string
func formatBytes(bytes int64) string <span class="cov0" title="0">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", bytes)
        }</span>
        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f %cB", float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package configr

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
)

var completionCmd = &amp;cobra.Command{
        Use:   "completion [bash|zsh|fish|powershell]",
        Short: "Generate shell completion scripts",
        Long: `Generate shell completion scripts for configr.

The completion script for the given shell will be written to stdout.
To load completions, add the output to your shell's completion directory
or source it directly.`,
        Example: `  # Bash (add to ~/.bashrc)
  configr completion bash &gt; /etc/bash_completion.d/configr
  source &lt;(configr completion bash)

  # Zsh (add to ~/.zshrc)
  configr completion zsh &gt; /usr/local/share/zsh/site-functions/_configr
  source &lt;(configr completion zsh)

  # Fish
  configr completion fish &gt; ~/.config/fish/completions/configr.fish

  # PowerShell (add to your PowerShell profile)
  configr completion powershell | Out-String | Invoke-Expression`,
        DisableFlagsInUseLine: true,
        ValidArgs:             []string{"bash", "zsh", "fish", "powershell"},
        Args:                  cobra.MatchAll(cobra.ExactArgs(1), cobra.OnlyValidArgs),
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                shell := args[0]
                
                switch shell </span>{
                case "bash":<span class="cov0" title="0">
                        return rootCmd.GenBashCompletion(os.Stdout)</span>
                case "zsh":<span class="cov0" title="0">
                        return rootCmd.GenZshCompletion(os.Stdout)</span>
                case "fish":<span class="cov0" title="0">
                        return rootCmd.GenFishCompletion(os.Stdout, true)</span>
                case "powershell":<span class="cov0" title="0">
                        return rootCmd.GenPowerShellCompletionWithDesc(os.Stdout)</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unsupported shell: %s", shell)</span>
                }
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(completionCmd)
        
        // Add custom completion for config files
        rootCmd.RegisterFlagCompletionFunc("config", func(cmd *cobra.Command, args []string, toComplete string) ([]string, cobra.ShellCompDirective) </span><span class="cov0" title="0">{
                return []string{"yaml", "yml"}, cobra.ShellCompDirectiveFilterFileExt
        }</span>)
}</pre>
		
		<pre class="file" id="file3" style="display: none">package configr

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
        "gopkg.in/yaml.v3"
)

var includesCmd = &amp;cobra.Command{
        Use:   "includes [config-file]",
        Short: "Debug and analyze include system behavior",
        Long: `Analyze the include system behavior for configuration files.

This command helps debug advanced include features by showing:
- Which files would be included based on current system conditions
- System information used for conditional includes
- Include resolution order and any conflicts
- Validation of glob patterns and conditions

Useful for debugging complex configurations with conditional includes.`,
        Example: `  configr includes                      # Analyze default config includes
  configr includes my-config.yaml        # Analyze specific config
  configr includes --show-system         # Show system detection info
  configr includes --dry-run             # Show what would be included
  configr includes --validate-only       # Only validate include specs`,
        Args: cobra.MaximumNArgs(1),
        RunE: runIncludes,
}

var (
        showSystemInfo  bool
        includesDryRun  bool
        validateOnly    bool
)

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(includesCmd)
        
        includesCmd.Flags().BoolVar(&amp;showSystemInfo, "show-system", false, "show system detection information")
        includesCmd.Flags().BoolVar(&amp;includesDryRun, "dry-run", false, "show what would be included without loading")
        includesCmd.Flags().BoolVar(&amp;validateOnly, "validate-only", false, "only validate include specifications")
}</span>

func runIncludes(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Set verbose mode
        verbose, _ := cmd.Flags().GetBool("verbose")
        config.SetVerbose(verbose)

        // Determine config file path
        var configPath string
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                configPath = args[0]
        }</span> else<span class="cov0" title="0"> if viper.GetString("config") != "" </span><span class="cov0" title="0">{
                configPath = viper.GetString("config")
        }</span> else<span class="cov0" title="0"> {
                // Find config file in standard locations
                var err error
                configPath, err = findConfigFile()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to find config file: %w", err)
                }</span>
        }

        <span class="cov0" title="0">config.Info("Analyzing includes for configuration: %s", configPath)

        // Show system information if requested
        if showSystemInfo </span><span class="cov0" title="0">{
                if err := showSystemInformation(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to show system information: %w", err)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span> // Add spacing
        }

        // Create advanced loader
        <span class="cov0" title="0">loader := config.NewAdvancedLoader()

        // If validate-only, just validate the include specs
        if validateOnly </span><span class="cov0" title="0">{
                return validateIncludeSpecs(configPath, loader)
        }</span>

        // If dry-run, analyze what would be included
        <span class="cov0" title="0">if includesDryRun </span><span class="cov0" title="0">{
                return analyzeIncludes(configPath, loader)
        }</span>

        // Full analysis with actual loading
        <span class="cov0" title="0">return fullIncludeAnalysis(configPath, loader)</span>
}

func showSystemInformation() error <span class="cov0" title="0">{
        loader := config.NewAdvancedLoader()
        sysInfo := loader.GetSystemInfo()

        config.Info("System Information:")
        
        // Sort keys for consistent output
        keys := make([]string, 0, len(sysInfo))
        for key := range sysInfo </span><span class="cov0" title="0">{
                keys = append(keys, key)
        }</span>
        <span class="cov0" title="0">sort.Strings(keys)

        for _, key := range keys </span><span class="cov0" title="0">{
                value := sysInfo[key]
                if strings.HasPrefix(key, "env_") </span><span class="cov0" title="0">{
                        config.Info("  %s: %s", key, value)
                }</span> else<span class="cov0" title="0"> {
                        config.Success("  %s: %s", key, value)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func validateIncludeSpecs(configPath string, loader *config.AdvancedLoader) error <span class="cov0" title="0">{
        // Read the config file to get include specs
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">var cfg config.Config
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse config: %w", err)
        }</span>

        <span class="cov0" title="0">config.Info("Validating include specifications...")

        // Validate includes
        if len(cfg.Includes) &gt; 0 </span><span class="cov0" title="0">{
                config.Info("Includes (%d):", len(cfg.Includes))
                for i, spec := range cfg.Includes </span><span class="cov0" title="0">{
                        config.Info("  [%d] %s", i+1, describeIncludeSpec(spec))
                        
                        if err := loader.ValidateIncludeSpec(spec); err != nil </span><span class="cov0" title="0">{
                                config.Error("    Validation failed: %v", err)
                        }</span> else<span class="cov0" title="0"> {
                                config.Success("    ✓ Valid")
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                config.Info("No includes found in configuration")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func analyzeIncludes(configPath string, loader *config.AdvancedLoader) error <span class="cov0" title="0">{
        config.Info("Analyzing includes (dry-run mode)...")

        // This would require extending the loader to support dry-run analysis
        // For now, we'll do basic analysis
        return validateIncludeSpecs(configPath, loader)
}</span>

func fullIncludeAnalysis(configPath string, loader *config.AdvancedLoader) error <span class="cov0" title="0">{
        config.Info("Loading configuration with full include analysis...")

        // Load configuration with advanced includes
        cfg, loadedPaths, err := loader.LoadConfigurationAdvanced(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        <span class="cov0" title="0">config.Success("✓ Configuration loaded successfully")
        config.Info("Loaded files (%d):", len(loadedPaths))

        baseDir := filepath.Dir(configPath)
        for i, path := range loadedPaths </span><span class="cov0" title="0">{
                // Show relative path when possible
                relPath, err := filepath.Rel(baseDir, path)
                if err != nil </span><span class="cov0" title="0">{
                        relPath = path
                }</span>
                <span class="cov0" title="0">config.Info("  [%d] %s", i+1, relPath)</span>
        }

        // Show configuration summary
        <span class="cov0" title="0">config.Info("Configuration summary:")
        config.Info("  Version: %s", cfg.Version)
        config.Info("  APT packages: %d", len(cfg.Packages.Apt))
        config.Info("  Flatpak packages: %d", len(cfg.Packages.Flatpak))
        config.Info("  Snap packages: %d", len(cfg.Packages.Snap))
        config.Info("  Files: %d", len(cfg.Files))
        config.Info("  DConf settings: %d", len(cfg.DConf.Settings))

        return nil</span>
}

func describeIncludeSpec(spec config.IncludeSpec) string <span class="cov0" title="0">{
        var parts []string

        if spec.Path != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("path: %s", spec.Path))
        }</span>

        <span class="cov0" title="0">if spec.Optional </span><span class="cov0" title="0">{
                parts = append(parts, "optional")
        }</span>

        <span class="cov0" title="0">if len(spec.Conditions) &gt; 0 </span><span class="cov0" title="0">{
                conditionStrs := make([]string, len(spec.Conditions))
                for i, condition := range spec.Conditions </span><span class="cov0" title="0">{
                        conditionStrs[i] = fmt.Sprintf("%s=%s", condition.Type, condition.Value)
                }</span>
                <span class="cov0" title="0">parts = append(parts, fmt.Sprintf("conditions: [%s]", strings.Join(conditionStrs, ", ")))</span>
        }

        <span class="cov0" title="0">if spec.Description != "" </span><span class="cov0" title="0">{
                parts = append(parts, fmt.Sprintf("desc: %s", spec.Description))
        }</span>

        <span class="cov0" title="0">return strings.Join(parts, ", ")</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package configr

import (
        "os"
        "os/exec"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/spf13/cobra"
)

type Tool struct {
        Name        string
        Command     string
        PackageName string
        Description string
        Required    bool
}

var requiredTools = []Tool{
        {
                Name:        "APT",
                Command:     "apt",
                PackageName: "", // Pre-installed on Ubuntu/Debian
                Description: "Advanced Package Tool for managing .deb packages",
                Required:    true,
        },
        {
                Name:        "DConf",
                Command:     "dconf",
                PackageName: "dconf-cli",
                Description: "Configuration system for GNOME and GTK applications",
                Required:    true,
        },
}

var optionalTools = []Tool{
        {
                Name:        "Flatpak",
                Command:     "flatpak",
                PackageName: "flatpak",
                Description: "Universal application distribution framework",
                Required:    false,
        },
        {
                Name:        "Snap",
                Command:     "snap",
                PackageName: "snapd",
                Description: "Universal package manager by Canonical",
                Required:    false,
        },
}

var initCmd = &amp;cobra.Command{
        Use:   "init",
        Short: "Verify system readiness and install missing dependencies",
        Long: `Check for required tools and dependencies needed by configr.
        
This command verifies that all required tools (apt, dconf) are available
and offers to install missing optional tools (flatpak, snapd).`,
        Example: `  configr init                    # Check system readiness
  configr init --install-missing   # Auto-install missing tools
  configr init --check-only        # Only check, don't offer installation`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                verbose, _ := cmd.Flags().GetBool("verbose")
                installMissing, _ := cmd.Flags().GetBool("install-missing")
                checkOnly, _ := cmd.Flags().GetBool("check-only")

                config.SetVerbose(verbose)

                config.Info("Checking system readiness for configr...")

                allToolsAvailable := true
                missingRequired := []Tool{}
                missingOptional := []Tool{}

                // Check required tools
                config.Info("Checking required tools...")
                for _, tool := range requiredTools </span><span class="cov0" title="0">{
                        if isToolAvailable(tool.Command) </span><span class="cov0" title="0">{
                                config.Success("%s: ✓ Available", tool.Name)
                                if verbose </span><span class="cov0" title="0">{
                                        config.Debug("%s found at: %s", tool.Name, getToolPath(tool.Command))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                config.Error("%s: ✗ Missing", tool.Name)
                                config.Info("  %s", tool.Description)
                                missingRequired = append(missingRequired, tool)
                                allToolsAvailable = false
                        }</span>
                }

                // Check optional tools
                <span class="cov0" title="0">config.Info("Checking optional tools...")
                for _, tool := range optionalTools </span><span class="cov0" title="0">{
                        if isToolAvailable(tool.Command) </span><span class="cov0" title="0">{
                                config.Success("%s: ✓ Available", tool.Name)
                                if verbose </span><span class="cov0" title="0">{
                                        config.Debug("%s found at: %s", tool.Name, getToolPath(tool.Command))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                config.Warning("%s: ○ Not installed", tool.Name)
                                config.Info("  %s", tool.Description)
                                missingOptional = append(missingOptional, tool)
                        }</span>
                }

                // Handle missing required tools
                <span class="cov0" title="0">if len(missingRequired) &gt; 0 </span><span class="cov0" title="0">{
                        config.Error("Missing required tools detected!")
                        for _, tool := range missingRequired </span><span class="cov0" title="0">{
                                if tool.PackageName != "" </span><span class="cov0" title="0">{
                                        config.Info("To install %s: sudo apt install %s", tool.Name, tool.PackageName)
                                }</span> else<span class="cov0" title="0"> {
                                        config.Info("%s should be pre-installed on Ubuntu/Debian systems", tool.Name)
                                }</span>
                        }
                        
                        <span class="cov0" title="0">if installMissing &amp;&amp; !checkOnly </span><span class="cov0" title="0">{
                                config.Info("Attempting to install missing required tools...")
                                for _, tool := range missingRequired </span><span class="cov0" title="0">{
                                        if tool.PackageName != "" </span><span class="cov0" title="0">{
                                                if err := installPackage(tool.PackageName); err != nil </span><span class="cov0" title="0">{
                                                        config.Error("Failed to install %s: %v", tool.Name, err)
                                                }</span> else<span class="cov0" title="0"> {
                                                        config.Success("Successfully installed %s", tool.Name)
                                                }</span>
                                        }
                                }
                        }
                }

                // Handle missing optional tools
                <span class="cov0" title="0">if len(missingOptional) &gt; 0 &amp;&amp; !checkOnly </span><span class="cov0" title="0">{
                        config.Info("Optional tools available for installation:")
                        for _, tool := range missingOptional </span><span class="cov0" title="0">{
                                config.Info("  %s: sudo apt install %s", tool.Name, tool.PackageName)
                        }</span>

                        <span class="cov0" title="0">if installMissing </span><span class="cov0" title="0">{
                                config.Info("Installing missing optional tools...")
                                for _, tool := range missingOptional </span><span class="cov0" title="0">{
                                        if err := installPackage(tool.PackageName); err != nil </span><span class="cov0" title="0">{
                                                config.Warning("Failed to install %s: %v", tool.Name, err)
                                        }</span> else<span class="cov0" title="0"> {
                                                config.Success("Successfully installed %s", tool.Name)
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                config.Info("Use --install-missing to automatically install optional tools")
                        }</span>
                }

                // Final system readiness report
                <span class="cov0" title="0">config.Info("System readiness summary:")
                if allToolsAvailable &amp;&amp; len(missingOptional) == 0 </span><span class="cov0" title="0">{
                        config.Success("✓ System is fully ready for configr")
                }</span> else<span class="cov0" title="0"> if allToolsAvailable </span><span class="cov0" title="0">{
                        config.Success("✓ System meets minimum requirements for configr")
                        config.Info("Optional tools can be installed for additional functionality")
                }</span> else<span class="cov0" title="0"> {
                        config.Error("✗ System is not ready - missing required tools")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                        config.Debug("All checks completed")
                }</span>
        },
}

func isToolAvailable(command string) bool <span class="cov8" title="1">{
        _, err := exec.LookPath(command)
        return err == nil
}</span>

func getToolPath(command string) string <span class="cov8" title="1">{
        path, err := exec.LookPath(command)
        if err != nil </span><span class="cov8" title="1">{
                return "not found"
        }</span>
        <span class="cov8" title="1">return path</span>
}

func installPackage(packageName string) error <span class="cov0" title="0">{
        config.Info("Installing %s...", packageName)
        
        // Check if running as root or with sudo
        if os.Geteuid() != 0 </span><span class="cov0" title="0">{
                // Try with sudo
                cmd := exec.Command("sudo", "apt", "install", "-y", packageName)
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr
                cmd.Stdin = os.Stdin
                return cmd.Run()
        }</span> else<span class="cov0" title="0"> {
                // Running as root
                cmd := exec.Command("apt", "install", "-y", packageName)
                cmd.Stdout = os.Stdout
                cmd.Stderr = os.Stderr
                return cmd.Run()
        }</span>
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(initCmd)
        initCmd.Flags().Bool("install-missing", false, "Automatically install missing tools")
        initCmd.Flags().Bool("check-only", false, "Only check tool availability, don't offer installation")
        initCmd.Flags().BoolP("verbose", "v", false, "Show detailed information about tool locations")
}</pre>
		
		<pre class="file" id="file5" style="display: none">package configr

import (
        "fmt"
        "os"
        "path/filepath"

        mango "github.com/muesli/mango-cobra"
        "github.com/muesli/roff"
        "github.com/spf13/cobra"
)

var manCmd = &amp;cobra.Command{
        Use:   "man",
        Short: "Generate Unix man pages",
        Long: `Generate Unix man pages for configr and all its subcommands.

The man pages will be written to the specified directory, or to a temporary
directory if none is specified. The generated files can then be installed
to your system's man page directory.`,
        Example: `  configr man                          # Generate to temp directory
  configr man /usr/local/share/man     # Generate to system location
  configr man ./docs/man               # Generate to docs directory`,
        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                var manDir string
                if len(args) &gt; 0 </span><span class="cov8" title="1">{
                        manDir = args[0]
                }</span> else<span class="cov8" title="1"> {
                        // Use temporary directory if none specified
                        tmpDir, err := os.MkdirTemp("", "configr-man-")
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create temporary directory: %w", err)
                        }</span>
                        <span class="cov8" title="1">manDir = tmpDir
                        defer fmt.Printf("Man pages generated in: %s\n", manDir)</span>
                }

                // Ensure directory exists
                <span class="cov8" title="1">if err := os.MkdirAll(manDir, 0755); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to create directory %s: %w", manDir, err)
                }</span>

                // Generate man pages for all commands
                <span class="cov8" title="1">manPage, err := mango.NewManPage(1, rootCmd)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create man page: %w", err)
                }</span>

                // Set additional metadata
                <span class="cov8" title="1">manPage = manPage.WithSection("SEE ALSO", "configr-validate(1), configr-apply(1), configr-init(1), configr-cache(1)")

                // Convert to roff format
                roffContent := manPage.Build(roff.NewDocument())
                

                // Write main man page
                mainManPath := filepath.Join(manDir, "configr.1")
                if err := os.WriteFile(mainManPath, []byte(roffContent), 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write man page %s: %w", mainManPath, err)
                }</span>

                // Generate man pages for subcommands
                <span class="cov8" title="1">for _, subCmd := range rootCmd.Commands() </span><span class="cov8" title="1">{
                        if subCmd.Name() == "help" </span><span class="cov8" title="1">{
                                continue</span> // Skip help command
                        }

                        <span class="cov8" title="1">subManPage, err := mango.NewManPage(1, subCmd)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: failed to create man page for %s: %v\n", subCmd.Name(), err)
                                continue</span>
                        }

                        <span class="cov8" title="1">subManPage = subManPage.WithSection("SEE ALSO", fmt.Sprintf("configr(1), configr-%s(1)", subCmd.Name()))

                        subRoffContent := subManPage.Build(roff.NewDocument())

                        subManPath := filepath.Join(manDir, fmt.Sprintf("configr-%s.1", subCmd.Name()))
                        if err := os.WriteFile(subManPath, []byte(subRoffContent), 0644); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: failed to write man page %s: %v\n", subManPath, err)
                                continue</span>
                        }
                }

                // List generated files
                <span class="cov8" title="1">files, err := filepath.Glob(filepath.Join(manDir, "configr*.1"))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to list generated files: %w", err)
                }</span>

                <span class="cov8" title="1">fmt.Printf("Successfully generated %d man pages:\n", len(files))
                for _, file := range files </span><span class="cov8" title="1">{
                        fmt.Printf("  %s\n", file)
                }</span>

                // Provide installation instructions
                <span class="cov8" title="1">if len(args) == 0 </span><span class="cov8" title="1">{
                        fmt.Printf("\nTo install system-wide, copy the files to your man page directory:\n")
                        fmt.Printf("  sudo cp %s/*.1 /usr/local/share/man/man1/\n", manDir)
                        fmt.Printf("  sudo mandb  # Update man page database\n")
                }</span>

                <span class="cov8" title="1">return nil</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(manCmd)
}</pre>
		
		<pre class="file" id="file6" style="display: none">package configr

import (
        "fmt"
        "os"
        "strings"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/bashfulrobot/configr/internal/pkg"
        "github.com/charmbracelet/log"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var packagesCmd = &amp;cobra.Command{
        Use:   "packages",
        Short: "Package management operations",
        Long: `Package management operations for APT, Flatpak, and Snap packages.

This command provides advanced package management capabilities including:
- Search for packages across all package managers
- Get detailed information about packages
- List and upgrade packages
- Manage package dependencies

Use the subcommands to perform specific package operations.`,
        Example: `  configr packages search firefox     # Search for firefox packages
  configr packages info vim           # Get information about vim package  
  configr packages list               # List all installed packages
  configr packages upgrade            # Upgrade all packages`,
}

var packageSearchCmd = &amp;cobra.Command{
        Use:   "search &lt;search-term&gt;",
        Short: "Search for packages across all package managers",
        Long: `Search for packages across APT, Flatpak, and Snap package managers.

This command searches all available package managers and returns matching packages
with their respective package manager type.`,
        Example: `  configr packages search firefox     # Search for firefox packages
  configr packages search --type apt vim  # Search only in APT
  configr packages search --type flatpak code # Search only in Flatpak`,
        Args: cobra.ExactArgs(1),
        RunE: runPackageSearch,
}

var packageInfoCmd = &amp;cobra.Command{
        Use:   "info &lt;package-name&gt;",
        Short: "Get detailed information about a package",
        Long: `Get detailed information about a specific package.

This command queries the appropriate package manager to get comprehensive
information about the specified package including version, description,
dependencies, and installation status.`,
        Example: `  configr packages info vim           # Get info about vim package
  configr packages info --type flatpak org.mozilla.Firefox  # Get Flatpak info
  configr packages info --type snap code     # Get Snap info`,
        Args: cobra.ExactArgs(1),
        RunE: runPackageInfo,
}

var packageListCmd = &amp;cobra.Command{
        Use:   "list",
        Short: "List installed packages from all package managers",
        Long: `List all installed packages from APT, Flatpak, and Snap package managers.

This command provides an overview of all packages currently installed on the system
across all supported package managers.`,
        Example: `  configr packages list               # List all installed packages
  configr packages list --type apt    # List only APT packages
  configr packages list --upgradable  # List packages that can be upgraded`,
        RunE: runPackageList,
}

var packageUpgradeCmd = &amp;cobra.Command{
        Use:   "upgrade [package-names...]",
        Short: "Upgrade packages across all package managers",
        Long: `Upgrade packages across APT, Flatpak, and Snap package managers.

This command can upgrade all packages or specific packages. When no package names
are provided, it will upgrade all packages from all package managers.`,
        Example: `  configr packages upgrade            # Upgrade all packages
  configr packages upgrade vim git    # Upgrade specific packages
  configr packages upgrade --type apt # Upgrade only APT packages`,
        RunE: runPackageUpgrade,
}

var packageDepsCmd = &amp;cobra.Command{
        Use:   "deps &lt;package-name&gt;",
        Short: "Show package dependencies and installation simulation",
        Long: `Show package dependencies and simulate what would be installed.

This command analyzes package dependencies and shows what packages would be
installed as dependencies. Currently supports APT packages with full dependency
resolution and simulation.`,
        Example: `  configr packages deps vim           # Show vim dependencies
  configr packages deps --simulate git # Simulate git installation
  configr packages deps --tree vim     # Show dependency tree`,
        Args: cobra.ExactArgs(1),
        RunE: runPackageDeps,
}

var (
        packageType    string
        showUpgradable bool
        simulate       bool
        showTree       bool
)

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(packagesCmd)
        packagesCmd.AddCommand(packageSearchCmd)
        packagesCmd.AddCommand(packageInfoCmd)
        packagesCmd.AddCommand(packageListCmd)
        packagesCmd.AddCommand(packageUpgradeCmd)
        packagesCmd.AddCommand(packageDepsCmd)

        // Add common flags
        packageSearchCmd.Flags().StringVar(&amp;packageType, "type", "", "package manager type (apt, flatpak, snap)")
        packageInfoCmd.Flags().StringVar(&amp;packageType, "type", "", "package manager type (apt, flatpak, snap)")
        packageListCmd.Flags().StringVar(&amp;packageType, "type", "", "package manager type (apt, flatpak, snap)")
        packageListCmd.Flags().BoolVar(&amp;showUpgradable, "upgradable", false, "show only packages that can be upgraded")
        packageUpgradeCmd.Flags().StringVar(&amp;packageType, "type", "", "package manager type (apt, flatpak, snap)")
        packageDepsCmd.Flags().BoolVar(&amp;simulate, "simulate", false, "simulate installation to show what would be installed")
        packageDepsCmd.Flags().BoolVar(&amp;showTree, "tree", false, "show dependency tree (currently shows dependencies only)")
}</span>

func runPackageSearch(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        searchTerm := args[0]
        
        logger := log.NewWithOptions(os.Stderr, log.Options{
                ReportCaller:    false,
                ReportTimestamp: false,
        })

        // Set up dry run mode
        dryRun := viper.GetBool("dry_run")
        
        fmt.Printf("🔍 Searching for packages matching '%s'...\n\n", searchTerm)

        var allPackages []PackageResult
        
        // Search in APT if no specific type or type is apt
        if packageType == "" || packageType == "apt" </span><span class="cov0" title="0">{
                aptManager := pkg.NewAptManager(logger, dryRun)
                aptPackages, err := aptManager.SearchPackages(searchTerm)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to search APT packages", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        for _, pkg := range aptPackages </span><span class="cov0" title="0">{
                                allPackages = append(allPackages, PackageResult{
                                        Name:    pkg,
                                        Manager: "apt",
                                })
                        }</span>
                }
        }

        // Search in Flatpak if no specific type or type is flatpak  
        <span class="cov0" title="0">if packageType == "" || packageType == "flatpak" </span><span class="cov0" title="0">{
                flatpakManager := pkg.NewFlatpakManager(logger, dryRun)
                flatpakPackages, err := flatpakManager.SearchPackages(searchTerm)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to search Flatpak packages", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        for _, pkg := range flatpakPackages </span><span class="cov0" title="0">{
                                allPackages = append(allPackages, PackageResult{
                                        Name:    pkg,
                                        Manager: "flatpak",
                                })
                        }</span>
                }
        }

        // Search in Snap if no specific type or type is snap
        <span class="cov0" title="0">if packageType == "" || packageType == "snap" </span><span class="cov0" title="0">{
                snapManager := pkg.NewSnapManager(logger, dryRun)
                snapPackages, err := snapManager.SearchPackages(searchTerm)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to search Snap packages", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        for _, pkg := range snapPackages </span><span class="cov0" title="0">{
                                allPackages = append(allPackages, PackageResult{
                                        Name:    pkg,
                                        Manager: "snap",
                                })
                        }</span>
                }
        }

        // Display results
        <span class="cov0" title="0">if len(allPackages) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("❌ No packages found matching '%s'\n", searchTerm)
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Found %d packages:\n\n", len(allPackages))
        
        // Group by package manager for better display
        aptPackages := []string{}
        flatpakPackages := []string{}
        snapPackages := []string{}
        
        for _, pkg := range allPackages </span><span class="cov0" title="0">{
                switch pkg.Manager </span>{
                case "apt":<span class="cov0" title="0">
                        aptPackages = append(aptPackages, pkg.Name)</span>
                case "flatpak":<span class="cov0" title="0">
                        flatpakPackages = append(flatpakPackages, pkg.Name)</span>
                case "snap":<span class="cov0" title="0">
                        snapPackages = append(snapPackages, pkg.Name)</span>
                }
        }

        <span class="cov0" title="0">if len(aptPackages) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("📦 APT Packages (%d):\n", len(aptPackages))
                for _, pkg := range aptPackages </span><span class="cov0" title="0">{
                        fmt.Printf("  • %s\n", pkg)
                }</span>
                <span class="cov0" title="0">fmt.Print("\n")</span>
        }

        <span class="cov0" title="0">if len(flatpakPackages) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("📱 Flatpak Applications (%d):\n", len(flatpakPackages))
                for _, pkg := range flatpakPackages </span><span class="cov0" title="0">{
                        fmt.Printf("  • %s\n", pkg)
                }</span>
                <span class="cov0" title="0">fmt.Print("\n")</span>
        }

        <span class="cov0" title="0">if len(snapPackages) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("🫰 Snap Packages (%d):\n", len(snapPackages))
                for _, pkg := range snapPackages </span><span class="cov0" title="0">{
                        fmt.Printf("  • %s\n", pkg)
                }</span>
                <span class="cov0" title="0">fmt.Print("\n")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func runPackageInfo(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        packageName := args[0]
        
        logger := log.NewWithOptions(os.Stderr, log.Options{
                ReportCaller:    false,
                ReportTimestamp: false,
        })

        // Set up dry run mode
        dryRun := viper.GetBool("dry_run")

        fmt.Printf("📋 Getting information for package '%s'...\n\n", packageName)

        // Try to determine package manager from package name if not specified
        if packageType == "" </span><span class="cov0" title="0">{
                if strings.Contains(packageName, ".") &amp;&amp; len(strings.Split(packageName, ".")) &gt;= 3 </span><span class="cov0" title="0">{
                        packageType = "flatpak"
                }</span> else<span class="cov0" title="0"> if strings.Contains(packageName, "/") </span><span class="cov0" title="0">{
                        packageType = "apt"
                }</span> else <span class="cov0" title="0">{
                        // Default to checking all managers
                }</span>
        }

        <span class="cov0" title="0">var info string
        var err error
        var foundManager string

        // Get info from APT if no specific type or type is apt
        if packageType == "" || packageType == "apt" </span><span class="cov0" title="0">{
                aptManager := pkg.NewAptManager(logger, dryRun)
                info, err = aptManager.GetPackageInfo(packageName)
                if err == nil &amp;&amp; info != "" </span><span class="cov0" title="0">{
                        foundManager = "apt"
                }</span>
        }

        // Try Flatpak if APT didn't work and no specific type or type is flatpak
        <span class="cov0" title="0">if (packageType == "" || packageType == "flatpak") &amp;&amp; foundManager == "" </span><span class="cov0" title="0">{
                flatpakManager := pkg.NewFlatpakManager(logger, dryRun)
                info, err = flatpakManager.GetPackageInfo(packageName)
                if err == nil &amp;&amp; info != "" </span><span class="cov0" title="0">{
                        foundManager = "flatpak"
                }</span>
        }

        // Try Snap if others didn't work and no specific type or type is snap
        <span class="cov0" title="0">if (packageType == "" || packageType == "snap") &amp;&amp; foundManager == "" </span><span class="cov0" title="0">{
                snapManager := pkg.NewSnapManager(logger, dryRun)
                info, err = snapManager.GetPackageInfo(packageName)
                if err == nil &amp;&amp; info != "" </span><span class="cov0" title="0">{
                        foundManager = "snap"
                }</span>
        }

        <span class="cov0" title="0">if foundManager == "" </span><span class="cov0" title="0">{
                if packageType != "" </span><span class="cov0" title="0">{
                        fmt.Printf("❌ Package '%s' not found in %s\n", packageName, packageType)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("❌ Package '%s' not found in any package manager\n", packageName)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        // Display the package info
        <span class="cov0" title="0">managerIcon := map[string]string{
                "apt":     "📦",
                "flatpak": "📱", 
                "snap":    "🫰",
        }

        fmt.Printf("%s Package Information (%s):\n", managerIcon[foundManager], strings.ToUpper(foundManager))
        fmt.Println(strings.Repeat("=", 50))
        fmt.Println(info)

        return nil</span>
}

func runPackageList(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        logger := log.NewWithOptions(os.Stderr, log.Options{
                ReportCaller:    false,
                ReportTimestamp: false,
        })

        // Set up dry run mode
        dryRun := viper.GetBool("dry_run")

        if showUpgradable </span><span class="cov0" title="0">{
                fmt.Print("🔄 Listing upgradable packages...\n\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print("📋 Listing installed packages...\n\n")
        }</span>

        // List APT packages
        <span class="cov0" title="0">if packageType == "" || packageType == "apt" </span><span class="cov0" title="0">{
                aptManager := pkg.NewAptManager(logger, dryRun)
                
                if showUpgradable </span><span class="cov0" title="0">{
                        packages, err := aptManager.ListUpgradablePackages()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warn("Failed to list upgradable APT packages", "error", err)
                        }</span> else<span class="cov0" title="0"> if len(packages) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("📦 APT Packages (Upgradable: %d):\n", len(packages))
                                for _, pkg := range packages </span><span class="cov0" title="0">{
                                        fmt.Printf("  ⬆ %s\n", pkg)
                                }</span>
                                <span class="cov0" title="0">fmt.Println()</span>
                        }
                } else<span class="cov0" title="0"> {
                        // For now, we don't have a general list method, so we'll note this
                        fmt.Printf("📦 APT Packages:\n")
                        fmt.Printf("  ℹ Use 'apt list --installed' to see all APT packages\n")
                        fmt.Println()
                }</span>
        }

        // List Flatpak packages
        <span class="cov0" title="0">if packageType == "" || packageType == "flatpak" </span><span class="cov0" title="0">{
                flatpakManager := pkg.NewFlatpakManager(logger, dryRun)
                packages, err := flatpakManager.ListInstalledPackages()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to list Flatpak packages", "error", err)
                }</span> else<span class="cov0" title="0"> if len(packages) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("📱 Flatpak Applications (%d):\n", len(packages))
                        for _, pkg := range packages </span><span class="cov0" title="0">{
                                fmt.Printf("  • %s\n", pkg)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }

        // List Snap packages
        <span class="cov0" title="0">if packageType == "" || packageType == "snap" </span><span class="cov0" title="0">{
                snapManager := pkg.NewSnapManager(logger, dryRun)
                packages, err := snapManager.ListInstalledPackages()
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to list Snap packages", "error", err)
                }</span> else<span class="cov0" title="0"> if len(packages) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("🫰 Snap Packages (%d):\n", len(packages))
                        for _, pkg := range packages </span><span class="cov0" title="0">{
                                fmt.Printf("  • %s\n", pkg)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func runPackageUpgrade(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        logger := log.NewWithOptions(os.Stderr, log.Options{
                ReportCaller:    false,
                ReportTimestamp: false,
        })

        // Set up dry run mode
        dryRun := viper.GetBool("dry_run")

        if len(args) == 0 </span><span class="cov0" title="0">{
                fmt.Print("🔄 Upgrading all packages...\n\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("🔄 Upgrading packages: %s...\n\n", strings.Join(args, ", "))
        }</span>

        // Default flags from config
        <span class="cov0" title="0">packageDefaults := map[string][]string{
                "apt":     config.GetDefaultFlags("apt"),
                "flatpak": config.GetDefaultFlags("flatpak"), 
                "snap":    config.GetDefaultFlags("snap"),
        }

        // Upgrade APT packages
        if packageType == "" || packageType == "apt" </span><span class="cov0" title="0">{
                aptManager := pkg.NewAptManager(logger, dryRun)
                fmt.Println("📦 Upgrading APT packages...")
                err := aptManager.UpgradePackages(args, packageDefaults["apt"])
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to upgrade APT packages", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        config.Success("APT packages upgraded successfully")
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Upgrade Flatpak packages
        <span class="cov0" title="0">if packageType == "" || packageType == "flatpak" </span><span class="cov0" title="0">{
                flatpakManager := pkg.NewFlatpakManager(logger, dryRun)
                fmt.Println("📱 Upgrading Flatpak applications...")
                err := flatpakManager.UpdatePackages(packageDefaults["flatpak"])
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to upgrade Flatpak packages", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        config.Success("Flatpak packages upgraded successfully")
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Upgrade Snap packages
        <span class="cov0" title="0">if packageType == "" || packageType == "snap" </span><span class="cov0" title="0">{
                snapManager := pkg.NewSnapManager(logger, dryRun)
                fmt.Println("🫰 Upgrading Snap packages...")
                err := snapManager.UpgradePackages(args, packageDefaults["snap"])
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to upgrade Snap packages", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        config.Success("Snap packages upgraded successfully")
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func runPackageDeps(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        packageName := args[0]
        
        logger := log.NewWithOptions(os.Stderr, log.Options{
                ReportCaller:    false,
                ReportTimestamp: false,
        })

        // Set up dry run mode
        dryRun := viper.GetBool("dry_run")

        fmt.Printf("🔍 Analyzing dependencies for package '%s'...\n\n", packageName)

        // Currently only support APT for dependency analysis
        aptManager := pkg.NewAptManager(logger, dryRun)

        if simulate </span><span class="cov0" title="0">{
                // Show what would be installed
                fmt.Println("📦 Simulating installation...")
                flags := config.GetDefaultFlags("apt")
                willInstall, err := aptManager.SimulateInstall([]string{packageName}, flags)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to simulate installation: %w", err)
                }</span>

                <span class="cov0" title="0">if len(willInstall) == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("❌ No packages would be installed for '%s'\n", packageName)
                        return nil
                }</span>

                <span class="cov0" title="0">fmt.Printf("✅ Would install %d packages:\n\n", len(willInstall))
                for _, pkg := range willInstall </span><span class="cov0" title="0">{
                        if pkg == packageName </span><span class="cov0" title="0">{
                                fmt.Printf("  📦 %s (main package)\n", pkg)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("  📦 %s (dependency)\n", pkg)
                        }</span>
                }
                <span class="cov0" title="0">fmt.Println()
                
                return nil</span>
        }

        // Show dependencies
        <span class="cov0" title="0">fmt.Println("📦 Getting package dependencies...")
        dependencies, err := aptManager.GetPackageDependencies(packageName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get dependencies: %w", err)
        }</span>

        <span class="cov0" title="0">if len(dependencies) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("✅ Package '%s' has no explicit dependencies\n", packageName)
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("✅ Found %d dependencies:\n\n", len(dependencies))
        
        if showTree </span><span class="cov0" title="0">{
                fmt.Printf("📦 %s\n", packageName)
                for i, dep := range dependencies </span><span class="cov0" title="0">{
                        if i == len(dependencies)-1 </span><span class="cov0" title="0">{
                                fmt.Printf("└── %s\n", dep)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("├── %s\n", dep)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                for _, dep := range dependencies </span><span class="cov0" title="0">{
                        fmt.Printf("  • %s\n", dep)
                }</span>
        }
        
        <span class="cov0" title="0">fmt.Printf("\n💡 Use --simulate to see what would actually be installed\n")
        fmt.Printf("💡 Use --tree to display dependencies in tree format\n")

        return nil</span>
}

// PackageResult represents a search result with its package manager
type PackageResult struct {
        Name    string
        Manager string
}</pre>
		
		<pre class="file" id="file7" style="display: none">package configr

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/bashfulrobot/configr/internal/pkg"
        "github.com/charmbracelet/log"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        restoreAll          bool
        restoreFile         string
        listBackups         bool
        cleanupBackups      bool
        cleanupOrphaned     bool
        showStats           bool
        backupMaxAge        string
        restoreDryRun       bool
        restoreVerbose      bool
)

var restoreCmd = &amp;cobra.Command{
        Use:   "restore",
        Short: "Restore files from backups created by configr",
        Long: `Restore manages backup files created by configr during file deployment.

This command can:
- List all available backups with their details
- Restore specific files from backup
- Restore all available backups
- Clean up expired backups based on age
- Clean up orphaned backups no longer tracked
- Show comprehensive backup statistics
- Show backup information and status

Backups are automatically created when configr deploys files with the 'backup: true' option.
Each backup is timestamped and stored alongside the original file location.`,
        Example: `  configr restore --list                    # List all available backups
  configr restore --all                     # Restore all available backups  
  configr restore --file myfile             # Restore specific file from backup
  configr restore --cleanup --max-age 30d   # Remove backups older than 30 days
  configr restore --cleanup-orphaned        # Remove backups no longer tracked
  configr restore --stats                   # Show comprehensive backup statistics
  configr restore --dry-run --all           # Preview what would be restored`,
        RunE: runRestore,
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(restoreCmd)
        
        // Command-specific flags
        restoreCmd.Flags().BoolVar(&amp;restoreAll, "all", false, "restore all available backups")
        restoreCmd.Flags().StringVar(&amp;restoreFile, "file", "", "restore backup for specific file by name")
        restoreCmd.Flags().BoolVar(&amp;listBackups, "list", false, "list all available backups")
        restoreCmd.Flags().BoolVar(&amp;cleanupBackups, "cleanup", false, "clean up expired backups")
        restoreCmd.Flags().BoolVar(&amp;cleanupOrphaned, "cleanup-orphaned", false, "clean up orphaned backups no longer tracked")
        restoreCmd.Flags().BoolVar(&amp;showStats, "stats", false, "show comprehensive backup statistics")
        restoreCmd.Flags().StringVar(&amp;backupMaxAge, "max-age", "30d", "maximum age for backups during cleanup (e.g. 7d, 24h, 30d)")
        restoreCmd.Flags().BoolVar(&amp;restoreDryRun, "dry-run", false, "preview restore operations without executing them")
        restoreCmd.Flags().BoolVar(&amp;restoreVerbose, "verbose", false, "show detailed backup information")
}</span>

func runRestore(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // Initialize logger
        logger := log.NewWithOptions(os.Stderr, log.Options{
                ReportCaller:    false,
                ReportTimestamp: false,
                Prefix:          "configr",
        })

        // Set log level based on verbose flag
        if viper.GetBool("verbose") || restoreVerbose </span><span class="cov0" title="0">{
                logger.SetLevel(log.DebugLevel)
        }</span>

        // Parse max age for cleanup
        <span class="cov0" title="0">var maxAge time.Duration
        if cleanupBackups </span><span class="cov0" title="0">{
                var err error
                maxAge, err = parseMaxAge(backupMaxAge)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid max-age format: %w", err)
                }</span>
        }

        // Initialize state manager to get managed files
        <span class="cov0" title="0">stateManager := pkg.NewStateManager(logger)
        
        // Load current state to get backup information
        state, err := stateManager.LoadState()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Could not load state file", "error", err)
                // Continue but with empty state
                state = &amp;pkg.PackageState{
                        Files: []pkg.ManagedFile{},
                }
        }</span>

        // Initialize file manager for backup operations
        <span class="cov0" title="0">var configDir string
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                configDir = filepath.Dir(args[0])
        }</span> else<span class="cov0" title="0"> {
                // Use current directory as fallback
                configDir = "."
        }</span>
        
        <span class="cov0" title="0">fileManager := pkg.NewFileManager(logger, restoreDryRun, configDir)

        // Validate flags - only one operation at a time
        operationCount := 0
        if listBackups </span><span class="cov0" title="0">{
                operationCount++
        }</span>
        <span class="cov0" title="0">if restoreAll </span><span class="cov0" title="0">{
                operationCount++
        }</span>
        <span class="cov0" title="0">if restoreFile != "" </span><span class="cov0" title="0">{
                operationCount++
        }</span>
        <span class="cov0" title="0">if cleanupBackups </span><span class="cov0" title="0">{
                operationCount++
        }</span>
        <span class="cov0" title="0">if cleanupOrphaned </span><span class="cov0" title="0">{
                operationCount++
        }</span>
        <span class="cov0" title="0">if showStats </span><span class="cov0" title="0">{
                operationCount++
        }</span>

        <span class="cov0" title="0">if operationCount == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("must specify one operation: --list, --all, --file, --cleanup, --cleanup-orphaned, or --stats")
        }</span>
        <span class="cov0" title="0">if operationCount &gt; 1 </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot specify multiple operations at once")
        }</span>

        // Execute the requested operation
        <span class="cov0" title="0">switch </span>{
        case listBackups:<span class="cov0" title="0">
                return listAvailableBackups(fileManager, state.Files, logger)</span>
        case restoreAll:<span class="cov0" title="0">
                return restoreAllBackups(fileManager, state.Files, logger)</span>
        case restoreFile != "":<span class="cov0" title="0">
                return restoreSpecificFile(fileManager, state.Files, restoreFile, logger)</span>
        case cleanupBackups:<span class="cov0" title="0">
                return cleanupExpiredBackups(fileManager, state.Files, maxAge, logger)</span>
        case cleanupOrphaned:<span class="cov0" title="0">
                return cleanupOrphanedBackups(fileManager, state.Files, logger)</span>
        case showStats:<span class="cov0" title="0">
                return showBackupStatistics(fileManager, state.Files, logger)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// listAvailableBackups displays all available backups
func listAvailableBackups(fileManager *pkg.FileManager, managedFiles []pkg.ManagedFile, logger *log.Logger) error <span class="cov0" title="0">{
        backups := fileManager.ListBackups(managedFiles)
        
        if len(backups) == 0 </span><span class="cov0" title="0">{
                logger.Info("No backups found")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("Available backups (%d):\n\n", len(backups))
        
        for _, backup := range backups </span><span class="cov0" title="0">{
                fmt.Printf("📁 %s\n", backup.FileName)
                fmt.Printf("   Backup:   %s\n", backup.BackupPath)
                fmt.Printf("   Original: %s\n", backup.OriginalPath)
                fmt.Printf("   Created:  %s\n", backup.BackupTime.Format("2006-01-02 15:04:05"))
                fmt.Printf("   Size:     %d bytes\n", backup.BackupSize)
                
                if backup.OriginalExists </span><span class="cov0" title="0">{
                        fmt.Printf("   Status:   Original file exists\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("   Status:   🔄 Ready for restore\n")
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// restoreAllBackups restores all available backups
func restoreAllBackups(fileManager *pkg.FileManager, managedFiles []pkg.ManagedFile, logger *log.Logger) error <span class="cov0" title="0">{
        backups := fileManager.ListBackups(managedFiles)
        
        if len(backups) == 0 </span><span class="cov0" title="0">{
                logger.Info("No backups available for restoration")
                return nil
        }</span>

        <span class="cov0" title="0">restorable := 0
        for _, backup := range backups </span><span class="cov0" title="0">{
                if !backup.OriginalExists </span><span class="cov0" title="0">{
                        restorable++
                }</span>
        }

        <span class="cov0" title="0">if restorable == 0 </span><span class="cov0" title="0">{
                logger.Info("No backups need restoration (all original files exist)")
                return nil
        }</span>

        <span class="cov0" title="0">logger.Info("Restoring all available backups", "total", len(backups), "restorable", restorable)
        
        return fileManager.RestoreAllBackups(managedFiles)</span>
}

// restoreSpecificFile restores a backup for a specific file
func restoreSpecificFile(fileManager *pkg.FileManager, managedFiles []pkg.ManagedFile, fileName string, logger *log.Logger) error <span class="cov0" title="0">{
        // Find the managed file by name
        var targetFile *pkg.ManagedFile
        for _, file := range managedFiles </span><span class="cov0" title="0">{
                if file.Name == fileName </span><span class="cov0" title="0">{
                        targetFile = &amp;file
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetFile == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("file '%s' not found in managed files", fileName)
        }</span>

        <span class="cov0" title="0">if targetFile.BackupPath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("no backup available for file '%s'", fileName)
        }</span>

        // Check if backup exists
        <span class="cov0" title="0">if _, err := os.Stat(targetFile.BackupPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("backup file does not exist: %s", targetFile.BackupPath)
        }</span>

        <span class="cov0" title="0">logger.Info("Restoring specific file from backup", "file", fileName, "backup", targetFile.BackupPath)
        
        return fileManager.RestoreFromBackup(targetFile.BackupPath, targetFile.Destination)</span>
}

// cleanupExpiredBackups removes old backup files
func cleanupExpiredBackups(fileManager *pkg.FileManager, managedFiles []pkg.ManagedFile, maxAge time.Duration, logger *log.Logger) error <span class="cov0" title="0">{
        return fileManager.CleanupExpiredBackups(managedFiles, maxAge)
}</span>

// cleanupOrphanedBackups removes backup files that are no longer tracked
func cleanupOrphanedBackups(fileManager *pkg.FileManager, managedFiles []pkg.ManagedFile, logger *log.Logger) error <span class="cov0" title="0">{
        return fileManager.CleanupOrphanedBackups(managedFiles)
}</span>

// showBackupStatistics displays comprehensive backup statistics
func showBackupStatistics(fileManager *pkg.FileManager, managedFiles []pkg.ManagedFile, logger *log.Logger) error <span class="cov0" title="0">{
        stats, err := fileManager.GetBackupStatistics(managedFiles)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get backup statistics: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Backup Statistics:\n\n")
        fmt.Printf("📊 Total backups:     %d\n", stats.TotalBackups)
        fmt.Printf("💾 Total size:        %s\n", formatFileSize(stats.TotalSize))
        fmt.Printf("🔄 Restorable:        %d\n", stats.RestorableCount)
        
        if stats.TotalBackups &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("📅 Oldest backup:     %s\n", stats.OldestBackup.Format("2006-01-02 15:04:05"))
                fmt.Printf("📅 Newest backup:     %s\n", stats.NewestBackup.Format("2006-01-02 15:04:05"))
                
                fmt.Printf("\nAge distribution:\n")
                for ageRange, count := range stats.BackupsByAge </span><span class="cov0" title="0">{
                        if count &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("  %s: %d\n", ageRange, count)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                fmt.Printf("No backups found.\n")
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// formatFileSize formats a file size in bytes to human-readable format
func formatFileSize(bytes int64) string <span class="cov0" title="0">{
        const unit = 1024
        if bytes &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d bytes", bytes)
        }</span>
        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := bytes / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f %cB",
                float64(bytes)/float64(div), "KMGTPE"[exp])</span>
}

// parseMaxAge parses duration strings like "7d", "24h", "30d"
func parseMaxAge(maxAgeStr string) (time.Duration, error) <span class="cov0" title="0">{
        // Handle common suffixes
        switch </span>{
        case len(maxAgeStr) == 0:<span class="cov0" title="0">
                return 0, fmt.Errorf("empty duration")</span>
        case maxAgeStr[len(maxAgeStr)-1] == 'd':<span class="cov0" title="0">
                // Days - convert to hours
                daysStr := maxAgeStr[:len(maxAgeStr)-1]
                days, err := time.ParseDuration(daysStr + "h")
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">return days * 24, nil</span>
        default:<span class="cov0" title="0">
                // Standard Go duration parsing
                return time.ParseDuration(maxAgeStr)</span>
        }
}</pre>
		
		<pre class="file" id="file8" style="display: none">package configr

import (
        "os"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

// Version is set at build time via -ldflags
var Version = "dev"

var rootCmd = &amp;cobra.Command{
        Use:   "configr",
        Short: "Desktop Linux configuration management",
        Long: `Configr is a single binary configuration management tool for Ubuntu desktop systems.

It provides package management, configuration management, and dotfile management
capabilities similar to Ansible but contained in a single binary.

Use 'configr validate' to check your configuration or 'configr --help' for more commands.`,
        Example: `  configr validate                    # Validate default config
  configr validate my-config.yaml     # Validate specific file  
  configr --config custom.yaml validate # Use custom config file`,
        Version: Version,
}

// Execute is kept for backward compatibility but deprecated
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

// NewRootCmd returns the root command for use with fang
func NewRootCmd() *cobra.Command <span class="cov8" title="1">{
        return rootCmd
}</span>

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)
        
        // Global flags
        rootCmd.PersistentFlags().StringP("config", "c", "", "config file path")
        rootCmd.PersistentFlags().BoolP("verbose", "v", false, "verbose output")
        rootCmd.PersistentFlags().Bool("no-color", false, "disable colored output")
        
        // Bind flags to viper
        viper.BindPFlag("config", rootCmd.PersistentFlags().Lookup("config"))
        viper.BindPFlag("verbose", rootCmd.PersistentFlags().Lookup("verbose"))
        viper.BindPFlag("no-color", rootCmd.PersistentFlags().Lookup("no-color"))
}</span>

func initConfig() <span class="cov8" title="1">{
        // Use explicit config file if provided
        if configFile := viper.GetString("config"); configFile != "" </span><span class="cov0" title="0">{
                viper.SetConfigFile(configFile)
        }</span> else<span class="cov8" title="1"> if configEnv := os.Getenv("CONFIGR_CONFIG"); configEnv != "" </span><span class="cov0" title="0">{
                // Use CONFIGR_CONFIG environment variable
                viper.SetConfigFile(configEnv)
        }</span> else<span class="cov8" title="1"> {
                // Search for config file in standard locations
                viper.SetConfigName("configr")
                viper.SetConfigType("yaml")
                
                // Add search paths in order of preference
                viper.AddConfigPath(".")                    // Current directory
                viper.AddConfigPath("$HOME/.config/configr") // XDG config dir
                viper.AddConfigPath("$HOME")                // Home directory  
                viper.AddConfigPath("/etc/configr")         // System config
                viper.AddConfigPath("/usr/local/etc/configr") // Local system config
        }</span>

        // Environment variable support
        <span class="cov8" title="1">viper.SetEnvPrefix("CONFIGR")
        viper.AutomaticEnv()
        
        // Bind additional environment variables
        viper.BindEnv("verbose", "CONFIGR_VERBOSE")
        viper.BindEnv("no_color", "CONFIGR_NO_COLOR")
        viper.BindEnv("dry_run", "CONFIGR_DRY_RUN")
        viper.BindEnv("interactive", "CONFIGR_INTERACTIVE")
        viper.BindEnv("remove_packages", "CONFIGR_REMOVE_PACKAGES")
        viper.BindEnv("optimize", "CONFIGR_OPTIMIZE")</span>

        // Don't error here - let individual commands handle config loading
}</pre>
		
		<pre class="file" id="file9" style="display: none">package configr

import (
        "fmt"
        "os"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var validateCmd = &amp;cobra.Command{
        Use:   "validate [config-file]",
        Short: "Validate configuration file",
        Long: `Validate the configuration file for syntax errors, missing files, 
and other issues without making any changes to the system.`,
        Example: `  configr validate                    # Validate default config
  configr validate my-config.yaml     # Validate specific file
  configr validate --verbose          # Show detailed validation info`,
        Args: cobra.MaximumNArgs(1),
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Set verbose mode if requested
                verbose, _ := cmd.Flags().GetBool("verbose")
                config.SetVerbose(verbose)

                // Use provided config file or search for default
                if len(args) &gt; 0 </span><span class="cov0" title="0">{
                        viper.SetConfigFile(args[0])
                }</span>

                // Try to read config
                <span class="cov0" title="0">if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                        config.Error("Failed to read config file: %v", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">config.Info("Validating configuration: %s", viper.ConfigFileUsed())

                // Load and validate config
                cfg, err := config.LoadWithIncludes()
                if err != nil </span><span class="cov0" title="0">{
                        config.Error("Failed to load config: %v", err)
                        os.Exit(1)
                }</span>

                // Validate configuration
                <span class="cov0" title="0">result := config.Validate(cfg, viper.ConfigFileUsed())

                // Show results
                if result.HasErrors() </span><span class="cov0" title="0">{
                        fmt.Print(config.FormatValidationResultSimple(result))
                        fmt.Print(config.FormatQuickFixSimple(result))
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Print(config.FormatValidationResultSimple(result))
                }</span>

                <span class="cov0" title="0">config.Success("Configuration is valid")
                
                if verbose </span><span class="cov0" title="0">{
                        config.Debug("Found %d package definitions", 
                                len(cfg.Packages.Apt)+len(cfg.Packages.Flatpak)+len(cfg.Packages.Snap))
                        config.Debug("Found %d file definitions", len(cfg.Files))
                        config.Debug("Found %d dconf settings", len(cfg.DConf.Settings))
                }</span>
        },
}

func init() <span class="cov8" title="1">{
        rootCmd.AddCommand(validateCmd)
        validateCmd.Flags().BoolP("verbose", "v", false, "Show detailed validation information")
}</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "runtime"
        "strings"

        "gopkg.in/yaml.v3"
)

// AdvancedLoader handles loading configurations with advanced include features
type AdvancedLoader struct {
        visited   map[string]bool
        hostname  string
        osName    string
}

// NewAdvancedLoader creates a new advanced configuration loader
func NewAdvancedLoader() *AdvancedLoader <span class="cov8" title="1">{
        hostname, _ := os.Hostname()
        return &amp;AdvancedLoader{
                visited:  make(map[string]bool),
                hostname: hostname,
                osName:   runtime.GOOS,
        }
}</span>

// LoadConfigurationAdvanced loads configuration with advanced include support
func (al *AdvancedLoader) LoadConfigurationAdvanced(configPath string) (*Config, []string, error) <span class="cov8" title="1">{
        al.visited = make(map[string]bool) // Reset visited map
        config, paths, err := al.loadConfigRecursiveAdvanced(configPath, []string{})
        return config, paths, err
}</span>

// loadConfigRecursiveAdvanced loads a config file and processes both simple and advanced includes
func (al *AdvancedLoader) loadConfigRecursiveAdvanced(configPath string, loadedPaths []string) (*Config, []string, error) <span class="cov8" title="1">{
        // Prevent circular includes
        absPath, err := filepath.Abs(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to get absolute path for %s: %w", configPath, err)
        }</span>

        <span class="cov8" title="1">if al.visited[absPath] </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("circular include detected: %s", absPath)
        }</span>
        <span class="cov8" title="1">al.visited[absPath] = true
        defer func() </span><span class="cov8" title="1">{ delete(al.visited, absPath) }</span>()

        // Load the config file
        <span class="cov8" title="1">data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to read config file %s: %w", configPath, err)
        }</span>

        <span class="cov8" title="1">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("failed to unmarshal config file %s: %w", configPath, err)
        }</span>

        <span class="cov8" title="1">loadedPaths = append(loadedPaths, absPath)
        baseDir := filepath.Dir(configPath)

        // Process includes with advanced features
        if len(config.Includes) &gt; 0 </span><span class="cov8" title="1">{
                for _, includeSpec := range config.Includes </span><span class="cov8" title="1">{
                        // Check conditions first
                        if !al.evaluateConditions(includeSpec.Conditions) </span><span class="cov0" title="0">{
                                continue</span> // Skip this include
                        }

                        // Resolve include path (supports glob patterns)
                        <span class="cov8" title="1">includePaths, err := al.resolveIncludePathAdvanced(baseDir, includeSpec.Path, includeSpec.Optional)

                        if err != nil </span><span class="cov0" title="0">{
                                if includeSpec.Optional </span><span class="cov0" title="0">{
                                        continue</span> // Skip optional includes that fail
                                }
                                <span class="cov0" title="0">return nil, nil, fmt.Errorf("failed to resolve include %s: %w", includeSpec.Path, err)</span>
                        }

                        <span class="cov8" title="1">for _, resolvedPath := range includePaths </span><span class="cov8" title="1">{
                                includedConfig, paths, err := al.loadConfigRecursiveAdvanced(resolvedPath, loadedPaths)
                                if err != nil </span><span class="cov0" title="0">{
                                        if includeSpec.Optional </span><span class="cov0" title="0">{
                                                continue</span> // Skip optional includes that fail to load
                                        }
                                        <span class="cov0" title="0">return nil, nil, fmt.Errorf("failed to load included config %s: %w", resolvedPath, err)</span>
                                }

                                <span class="cov8" title="1">loadedPaths = paths
                                if err := mergeConfigs(&amp;config, includedConfig); err != nil </span><span class="cov0" title="0">{
                                        return nil, nil, fmt.Errorf("failed to merge config %s: %w", resolvedPath, err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return &amp;config, loadedPaths, nil</span>
}

// resolveIncludePathAdvanced resolves include paths with enhanced features
func (al *AdvancedLoader) resolveIncludePathAdvanced(baseDir, includePath string, optional bool) ([]string, error) <span class="cov8" title="1">{
        // Check for glob patterns
        if strings.Contains(includePath, "*") || strings.Contains(includePath, "?") || strings.Contains(includePath, "[") </span><span class="cov0" title="0">{
                return al.resolveGlobPattern(baseDir, includePath, optional)
        }</span>

        // Use existing resolveIncludePath for non-glob patterns
        <span class="cov8" title="1">resolvedPath, err := resolveIncludePath(baseDir, includePath)
        if err != nil </span><span class="cov0" title="0">{
                if optional </span><span class="cov0" title="0">{
                        return []string{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">return []string{resolvedPath}, nil</span>
}

// resolveGlobPattern resolves glob patterns for include files
func (al *AdvancedLoader) resolveGlobPattern(baseDir, pattern string, optional bool) ([]string, error) <span class="cov8" title="1">{
        fullPattern := filepath.Join(baseDir, pattern)
        
        matches, err := filepath.Glob(fullPattern)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid glob pattern %s: %w", pattern, err)
        }</span>

        <span class="cov8" title="1">if len(matches) == 0 </span><span class="cov8" title="1">{
                if optional </span><span class="cov8" title="1">{
                        return []string{}, nil
                }</span>
                <span class="cov8" title="1">return nil, fmt.Errorf("no files match glob pattern: %s", pattern)</span>
        }

        // Filter out directories unless they contain default.yaml
        <span class="cov8" title="1">var validPaths []string
        for _, match := range matches </span><span class="cov8" title="1">{
                info, err := os.Stat(match)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if info.IsDir() </span><span class="cov0" title="0">{
                        // Check for default.yaml in directory
                        defaultPath := filepath.Join(match, "default.yaml")
                        if _, err := os.Stat(defaultPath); err == nil </span><span class="cov0" title="0">{
                                validPaths = append(validPaths, defaultPath)
                        }</span>
                } else<span class="cov8" title="1"> if strings.HasSuffix(strings.ToLower(match), ".yaml") || strings.HasSuffix(strings.ToLower(match), ".yml") </span><span class="cov8" title="1">{
                        validPaths = append(validPaths, match)
                }</span>
        }

        <span class="cov8" title="1">if len(validPaths) == 0 &amp;&amp; !optional </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no valid YAML files found for pattern: %s", pattern)
        }</span>

        <span class="cov8" title="1">return validPaths, nil</span>
}

// evaluateConditions evaluates all conditions and returns true if all pass
func (al *AdvancedLoader) evaluateConditions(conditions []IncludeCondition) bool <span class="cov8" title="1">{
        if len(conditions) == 0 </span><span class="cov8" title="1">{
                return true // No conditions means always include
        }</span>

        <span class="cov0" title="0">for _, condition := range conditions </span><span class="cov0" title="0">{
                if !al.evaluateCondition(condition) </span><span class="cov0" title="0">{
                        return false // All conditions must pass
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// evaluateCondition evaluates a single condition
func (al *AdvancedLoader) evaluateCondition(condition IncludeCondition) bool <span class="cov8" title="1">{
        operator := condition.Operator
        if operator == "" </span><span class="cov8" title="1">{
                operator = "equals" // Default operator
        }</span>

        <span class="cov8" title="1">var actualValue string

        switch condition.Type </span>{
        case "os":<span class="cov8" title="1">
                actualValue = al.osName</span>
        case "hostname":<span class="cov8" title="1">
                actualValue = al.hostname</span>
        case "env":<span class="cov8" title="1">
                // For env conditions, the Value should be "VAR_NAME=expected_value"
                if strings.Contains(condition.Value, "=") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(condition.Value, "=", 2)
                        varName := parts[0]
                        expectedValue := parts[1]
                        actualValue = os.Getenv(varName)
                        return al.compareValues(actualValue, expectedValue, operator)
                }</span>
                // If no =, treat as checking if env var exists
                <span class="cov8" title="1">varName := condition.Value
                _, exists := os.LookupEnv(varName)
                return exists</span>
        case "file_exists":<span class="cov8" title="1">
                // Check if file exists
                _, err := os.Stat(condition.Value)
                return err == nil</span>
        case "dir_exists":<span class="cov0" title="0">
                // Check if directory exists
                info, err := os.Stat(condition.Value)
                return err == nil &amp;&amp; info.IsDir()</span>
        default:<span class="cov0" title="0">
                return false</span> // Unknown condition type
        }

        <span class="cov8" title="1">return al.compareValues(actualValue, condition.Value, operator)</span>
}

// compareValues compares actual and expected values using the specified operator
func (al *AdvancedLoader) compareValues(actual, expected, operator string) bool <span class="cov8" title="1">{
        switch operator </span>{
        case "equals":<span class="cov8" title="1">
                return actual == expected</span>
        case "contains":<span class="cov8" title="1">
                return strings.Contains(actual, expected)</span>
        case "matches":<span class="cov8" title="1">
                matched, err := regexp.MatchString(expected, actual)
                return err == nil &amp;&amp; matched</span>
        case "not_equals":<span class="cov8" title="1">
                return actual != expected</span>
        case "not_contains":<span class="cov8" title="1">
                return !strings.Contains(actual, expected)</span>
        default:<span class="cov8" title="1">
                return actual == expected</span> // Default to equals
        }
}

// ValidateIncludeSpec validates an include specification
func (al *AdvancedLoader) ValidateIncludeSpec(spec IncludeSpec) error <span class="cov8" title="1">{
        // Path must be specified
        if spec.Path == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("include spec must have 'path' specified")
        }</span>

        // Validate conditions
        <span class="cov8" title="1">for i, condition := range spec.Conditions </span><span class="cov8" title="1">{
                if err := al.validateCondition(condition); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid condition %d: %w", i, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validateCondition validates a single condition
func (al *AdvancedLoader) validateCondition(condition IncludeCondition) error <span class="cov8" title="1">{
        if condition.Type == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("condition type is required")
        }</span>

        <span class="cov8" title="1">validTypes := []string{"os", "hostname", "env", "file_exists", "dir_exists"}
        typeValid := false
        for _, validType := range validTypes </span><span class="cov8" title="1">{
                if condition.Type == validType </span><span class="cov8" title="1">{
                        typeValid = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !typeValid </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid condition type: %s (valid types: %s)", condition.Type, strings.Join(validTypes, ", "))
        }</span>

        <span class="cov8" title="1">if condition.Value == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("condition value is required")
        }</span>

        // Validate operators
        <span class="cov8" title="1">if condition.Operator != "" </span><span class="cov8" title="1">{
                validOperators := []string{"equals", "contains", "matches", "not_equals", "not_contains"}
                operatorValid := false
                for _, validOp := range validOperators </span><span class="cov8" title="1">{
                        if condition.Operator == validOp </span><span class="cov8" title="1">{
                                operatorValid = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !operatorValid </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid operator: %s (valid operators: %s)", condition.Operator, strings.Join(validOperators, ", "))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetSystemInfo returns information about the current system for debugging
func (al *AdvancedLoader) GetSystemInfo() map[string]string <span class="cov8" title="1">{
        info := make(map[string]string)
        info["os"] = al.osName
        info["hostname"] = al.hostname
        info["goos"] = runtime.GOOS
        info["goarch"] = runtime.GOARCH
        
        // Add some common environment variables
        commonVars := []string{"USER", "HOME", "PATH", "SHELL", "DESKTOP_SESSION"}
        for _, varName := range commonVars </span><span class="cov8" title="1">{
                if value := os.Getenv(varName); value != "" </span><span class="cov8" title="1">{
                        info["env_"+strings.ToLower(varName)] = value
                }</span>
        }

        <span class="cov8" title="1">return info</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package config

import (
        "fmt"

        "github.com/spf13/viper"
)

// Load reads and parses the configuration file using Viper with include support and validation
func Load() (*Config, error) <span class="cov8" title="1">{
        if err := viper.ReadInConfig(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Use the new include-aware loader
        <span class="cov0" title="0">config, err := LoadWithIncludes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate the configuration
        <span class="cov0" title="0">result := Validate(config, viper.ConfigFileUsed())
        if result.HasErrors() </span><span class="cov0" title="0">{
                return nil, &amp;ValidationFailedError{
                        Result: result,
                }
        }</span>

        // Show warnings if any (but don't fail)
        <span class="cov0" title="0">if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Print(FormatValidationResultSimple(&amp;ValidationResult{
                        Warnings: result.Warnings,
                        Valid:    true,
                }))
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// GetConfigFile returns the path of the config file being used
func GetConfigFile() string <span class="cov8" title="1">{
        return viper.ConfigFileUsed()
}</span>

// IsConfigFound returns true if a config file was found and loaded
func IsConfigFound() bool <span class="cov8" title="1">{
        return viper.ConfigFileUsed() != ""
}</pre>
		
		<pre class="file" id="file12" style="display: none">package config

// DefaultPackageFlags contains the built-in default flags for each package manager
// These are used when the user doesn't specify their own defaults
var DefaultPackageFlags = map[string][]string{
        // APT defaults: non-interactive and don't install recommended packages
        "apt": {"-y", "--no-install-recommends"},
        
        // Snap defaults: empty - snaps are interactive by design and most don't need special flags
        "snap": {},
        
        // Flatpak defaults: install system-wide and assume yes for prompts
        "flatpak": {"--system", "--assumeyes"},
}

// GetDefaultFlags returns the default flags for a package manager
func GetDefaultFlags(manager string) []string <span class="cov8" title="1">{
        if flags, exists := DefaultPackageFlags[manager]; exists </span><span class="cov8" title="1">{
                // Return a copy to avoid accidental modification
                result := make([]string, len(flags))
                copy(result, flags)
                return result
        }</span>
        <span class="cov8" title="1">return []string{}</span>
}

// HasDefaultFlags checks if a package manager has default flags defined
func HasDefaultFlags(manager string) bool <span class="cov8" title="1">{
        _, exists := DefaultPackageFlags[manager]
        return exists
}</span>

// GetSupportedPackageManagers returns all supported package managers
func GetSupportedPackageManagers() []string <span class="cov8" title="1">{
        managers := make([]string, 0, len(DefaultPackageFlags))
        for manager := range DefaultPackageFlags </span><span class="cov8" title="1">{
                managers = append(managers, manager)
        }</span>
        <span class="cov8" title="1">return managers</span>
}</pre>
		
		<pre class="file" id="file13" style="display: none">package config

import (
        "fmt"
        "os"
        "strconv"
        "strings"

        "github.com/charmbracelet/lipgloss"
)

// EnhancedFormatter provides Rust-style error formatting with colors and enhanced presentation
type EnhancedFormatter struct {
        // Color styles
        errorStyle     lipgloss.Style
        warningStyle   lipgloss.Style
        noteStyle      lipgloss.Style
        helpStyle      lipgloss.Style
        lineNumberStyle lipgloss.Style
        highlightStyle lipgloss.Style
        codeStyle      lipgloss.Style
        titleStyle     lipgloss.Style
}

// NewEnhancedFormatter creates a new enhanced formatter with color support
func NewEnhancedFormatter() *EnhancedFormatter <span class="cov0" title="0">{
        return &amp;EnhancedFormatter{
                errorStyle:      lipgloss.NewStyle().Foreground(lipgloss.Color("196")).Bold(true),
                warningStyle:    lipgloss.NewStyle().Foreground(lipgloss.Color("214")).Bold(true),
                noteStyle:       lipgloss.NewStyle().Foreground(lipgloss.Color("39")).Bold(true),
                helpStyle:       lipgloss.NewStyle().Foreground(lipgloss.Color("46")).Bold(true),
                lineNumberStyle: lipgloss.NewStyle().Foreground(lipgloss.Color("243")),
                highlightStyle:  lipgloss.NewStyle().Foreground(lipgloss.Color("196")).Underline(true),
                codeStyle:       lipgloss.NewStyle().Foreground(lipgloss.Color("250")).Background(lipgloss.Color("235")).Padding(0, 1),
                titleStyle:      lipgloss.NewStyle().Foreground(lipgloss.Color("255")).Bold(true),
        }
}</span>

// FormatValidationResultEnhanced provides enhanced Rust-style error formatting
func (ef *EnhancedFormatter) FormatValidationResultEnhanced(result *ValidationResult) string <span class="cov0" title="0">{
        if len(result.Errors) == 0 &amp;&amp; len(result.Warnings) == 0 </span><span class="cov0" title="0">{
                return ef.helpStyle.Render("✅ Configuration validation passed") + "\n"
        }</span>

        <span class="cov0" title="0">var output strings.Builder

        // Format errors with enhanced styling
        for i, err := range result.Errors </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        output.WriteString(ef.lineNumberStyle.Render("─────────────────────────────────────────────────────────") + "\n\n")
                }</span>
                <span class="cov0" title="0">output.WriteString(ef.formatErrorEnhanced(err))</span>
        }

        // Add separator between errors and warnings
        <span class="cov0" title="0">if len(result.Errors) &gt; 0 &amp;&amp; len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString(ef.lineNumberStyle.Render("─────────────────────────────────────────────────────────") + "\n\n")
        }</span>

        // Format warnings with enhanced styling
        <span class="cov0" title="0">for i, warning := range result.Warnings </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        output.WriteString(ef.lineNumberStyle.Render("─────────────────────────────────────────────────────────") + "\n\n")
                }</span>
                <span class="cov0" title="0">output.WriteString(ef.formatWarningEnhanced(warning))</span>
        }

        // Enhanced summary with better visual hierarchy
        <span class="cov0" title="0">if len(result.Errors) &gt; 0 || len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString(ef.lineNumberStyle.Render("═════════════════════════════════════════════════════════") + "\n")
                
                if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        summary := fmt.Sprintf("🚨 Validation failed: %d error(s) found", len(result.Errors))
                        if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                                summary += fmt.Sprintf(" (+ %d warning(s))", len(result.Warnings))
                        }</span>
                        <span class="cov0" title="0">output.WriteString(ef.errorStyle.Render(summary) + "\n")</span>
                } else<span class="cov0" title="0"> if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                        summary := fmt.Sprintf("⚠️  Validation completed with %d warning(s)", len(result.Warnings))
                        output.WriteString(ef.warningStyle.Render(summary) + "\n")
                }</span>
                
                <span class="cov0" title="0">output.WriteString(ef.lineNumberStyle.Render("═════════════════════════════════════════════════════════") + "\n")</span>
        }

        <span class="cov0" title="0">return output.String()</span>
}

func (ef *EnhancedFormatter) formatErrorEnhanced(err ValidationError) string <span class="cov0" title="0">{
        var output strings.Builder

        // Error header with enhanced styling and emoji
        output.WriteString(ef.errorStyle.Render("❌ error") + ": " + ef.titleStyle.Render(err.Title) + "\n")

        // Location with file context
        if err.File != "" &amp;&amp; err.Line &gt; 0 </span><span class="cov0" title="0">{
                location := fmt.Sprintf("%s:%d:%d", err.File, err.Line, err.Column)
                output.WriteString("  " + ef.noteStyle.Render("┌─&gt;") + " " + location + "\n")
                
                // Show actual file content if available
                if content := ef.getFileContext(err.File, err.Line, err.Column); content != "" </span><span class="cov0" title="0">{
                        output.WriteString(content)
                }</span>
        } else<span class="cov0" title="0"> if err.File != "" </span><span class="cov0" title="0">{
                output.WriteString("  " + ef.noteStyle.Render("┌─&gt;") + " " + err.File + "\n")
        }</span>

        // Field path and value with enhanced highlighting
        <span class="cov0" title="0">if err.Field != "" </span><span class="cov0" title="0">{
                output.WriteString("  │\n")
                if err.Value != "" </span><span class="cov0" title="0">{
                        // Highlight problematic value with better context
                        highlighted := ef.highlightStyle.Render(err.Value)
                        output.WriteString(fmt.Sprintf("  │ %s: %s\n", err.Field, highlighted))
                        
                        // Show underline highlighting
                        fieldLen := len(err.Field) + 2 // ": " length
                        valueStart := fieldLen
                        underline := strings.Repeat(" ", valueStart) + ef.highlightStyle.Render(strings.Repeat("^", len(err.Value)))
                        output.WriteString("  │ " + underline + " " + ef.errorStyle.Render(err.Message) + "\n")
                }</span> else<span class="cov0" title="0"> {
                        output.WriteString(fmt.Sprintf("  │ %s\n", err.Field))
                        if err.Message != "" </span><span class="cov0" title="0">{
                                output.WriteString("  │ " + strings.Repeat(" ", len(err.Field)) + " " + ef.errorStyle.Render("^-- " + err.Message) + "\n")
                        }</span>
                }
                <span class="cov0" title="0">output.WriteString("  │\n")</span>
        }

        // Help section with enhanced styling and icon
        <span class="cov0" title="0">if err.Help != "" </span><span class="cov0" title="0">{
                output.WriteString("  " + ef.helpStyle.Render("💡 help:") + " " + err.Help + "\n")
        }</span>

        // Note section with enhanced styling and icon
        <span class="cov0" title="0">if err.Note != "" </span><span class="cov0" title="0">{
                output.WriteString("  " + ef.noteStyle.Render("📝 note:") + " " + err.Note + "\n")
        }</span>

        // Suggestion section with enhanced code formatting
        <span class="cov0" title="0">if err.Suggestion != "" </span><span class="cov0" title="0">{
                output.WriteString("  " + ef.helpStyle.Render("🔧 suggestion:") + " ")
                if strings.Contains(err.Suggestion, ":") || strings.Contains(err.Suggestion, "{") </span><span class="cov0" title="0">{
                        // Format as code if it looks like YAML
                        output.WriteString("\n" + ef.formatCodeSuggestion(err.Suggestion))
                }</span> else<span class="cov0" title="0"> {
                        output.WriteString(err.Suggestion + "\n")
                }</span>
        }

        <span class="cov0" title="0">output.WriteString("\n") // Add spacing between errors

        return output.String()</span>
}

func (ef *EnhancedFormatter) formatWarningEnhanced(warning ValidationError) string <span class="cov0" title="0">{
        var output strings.Builder

        // Warning header with enhanced styling and emoji
        output.WriteString(ef.warningStyle.Render("⚠️  warning") + ": " + ef.titleStyle.Render(warning.Title) + "\n")

        // Location with enhanced styling
        if warning.File != "" &amp;&amp; warning.Line &gt; 0 </span><span class="cov0" title="0">{
                location := fmt.Sprintf("%s:%d:%d", warning.File, warning.Line, warning.Column)
                output.WriteString("  " + ef.noteStyle.Render("┌─&gt;") + " " + location + "\n")
                
                // Show actual file content if available
                if content := ef.getFileContext(warning.File, warning.Line, warning.Column); content != "" </span><span class="cov0" title="0">{
                        output.WriteString(content)
                }</span>
        } else<span class="cov0" title="0"> if warning.File != "" </span><span class="cov0" title="0">{
                output.WriteString("  " + ef.noteStyle.Render("┌─&gt;") + " " + warning.File + "\n")
        }</span>

        // Field and value with highlighting
        <span class="cov0" title="0">if warning.Field != "" </span><span class="cov0" title="0">{
                output.WriteString("  │\n")
                if warning.Value != "" </span><span class="cov0" title="0">{
                        highlighted := ef.warningStyle.Render(warning.Value)
                        output.WriteString(fmt.Sprintf("  │ %s: %s\n", warning.Field, highlighted))
                        
                        // Show underline for warnings too
                        fieldLen := len(warning.Field) + 2
                        underline := strings.Repeat(" ", fieldLen) + ef.warningStyle.Render(strings.Repeat("~", len(warning.Value)))
                        output.WriteString("  │ " + underline + " " + ef.warningStyle.Render(warning.Message) + "\n")
                }</span> else<span class="cov0" title="0"> {
                        output.WriteString(fmt.Sprintf("  │ %s\n", warning.Field))
                        if warning.Message != "" </span><span class="cov0" title="0">{
                                output.WriteString("  │ " + strings.Repeat(" ", len(warning.Field)) + " " + ef.warningStyle.Render("~-- " + warning.Message) + "\n")
                        }</span>
                }
                <span class="cov0" title="0">output.WriteString("  │\n")</span>
        }

        // Help section with enhanced styling and icon
        <span class="cov0" title="0">if warning.Help != "" </span><span class="cov0" title="0">{
                output.WriteString("  " + ef.helpStyle.Render("💡 help:") + " " + warning.Help + "\n")
        }</span>

        // Note section for warnings
        <span class="cov0" title="0">if warning.Note != "" </span><span class="cov0" title="0">{
                output.WriteString("  " + ef.noteStyle.Render("📝 note:") + " " + warning.Note + "\n")
        }</span>

        <span class="cov0" title="0">output.WriteString("\n") // Add spacing between warnings

        return output.String()</span>
}

// getFileContext reads and formats the relevant lines from the source file
func (ef *EnhancedFormatter) getFileContext(filename string, line, column int) string <span class="cov0" title="0">{
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">lines := strings.Split(string(content), "\n")
        if line &lt;= 0 || line &gt; len(lines) </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var output strings.Builder
        
        // Show context: 2 lines before, the error line, 2 lines after for better context
        startLine := max(1, line-2)
        endLine := min(len(lines), line+2)
        
        // Calculate line number width for alignment
        lineNumWidth := len(strconv.Itoa(endLine))
        
        for i := startLine; i &lt;= endLine; i++ </span><span class="cov0" title="0">{
                lineContent := ""
                if i &lt;= len(lines) </span><span class="cov0" title="0">{
                        lineContent = lines[i-1]
                }</span>
                
                <span class="cov0" title="0">lineNum := ef.lineNumberStyle.Render(fmt.Sprintf("%*d", lineNumWidth, i))
                
                if i == line </span><span class="cov0" title="0">{
                        // Highlight the error line with special styling
                        output.WriteString(fmt.Sprintf("   %s │ %s\n", 
                                ef.errorStyle.Render(fmt.Sprintf("%*d", lineNumWidth, i)), 
                                lineContent))
                        
                        // Add pointer to specific column if available
                        if column &gt; 0 &amp;&amp; column &lt;= len(lineContent) </span><span class="cov0" title="0">{
                                pointer := strings.Repeat(" ", column-1) + ef.highlightStyle.Render("^")
                                if column &gt; 1 </span><span class="cov0" title="0">{
                                        pointer = strings.Repeat(" ", column-1) + ef.highlightStyle.Render("^^^")
                                }</span>
                                <span class="cov0" title="0">output.WriteString(fmt.Sprintf("   %s │ %s\n", 
                                        strings.Repeat(" ", lineNumWidth), pointer))</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Context lines with subdued styling
                        output.WriteString(fmt.Sprintf("   %s │ %s\n", lineNum, 
                                ef.lineNumberStyle.Render(lineContent)))
                }</span>
        }
        
        <span class="cov0" title="0">return output.String()</span>
}

// formatCodeSuggestion formats YAML code suggestions with proper indentation
func (ef *EnhancedFormatter) formatCodeSuggestion(suggestion string) string <span class="cov0" title="0">{
        lines := strings.Split(suggestion, "\n")
        var formatted strings.Builder
        
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.TrimSpace(line) != "" </span><span class="cov0" title="0">{
                        formatted.WriteString("       " + ef.codeStyle.Render(line) + "\n")
                }</span>
        }
        
        <span class="cov0" title="0">return formatted.String()</span>
}

// FormatQuickFixEnhanced provides enhanced quick fix suggestions
func (ef *EnhancedFormatter) FormatQuickFixEnhanced(result *ValidationResult) string <span class="cov0" title="0">{
        if len(result.Errors) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">var output strings.Builder
        output.WriteString("\n" + ef.helpStyle.Render("🚀 Quick Fixes") + "\n")
        output.WriteString(ef.lineNumberStyle.Render("┌─ Try these solutions to resolve the errors:") + "\n")

        fixCount := 0
        for _, err := range result.Errors </span><span class="cov0" title="0">{
                if fixCount &gt;= 5 </span><span class="cov0" title="0">{ // Limit to first 5 quick fixes
                        remaining := len(result.Errors) - fixCount
                        output.WriteString(ef.lineNumberStyle.Render("├─ ") + 
                                ef.noteStyle.Render(fmt.Sprintf("... and %d more errors need attention", remaining)) + "\n")
                        break</span>
                }

                <span class="cov0" title="0">fix := ef.getQuickFixEnhanced(err)
                if fix != "" </span><span class="cov0" title="0">{
                        prefix := "├─"
                        if fixCount == len(result.Errors)-1 || fixCount == 4 </span><span class="cov0" title="0">{
                                prefix = "└─"
                        }</span>
                        <span class="cov0" title="0">output.WriteString(ef.lineNumberStyle.Render(prefix + " ") + fix + "\n")
                        fixCount++</span>
                }
        }

        <span class="cov0" title="0">if fixCount == 0 </span><span class="cov0" title="0">{
                output.WriteString(ef.lineNumberStyle.Render("└─ ") + 
                        ef.noteStyle.Render("Review the error details above for specific guidance") + "\n")
        }</span>

        <span class="cov0" title="0">return output.String()</span>
}

func (ef *EnhancedFormatter) getQuickFixEnhanced(err ValidationError) string <span class="cov0" title="0">{
        switch </span>{
        case strings.Contains(err.Title, "missing version"):<span class="cov0" title="0">
                return fmt.Sprintf("🔧 Add %s to the top of your config file", 
                        ef.codeStyle.Render(`version: "1.0"`))</span>
        case strings.Contains(err.Title, "source file not found"):<span class="cov0" title="0">
                return fmt.Sprintf("📁 Create missing file: %s", ef.codeStyle.Render(err.Value))</span>
        case strings.Contains(err.Title, "invalid file mode"):<span class="cov0" title="0">
                return fmt.Sprintf("🔐 Change mode to %s in %s", 
                        ef.codeStyle.Render(`"644"`), ef.codeStyle.Render(err.Field))</span>
        case strings.Contains(err.Title, "empty package name"):<span class="cov0" title="0">
                return "🗑️  Remove empty package entries from your lists"</span>
        case strings.Contains(err.Title, "invalid dconf path"):<span class="cov0" title="0">
                return fmt.Sprintf("🛤️  Add '/' prefix to dconf path: %s", 
                        ef.codeStyle.Render("/"+err.Value))</span>
        case strings.Contains(err.Title, "invalid package name"):<span class="cov0" title="0">
                if err.Suggestion != "" </span><span class="cov0" title="0">{
                        return fmt.Sprintf("📦 Fix package name format (suggested: %s)", 
                                ef.codeStyle.Render(err.Suggestion))
                }</span>
                <span class="cov0" title="0">return "📦 Fix package name format according to manager conventions"</span>
        case strings.Contains(err.Title, "missing repository"):<span class="cov0" title="0">
                return "📚 Add repository configuration before installing packages"</span>
        case strings.Contains(err.Title, "invalid PPA"):<span class="cov0" title="0">
                return fmt.Sprintf("🔗 Use correct PPA format: %s", 
                        ef.codeStyle.Render("user/repo"))</span>
        case strings.Contains(err.Title, "unsafe destination"):<span class="cov0" title="0">
                return "🛡️  Use absolute paths or home-relative paths (~/) for destinations"</span>
        case strings.Contains(err.Title, "conflicting flags"):<span class="cov0" title="0">
                return "⚡ Remove conflicting flags - choose one option per category"</span>
        case strings.Contains(err.Title, "dangerous flag"):<span class="cov0" title="0">
                return "⚠️  Consider removing dangerous flags or ensure you understand the security implications"</span>
        case strings.Contains(err.Title, "missing destination"):<span class="cov0" title="0">
                return fmt.Sprintf("🎯 Add destination path: %s", 
                        ef.codeStyle.Render(`destination: "/path/to/target"`))</span>
        case strings.Contains(err.Title, "missing source"):<span class="cov0" title="0">
                return fmt.Sprintf("📄 Add source path: %s", 
                        ef.codeStyle.Render(`source: "path/to/file"`))</span>
        case strings.Contains(err.Title, "include file not found"):<span class="cov0" title="0">
                return "📂 Create the missing include file or mark as optional with 'optional: true'"</span>
        case strings.Contains(err.Title, "invalid glob"):<span class="cov0" title="0">
                return "🔍 Check glob pattern syntax - use *, ?, and [] correctly"</span>
        case strings.Contains(err.Title, "circular"):<span class="cov0" title="0">
                return "🔄 Remove circular dependencies between include files"</span>
        case strings.Contains(err.Title, "malformed dconf"):<span class="cov0" title="0">
                return "⚙️  Fix dconf path format - use single slashes to separate segments"</span>
        default:<span class="cov0" title="0">
                if err.Help != "" </span><span class="cov0" title="0">{
                        return "💡 " + err.Help
                }</span>
                <span class="cov0" title="0">return "🔧 Check the configuration documentation for guidance"</span>
        }
}

// Helper functions
func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}</pre>
		
		<pre class="file" id="file14" style="display: none">package config

import (
        "fmt"
        "strings"
)

// FormatValidationResultSimple provides a simple formatter without complex styling
func FormatValidationResultSimple(result *ValidationResult) string <span class="cov8" title="1">{
        if len(result.Errors) == 0 &amp;&amp; len(result.Warnings) == 0 </span><span class="cov8" title="1">{
                return "✓ Configuration is valid\n"
        }</span>
        
        <span class="cov8" title="1">var output strings.Builder
        
        // Format errors
        for i, err := range result.Errors </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        output.WriteString("\n")
                }</span>
                <span class="cov8" title="1">output.WriteString(formatErrorSimple(err))</span>
        }
        
        // Format warnings  
        <span class="cov8" title="1">for i, warning := range result.Warnings </span><span class="cov8" title="1">{
                if len(result.Errors) &gt; 0 || i &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString("\n")
                }</span>
                <span class="cov8" title="1">output.WriteString(formatWarningSimple(warning))</span>
        }
        
        // Summary
        <span class="cov8" title="1">if len(result.Errors) &gt; 0 </span><span class="cov8" title="1">{
                output.WriteString(fmt.Sprintf("\nError: could not validate configuration due to %d errors\n", len(result.Errors)))
        }</span>
        
        <span class="cov8" title="1">return output.String()</span>
}

func formatErrorSimple(err ValidationError) string <span class="cov8" title="1">{
        var output strings.Builder
        
        // Error header
        output.WriteString(fmt.Sprintf("error: %s\n", err.Title))
        
        // Location if available
        if err.File != "" &amp;&amp; err.Line &gt; 0 </span><span class="cov8" title="1">{
                output.WriteString(fmt.Sprintf("  --&gt; %s:%d:%d\n", err.File, err.Line, err.Column))
        }</span> else<span class="cov8" title="1"> if err.File != "" </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("  --&gt; %s\n", err.File))
        }</span>
        
        // Field and value
        <span class="cov8" title="1">if err.Field != "" </span><span class="cov8" title="1">{
                output.WriteString("   |\n")
                if err.Value != "" </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("   | %s: %s\n", err.Field, err.Value))
                }</span> else<span class="cov8" title="1"> {
                        output.WriteString(fmt.Sprintf("   | %s\n", err.Field))
                }</span>
                <span class="cov8" title="1">output.WriteString("   |\n")</span>
        }
        
        // Help section
        <span class="cov8" title="1">if err.Help != "" </span><span class="cov8" title="1">{
                output.WriteString(fmt.Sprintf("   = help: %s\n", err.Help))
        }</span>
        
        // Note section
        <span class="cov8" title="1">if err.Note != "" </span><span class="cov8" title="1">{
                output.WriteString(fmt.Sprintf("   = note: %s\n", err.Note))
        }</span>
        
        // Suggestion section
        <span class="cov8" title="1">if err.Suggestion != "" </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("   = suggestion: %s\n", err.Suggestion))
        }</span>
        
        <span class="cov8" title="1">return output.String()</span>
}

func formatWarningSimple(warning ValidationError) string <span class="cov8" title="1">{
        var output strings.Builder
        
        // Warning header
        output.WriteString(fmt.Sprintf("warning: %s\n", warning.Title))
        
        // Location if available
        if warning.File != "" &amp;&amp; warning.Line &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("  --&gt; %s:%d:%d\n", warning.File, warning.Line, warning.Column))
        }</span>
        
        // Field and value
        <span class="cov8" title="1">if warning.Field != "" </span><span class="cov8" title="1">{
                output.WriteString("   |\n")
                if warning.Value != "" </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("   | %s: %s\n", warning.Field, warning.Value))
                }</span>
                <span class="cov8" title="1">output.WriteString("   |\n")</span>
        }
        
        // Help section
        <span class="cov8" title="1">if warning.Help != "" </span><span class="cov8" title="1">{
                output.WriteString(fmt.Sprintf("   = help: %s\n", warning.Help))
        }</span>
        
        <span class="cov8" title="1">return output.String()</span>
}

// FormatQuickFixSimple provides simple quick fix suggestions
func FormatQuickFixSimple(result *ValidationResult) string <span class="cov8" title="1">{
        if len(result.Errors) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        
        <span class="cov8" title="1">var output strings.Builder
        output.WriteString("\nQuick fixes:\n")
        
        for i, err := range result.Errors </span><span class="cov8" title="1">{
                if i &gt;= 3 </span><span class="cov8" title="1">{
                        remaining := len(result.Errors) - 3
                        output.WriteString(fmt.Sprintf("  ... and %d more errors\n", remaining))
                        break</span>
                }
                
                <span class="cov8" title="1">fix := getQuickFixSimple(err)
                if fix != "" </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("  • %s\n", fix))
                }</span>
        }
        
        <span class="cov8" title="1">return output.String()</span>
}

func getQuickFixSimple(err ValidationError) string <span class="cov8" title="1">{
        switch </span>{
        case strings.Contains(err.Title, "missing version"):<span class="cov8" title="1">
                return "Add 'version: \"1.0\"' to the top of your config file"</span>
        case strings.Contains(err.Title, "source file not found"):<span class="cov8" title="1">
                return fmt.Sprintf("Create missing file: %s", err.Value)</span>
        case strings.Contains(err.Title, "invalid file mode"):<span class="cov8" title="1">
                return fmt.Sprintf("Change mode to \"644\" in %s", err.Field)</span>
        case strings.Contains(err.Title, "empty package name"):<span class="cov8" title="1">
                return "Remove empty package entries from your lists"</span>
        case strings.Contains(err.Title, "invalid dconf path"):<span class="cov8" title="1">
                return fmt.Sprintf("Add '/' prefix to dconf path: %s", err.Value)</span>
        default:<span class="cov8" title="1">
                return err.Help</span>
        }
}</pre>
		
		<pre class="file" id="file15" style="display: none">package config

import (
        "fmt"
        "sort"
        "strings"
)

// InheritancePattern represents different inheritance strategies
type InheritancePattern int

const (
        InheritanceNone InheritancePattern = iota
        InheritanceOverride
        InheritanceMerge
        InheritanceAppend
        InheritancePrepend
)

// InheritanceRule defines how specific configuration sections should be inherited
type InheritanceRule struct {
        Section   string             `yaml:"section"`   // Configuration section (packages.apt, files, etc.)
        Pattern   InheritancePattern `yaml:"pattern"`   // How to inherit
        Priority  int                `yaml:"priority"`  // Priority for conflict resolution
        Condition string             `yaml:"condition"` // Optional condition for rule application
}

// InheritanceConfig defines inheritance rules for configuration merging
type InheritanceConfig struct {
        Rules        []InheritanceRule `yaml:"rules"`
        DefaultRule  InheritancePattern `yaml:"default_rule"`
        AllowOverride bool              `yaml:"allow_override"`
}

// ConfigInheritanceManager handles configuration inheritance
type ConfigInheritanceManager struct {
        rules       map[string]InheritanceRule
        defaultRule InheritancePattern
        allowOverride bool
}

// NewConfigInheritanceManager creates a new inheritance manager
func NewConfigInheritanceManager() *ConfigInheritanceManager <span class="cov0" title="0">{
        return &amp;ConfigInheritanceManager{
                rules:         make(map[string]InheritanceRule),
                defaultRule:   InheritanceMerge, // Safe default
                allowOverride: true,
        }
}</span>

// SetInheritanceRules sets the inheritance rules
func (cim *ConfigInheritanceManager) SetInheritanceRules(config InheritanceConfig) <span class="cov0" title="0">{
        cim.defaultRule = config.DefaultRule
        cim.allowOverride = config.AllowOverride
        
        // Clear existing rules
        cim.rules = make(map[string]InheritanceRule)
        
        // Set new rules
        for _, rule := range config.Rules </span><span class="cov0" title="0">{
                cim.rules[rule.Section] = rule
        }</span>
}

// GetBuiltinInheritanceRules returns sensible default inheritance rules
func (cim *ConfigInheritanceManager) GetBuiltinInheritanceRules() InheritanceConfig <span class="cov0" title="0">{
        return InheritanceConfig{
                DefaultRule:   InheritanceMerge,
                AllowOverride: true,
                Rules: []InheritanceRule{
                        // Package management: Append packages from parent configs
                        {Section: "packages.apt", Pattern: InheritanceAppend, Priority: 1},
                        {Section: "packages.flatpak", Pattern: InheritanceAppend, Priority: 1},
                        {Section: "packages.snap", Pattern: InheritanceAppend, Priority: 1},
                        
                        // Package defaults: Override (more specific configs take precedence)
                        {Section: "package_defaults", Pattern: InheritanceOverride, Priority: 2},
                        
                        // Files: Override (child configs override parent file configurations)
                        {Section: "files", Pattern: InheritanceOverride, Priority: 3},
                        
                        // DConf settings: Merge (combine settings from all levels)
                        {Section: "dconf.settings", Pattern: InheritanceMerge, Priority: 1},
                        
                        // Repositories: Merge (combine repositories from all levels)
                        {Section: "repositories.apt", Pattern: InheritanceMerge, Priority: 1},
                        {Section: "repositories.flatpak", Pattern: InheritanceMerge, Priority: 1},
                        
                        // Backup policy: Override (most specific config wins)
                        {Section: "backup_policy", Pattern: InheritanceOverride, Priority: 2},
                        
                        // Version: Override (child version takes precedence)
                        {Section: "version", Pattern: InheritanceOverride, Priority: 3},
                },
        }
}</span>

// MergeConfigsWithInheritance merges configurations using inheritance rules
func (cim *ConfigInheritanceManager) MergeConfigsWithInheritance(parent, child *Config) (*Config, error) <span class="cov0" title="0">{
        // Start with a copy of the child config
        result := cim.deepCopyConfig(child)
        
        // Apply inheritance rules for each section
        if err := cim.inheritPackages(&amp;result.Packages, &amp;parent.Packages); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to inherit packages: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := cim.inheritPackageDefaults(&amp;result.PackageDefaults, parent.PackageDefaults); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to inherit package defaults: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := cim.inheritFiles(&amp;result.Files, parent.Files); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to inherit files: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := cim.inheritDConfSettings(&amp;result.DConf.Settings, parent.DConf.Settings); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to inherit dconf settings: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := cim.inheritRepositories(&amp;result.Repositories, &amp;parent.Repositories); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to inherit repositories: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := cim.inheritBackupPolicy(&amp;result.BackupPolicy, parent.BackupPolicy); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to inherit backup policy: %w", err)
        }</span>
        
        <span class="cov0" title="0">if err := cim.inheritVersion(&amp;result.Version, parent.Version); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to inherit version: %w", err)
        }</span>
        
        <span class="cov0" title="0">return result, nil</span>
}

// inheritPackages handles package inheritance
func (cim *ConfigInheritanceManager) inheritPackages(child, parent *PackageManagement) error <span class="cov0" title="0">{
        // APT packages
        aptRule := cim.getRule("packages.apt")
        switch aptRule.Pattern </span>{
        case InheritanceAppend:<span class="cov0" title="0">
                child.Apt = cim.appendUniquePackages(parent.Apt, child.Apt)</span>
        case InheritancePrepend:<span class="cov0" title="0">
                child.Apt = cim.appendUniquePackages(child.Apt, parent.Apt)</span>
        case InheritanceOverride:<span class="cov0" title="0"></span>
                // Child already has precedence, nothing to do
        case InheritanceMerge:<span class="cov0" title="0">
                child.Apt = cim.mergePackages(parent.Apt, child.Apt)</span>
        }
        
        // Flatpak packages
        <span class="cov0" title="0">flatpakRule := cim.getRule("packages.flatpak")
        switch flatpakRule.Pattern </span>{
        case InheritanceAppend:<span class="cov0" title="0">
                child.Flatpak = cim.appendUniquePackages(parent.Flatpak, child.Flatpak)</span>
        case InheritancePrepend:<span class="cov0" title="0">
                child.Flatpak = cim.appendUniquePackages(child.Flatpak, parent.Flatpak)</span>
        case InheritanceOverride:<span class="cov0" title="0"></span>
                // Child already has precedence, nothing to do
        case InheritanceMerge:<span class="cov0" title="0">
                child.Flatpak = cim.mergePackages(parent.Flatpak, child.Flatpak)</span>
        }
        
        // Snap packages
        <span class="cov0" title="0">snapRule := cim.getRule("packages.snap")
        switch snapRule.Pattern </span>{
        case InheritanceAppend:<span class="cov0" title="0">
                child.Snap = cim.appendUniquePackages(parent.Snap, child.Snap)</span>
        case InheritancePrepend:<span class="cov0" title="0">
                child.Snap = cim.appendUniquePackages(child.Snap, parent.Snap)</span>
        case InheritanceOverride:<span class="cov0" title="0"></span>
                // Child already has precedence, nothing to do
        case InheritanceMerge:<span class="cov0" title="0">
                child.Snap = cim.mergePackages(parent.Snap, child.Snap)</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// inheritPackageDefaults handles package defaults inheritance
func (cim *ConfigInheritanceManager) inheritPackageDefaults(child *map[string][]string, parent map[string][]string) error <span class="cov0" title="0">{
        rule := cim.getRule("package_defaults")
        
        if *child == nil </span><span class="cov0" title="0">{
                *child = make(map[string][]string)
        }</span>
        
        <span class="cov0" title="0">switch rule.Pattern </span>{
        case InheritanceOverride:<span class="cov0" title="0">
                // Child takes precedence, only inherit missing keys
                for key, value := range parent </span><span class="cov0" title="0">{
                        if _, exists := (*child)[key]; !exists </span><span class="cov0" title="0">{
                                (*child)[key] = make([]string, len(value))
                                copy((*child)[key], value)
                        }</span>
                }
        case InheritanceMerge:<span class="cov0" title="0">
                // Merge values for each package manager
                for key, parentValues := range parent </span><span class="cov0" title="0">{
                        if childValues, exists := (*child)[key]; exists </span><span class="cov0" title="0">{
                                // Merge arrays
                                merged := make([]string, 0, len(parentValues)+len(childValues))
                                merged = append(merged, parentValues...)
                                for _, childValue := range childValues </span><span class="cov0" title="0">{
                                        if !contains(merged, childValue) </span><span class="cov0" title="0">{
                                                merged = append(merged, childValue)
                                        }</span>
                                }
                                <span class="cov0" title="0">(*child)[key] = merged</span>
                        } else<span class="cov0" title="0"> {
                                // Copy parent values
                                (*child)[key] = make([]string, len(parentValues))
                                copy((*child)[key], parentValues)
                        }</span>
                }
        case InheritanceAppend:<span class="cov0" title="0">
                // Append parent values to child values
                for key, parentValues := range parent </span><span class="cov0" title="0">{
                        if childValues, exists := (*child)[key]; exists </span><span class="cov0" title="0">{
                                for _, parentValue := range parentValues </span><span class="cov0" title="0">{
                                        if !contains(childValues, parentValue) </span><span class="cov0" title="0">{
                                                (*child)[key] = append((*child)[key], parentValue)
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                (*child)[key] = make([]string, len(parentValues))
                                copy((*child)[key], parentValues)
                        }</span>
                }
        case InheritancePrepend:<span class="cov0" title="0">
                // Prepend parent values to child values
                for key, parentValues := range parent </span><span class="cov0" title="0">{
                        if childValues, exists := (*child)[key]; exists </span><span class="cov0" title="0">{
                                newValues := make([]string, 0, len(parentValues)+len(childValues))
                                newValues = append(newValues, parentValues...)
                                for _, childValue := range childValues </span><span class="cov0" title="0">{
                                        if !contains(newValues, childValue) </span><span class="cov0" title="0">{
                                                newValues = append(newValues, childValue)
                                        }</span>
                                }
                                <span class="cov0" title="0">(*child)[key] = newValues</span>
                        } else<span class="cov0" title="0"> {
                                (*child)[key] = make([]string, len(parentValues))
                                copy((*child)[key], parentValues)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return nil</span>
}

// inheritFiles handles file inheritance
func (cim *ConfigInheritanceManager) inheritFiles(child *map[string]File, parent map[string]File) error <span class="cov0" title="0">{
        rule := cim.getRule("files")
        
        if *child == nil </span><span class="cov0" title="0">{
                *child = make(map[string]File)
        }</span>
        
        <span class="cov0" title="0">switch rule.Pattern </span>{
        case InheritanceOverride:<span class="cov0" title="0">
                // Child takes precedence, only inherit missing files
                for key, value := range parent </span><span class="cov0" title="0">{
                        if _, exists := (*child)[key]; !exists </span><span class="cov0" title="0">{
                                (*child)[key] = value
                        }</span>
                }
        case InheritanceMerge:<span class="cov0" title="0">
                // Merge file configurations (child properties override parent)
                for key, parentFile := range parent </span><span class="cov0" title="0">{
                        if childFile, exists := (*child)[key]; exists </span><span class="cov0" title="0">{
                                // Merge file properties
                                merged := parentFile
                                if childFile.Source != "" </span><span class="cov0" title="0">{
                                        merged.Source = childFile.Source
                                }</span>
                                <span class="cov0" title="0">if childFile.Destination != "" </span><span class="cov0" title="0">{
                                        merged.Destination = childFile.Destination
                                }</span>
                                <span class="cov0" title="0">if childFile.Owner != "" </span><span class="cov0" title="0">{
                                        merged.Owner = childFile.Owner
                                }</span>
                                <span class="cov0" title="0">if childFile.Group != "" </span><span class="cov0" title="0">{
                                        merged.Group = childFile.Group
                                }</span>
                                <span class="cov0" title="0">if childFile.Mode != "" </span><span class="cov0" title="0">{
                                        merged.Mode = childFile.Mode
                                }</span>
                                // Boolean fields: child value takes precedence if explicitly set
                                <span class="cov0" title="0">if childFile.Backup </span><span class="cov0" title="0">{
                                        merged.Backup = childFile.Backup
                                }</span>
                                <span class="cov0" title="0">if childFile.Copy </span><span class="cov0" title="0">{
                                        merged.Copy = childFile.Copy
                                }</span>
                                <span class="cov0" title="0">if childFile.Interactive </span><span class="cov0" title="0">{
                                        merged.Interactive = childFile.Interactive
                                }</span>
                                <span class="cov0" title="0">(*child)[key] = merged</span>
                        } else<span class="cov0" title="0"> {
                                (*child)[key] = parentFile
                        }</span>
                }
        case InheritanceAppend, InheritancePrepend:<span class="cov0" title="0">
                // For files, append/prepend is the same as merge
                return cim.inheritFiles(child, parent)</span> // Recursive call with merge logic
        }
        
        <span class="cov0" title="0">return nil</span>
}

// inheritDConfSettings handles DConf settings inheritance
func (cim *ConfigInheritanceManager) inheritDConfSettings(child *map[string]string, parent map[string]string) error <span class="cov0" title="0">{
        rule := cim.getRule("dconf.settings")
        
        if *child == nil </span><span class="cov0" title="0">{
                *child = make(map[string]string)
        }</span>
        
        <span class="cov0" title="0">switch rule.Pattern </span>{
        case InheritanceOverride:<span class="cov0" title="0">
                // Child takes precedence, only inherit missing settings
                for key, value := range parent </span><span class="cov0" title="0">{
                        if _, exists := (*child)[key]; !exists </span><span class="cov0" title="0">{
                                (*child)[key] = value
                        }</span>
                }
        case InheritanceMerge, InheritanceAppend, InheritancePrepend:<span class="cov0" title="0">
                // All merge for settings (child overrides parent for same key)
                for key, value := range parent </span><span class="cov0" title="0">{
                        if _, exists := (*child)[key]; !exists </span><span class="cov0" title="0">{
                                (*child)[key] = value
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return nil</span>
}

// inheritRepositories handles repository inheritance
func (cim *ConfigInheritanceManager) inheritRepositories(child, parent *RepositoryManagement) error <span class="cov0" title="0">{
        aptRule := cim.getRule("repositories.apt")
        flatpakRule := cim.getRule("repositories.flatpak")
        
        // Initialize child slices if nil
        if child.Apt == nil </span><span class="cov0" title="0">{
                child.Apt = make([]AptRepository, 0)
        }</span>
        <span class="cov0" title="0">if child.Flatpak == nil </span><span class="cov0" title="0">{
                child.Flatpak = make([]FlatpakRepository, 0)
        }</span>
        
        // Inherit APT repositories
        <span class="cov0" title="0">switch aptRule.Pattern </span>{
        case InheritanceOverride:<span class="cov0" title="0">
                // Add parent repos that don't exist in child
                for _, parentRepo := range parent.Apt </span><span class="cov0" title="0">{
                        found := false
                        for _, childRepo := range child.Apt </span><span class="cov0" title="0">{
                                if childRepo.Name == parentRepo.Name </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                child.Apt = append(child.Apt, parentRepo)
                        }</span>
                }
        case InheritanceMerge, InheritanceAppend, InheritancePrepend:<span class="cov0" title="0">
                // Add all parent repos that don't exist in child
                for _, parentRepo := range parent.Apt </span><span class="cov0" title="0">{
                        found := false
                        for _, childRepo := range child.Apt </span><span class="cov0" title="0">{
                                if childRepo.Name == parentRepo.Name </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                child.Apt = append(child.Apt, parentRepo)
                        }</span>
                }
        }
        
        // Inherit Flatpak repositories
        <span class="cov0" title="0">switch flatpakRule.Pattern </span>{
        case InheritanceOverride:<span class="cov0" title="0">
                // Add parent repos that don't exist in child
                for _, parentRepo := range parent.Flatpak </span><span class="cov0" title="0">{
                        found := false
                        for _, childRepo := range child.Flatpak </span><span class="cov0" title="0">{
                                if childRepo.Name == parentRepo.Name </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                child.Flatpak = append(child.Flatpak, parentRepo)
                        }</span>
                }
        case InheritanceMerge, InheritanceAppend, InheritancePrepend:<span class="cov0" title="0">
                // Add all parent repos that don't exist in child
                for _, parentRepo := range parent.Flatpak </span><span class="cov0" title="0">{
                        found := false
                        for _, childRepo := range child.Flatpak </span><span class="cov0" title="0">{
                                if childRepo.Name == parentRepo.Name </span><span class="cov0" title="0">{
                                        found = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                child.Flatpak = append(child.Flatpak, parentRepo)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return nil</span>
}

// inheritBackupPolicy handles backup policy inheritance
func (cim *ConfigInheritanceManager) inheritBackupPolicy(child *BackupPolicy, parent BackupPolicy) error <span class="cov0" title="0">{
        rule := cim.getRule("backup_policy")
        
        switch rule.Pattern </span>{
        case InheritanceOverride:<span class="cov0" title="0">
                // Only inherit values that are not set in child
                if !child.AutoCleanup &amp;&amp; parent.AutoCleanup </span><span class="cov0" title="0">{
                        child.AutoCleanup = parent.AutoCleanup
                }</span>
                <span class="cov0" title="0">if child.MaxAge == "" &amp;&amp; parent.MaxAge != "" </span><span class="cov0" title="0">{
                        child.MaxAge = parent.MaxAge
                }</span>
                <span class="cov0" title="0">if child.MaxCount == 0 &amp;&amp; parent.MaxCount &gt; 0 </span><span class="cov0" title="0">{
                        child.MaxCount = parent.MaxCount
                }</span>
                <span class="cov0" title="0">if !child.CleanupOrphaned &amp;&amp; parent.CleanupOrphaned </span><span class="cov0" title="0">{
                        child.CleanupOrphaned = parent.CleanupOrphaned
                }</span>
                <span class="cov0" title="0">if child.PreserveRecent == 0 &amp;&amp; parent.PreserveRecent &gt; 0 </span><span class="cov0" title="0">{
                        child.PreserveRecent = parent.PreserveRecent
                }</span>
        case InheritanceMerge:<span class="cov0" title="0">
                // Merge policies (child takes precedence for set values)
                if !child.AutoCleanup </span><span class="cov0" title="0">{
                        child.AutoCleanup = parent.AutoCleanup
                }</span>
                <span class="cov0" title="0">if child.MaxAge == "" </span><span class="cov0" title="0">{
                        child.MaxAge = parent.MaxAge
                }</span>
                <span class="cov0" title="0">if child.MaxCount == 0 </span><span class="cov0" title="0">{
                        child.MaxCount = parent.MaxCount
                }</span>
                <span class="cov0" title="0">if !child.CleanupOrphaned </span><span class="cov0" title="0">{
                        child.CleanupOrphaned = parent.CleanupOrphaned
                }</span>
                <span class="cov0" title="0">if child.PreserveRecent == 0 </span><span class="cov0" title="0">{
                        child.PreserveRecent = parent.PreserveRecent
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// inheritVersion handles version inheritance
func (cim *ConfigInheritanceManager) inheritVersion(child *string, parent string) error <span class="cov0" title="0">{
        rule := cim.getRule("version")
        
        switch rule.Pattern </span>{
        case InheritanceOverride:<span class="cov0" title="0">
                // Child version takes precedence
                if *child == "" &amp;&amp; parent != "" </span><span class="cov0" title="0">{
                        *child = parent
                }</span>
        case InheritanceMerge:<span class="cov0" title="0">
                // Use parent version if child doesn't specify one
                if *child == "" </span><span class="cov0" title="0">{
                        *child = parent
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// Helper methods

func (cim *ConfigInheritanceManager) getRule(section string) InheritanceRule <span class="cov0" title="0">{
        if rule, exists := cim.rules[section]; exists </span><span class="cov0" title="0">{
                return rule
        }</span>
        // Return default rule
        <span class="cov0" title="0">return InheritanceRule{
                Section:  section,
                Pattern:  cim.defaultRule,
                Priority: 1,
        }</span>
}

func (cim *ConfigInheritanceManager) appendUniquePackages(first, second []PackageEntry) []PackageEntry <span class="cov0" title="0">{
        result := make([]PackageEntry, len(first))
        copy(result, first)
        
        existingNames := make(map[string]bool)
        for _, pkg := range first </span><span class="cov0" title="0">{
                existingNames[pkg.Name] = true
        }</span>
        
        <span class="cov0" title="0">for _, pkg := range second </span><span class="cov0" title="0">{
                if !existingNames[pkg.Name] </span><span class="cov0" title="0">{
                        result = append(result, pkg)
                        existingNames[pkg.Name] = true
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}

func (cim *ConfigInheritanceManager) mergePackages(parent, child []PackageEntry) []PackageEntry <span class="cov0" title="0">{
        // Create a map for quick lookup
        childMap := make(map[string]PackageEntry)
        for _, pkg := range child </span><span class="cov0" title="0">{
                childMap[pkg.Name] = pkg
        }</span>
        
        // Start with parent packages
        <span class="cov0" title="0">result := make([]PackageEntry, 0, len(parent)+len(child))
        for _, parentPkg := range parent </span><span class="cov0" title="0">{
                if childPkg, exists := childMap[parentPkg.Name]; exists </span><span class="cov0" title="0">{
                        // Child overrides parent
                        result = append(result, childPkg)
                }</span> else<span class="cov0" title="0"> {
                        // No child override, use parent
                        result = append(result, parentPkg)
                }</span>
        }
        
        // Add child packages that weren't in parent
        <span class="cov0" title="0">for _, childPkg := range child </span><span class="cov0" title="0">{
                found := false
                for _, parentPkg := range parent </span><span class="cov0" title="0">{
                        if parentPkg.Name == childPkg.Name </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        result = append(result, childPkg)
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}

func (cim *ConfigInheritanceManager) deepCopyConfig(original *Config) *Config <span class="cov0" title="0">{
        if original == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">result := &amp;Config{
                Version:         original.Version,
                PackageDefaults: make(map[string][]string),
                BackupPolicy:    original.BackupPolicy,
                Files:           make(map[string]File),
                DConf: DConfConfig{
                        Settings: make(map[string]string),
                },
                Repositories: RepositoryManagement{
                        Apt:     make([]AptRepository, 0),
                        Flatpak: make([]FlatpakRepository, 0),
                },
                Packages: PackageManagement{
                        Apt:     make([]PackageEntry, len(original.Packages.Apt)),
                        Flatpak: make([]PackageEntry, len(original.Packages.Flatpak)),
                        Snap:    make([]PackageEntry, len(original.Packages.Snap)),
                },
                Includes: make([]IncludeSpec, len(original.Includes)),
        }
        
        // Deep copy slices and maps
        copy(result.Packages.Apt, original.Packages.Apt)
        copy(result.Packages.Flatpak, original.Packages.Flatpak)
        copy(result.Packages.Snap, original.Packages.Snap)
        copy(result.Includes, original.Includes)
        
        for k, v := range original.PackageDefaults </span><span class="cov0" title="0">{
                result.PackageDefaults[k] = make([]string, len(v))
                copy(result.PackageDefaults[k], v)
        }</span>
        
        <span class="cov0" title="0">for k, v := range original.Files </span><span class="cov0" title="0">{
                result.Files[k] = v
        }</span>
        
        <span class="cov0" title="0">for k, v := range original.DConf.Settings </span><span class="cov0" title="0">{
                result.DConf.Settings[k] = v
        }</span>
        
        <span class="cov0" title="0">result.Repositories.Apt = make([]AptRepository, len(original.Repositories.Apt))
        copy(result.Repositories.Apt, original.Repositories.Apt)
        
        result.Repositories.Flatpak = make([]FlatpakRepository, len(original.Repositories.Flatpak))
        copy(result.Repositories.Flatpak, original.Repositories.Flatpak)
        
        return result</span>
}

// CreateInheritanceChain creates a chain of configurations for inheritance processing
func (cim *ConfigInheritanceManager) CreateInheritanceChain(configs []*Config) (*Config, error) <span class="cov0" title="0">{
        if len(configs) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no configurations provided")
        }</span>
        
        <span class="cov0" title="0">if len(configs) == 1 </span><span class="cov0" title="0">{
                return configs[0], nil
        }</span>
        
        // Sort configs by priority (most general to most specific)
        // For now, we'll use the order provided, but this could be enhanced
        // with explicit priority fields in the configuration
        
        <span class="cov0" title="0">result := configs[0]
        for i := 1; i &lt; len(configs); i++ </span><span class="cov0" title="0">{
                merged, err := cim.MergeConfigsWithInheritance(result, configs[i])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to merge config %d: %w", i, err)
                }</span>
                <span class="cov0" title="0">result = merged</span>
        }
        
        <span class="cov0" title="0">return result, nil</span>
}

// ValidateInheritanceRules validates inheritance rules
func (cim *ConfigInheritanceManager) ValidateInheritanceRules(config InheritanceConfig) error <span class="cov0" title="0">{
        validSections := map[string]bool{
                "packages.apt":        true,
                "packages.flatpak":    true,
                "packages.snap":       true,
                "package_defaults":    true,
                "files":               true,
                "dconf.settings":      true,
                "repositories.apt":    true,
                "repositories.flatpak": true,
                "backup_policy":       true,
                "version":             true,
        }
        
        for _, rule := range config.Rules </span><span class="cov0" title="0">{
                if !validSections[rule.Section] </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid section in inheritance rule: %s", rule.Section)
                }</span>
                
                <span class="cov0" title="0">if rule.Priority &lt; 1 || rule.Priority &gt; 10 </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid priority %d for section %s (must be 1-10)", rule.Priority, rule.Section)
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// GetInheritanceReport generates a report of how configurations were inherited
func (cim *ConfigInheritanceManager) GetInheritanceReport(configs []*Config, result *Config) string <span class="cov0" title="0">{
        var report strings.Builder
        
        report.WriteString("Configuration Inheritance Report\n")
        report.WriteString("================================\n\n")
        
        report.WriteString(fmt.Sprintf("Merged %d configuration(s) using inheritance rules:\n\n", len(configs)))
        
        // Sort rules by priority for display
        var rules []InheritanceRule
        for _, rule := range cim.rules </span><span class="cov0" title="0">{
                rules = append(rules, rule)
        }</span>
        <span class="cov0" title="0">sort.Slice(rules, func(i, j int) bool </span><span class="cov0" title="0">{
                return rules[i].Priority &lt; rules[j].Priority
        }</span>)
        
        <span class="cov0" title="0">report.WriteString("Inheritance Rules Applied:\n")
        for _, rule := range rules </span><span class="cov0" title="0">{
                patternName := cim.getPatternName(rule.Pattern)
                report.WriteString(fmt.Sprintf("  %s: %s (priority %d)\n", rule.Section, patternName, rule.Priority))
        }</span>
        
        <span class="cov0" title="0">report.WriteString(fmt.Sprintf("\nDefault Rule: %s\n", cim.getPatternName(cim.defaultRule)))
        report.WriteString(fmt.Sprintf("Allow Override: %t\n\n", cim.allowOverride))
        
        // Summary of merged configuration
        aptCount := len(result.Packages.Apt)
        flatpakCount := len(result.Packages.Flatpak)
        snapCount := len(result.Packages.Snap)
        totalPackages := aptCount + flatpakCount + snapCount
        
        report.WriteString("Final Configuration Summary:\n")
        report.WriteString(fmt.Sprintf("  Version: %s\n", result.Version))
        report.WriteString(fmt.Sprintf("  Total Packages: %d (APT: %d, Flatpak: %d, Snap: %d)\n", 
                totalPackages, aptCount, flatpakCount, snapCount))
        report.WriteString(fmt.Sprintf("  Files: %d\n", len(result.Files)))
        report.WriteString(fmt.Sprintf("  DConf Settings: %d\n", len(result.DConf.Settings)))
        report.WriteString(fmt.Sprintf("  APT Repositories: %d\n", len(result.Repositories.Apt)))
        report.WriteString(fmt.Sprintf("  Flatpak Repositories: %d\n", len(result.Repositories.Flatpak)))
        
        return report.String()</span>
}

func (cim *ConfigInheritanceManager) getPatternName(pattern InheritancePattern) string <span class="cov0" title="0">{
        switch pattern </span>{
        case InheritanceNone:<span class="cov0" title="0">
                return "None"</span>
        case InheritanceOverride:<span class="cov0" title="0">
                return "Override"</span>
        case InheritanceMerge:<span class="cov0" title="0">
                return "Merge"</span>
        case InheritanceAppend:<span class="cov0" title="0">
                return "Append"</span>
        case InheritancePrepend:<span class="cov0" title="0">
                return "Prepend"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}</pre>
		
		<pre class="file" id="file16" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/spf13/viper"
        "gopkg.in/yaml.v3"
)

// LoadWithIncludes reads and parses the configuration file with include support
func LoadWithIncludes() (*Config, error) <span class="cov8" title="1">{
        rootConfigPath := viper.ConfigFileUsed()
        if rootConfigPath == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no config file found")
        }</span>

        <span class="cov8" title="1">visited := make(map[string]bool)
        return loadConfigRecursive(rootConfigPath, visited)</span>
}

// loadConfigRecursive loads a config file and processes its includes
func loadConfigRecursive(configPath string, visited map[string]bool) (*Config, error) <span class="cov8" title="1">{
        // Prevent circular includes
        absPath, err := filepath.Abs(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get absolute path for %s: %w", configPath, err)
        }</span>

        <span class="cov8" title="1">if visited[absPath] </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("circular include detected: %s", absPath)
        }</span>
        <span class="cov8" title="1">visited[absPath] = true

        // Load the config file
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file %s: %w", configPath, err)
        }</span>

        <span class="cov8" title="1">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal config file %s: %w", configPath, err)
        }</span>

        // Process includes
        <span class="cov8" title="1">if len(config.Includes) &gt; 0 </span><span class="cov8" title="1">{
                baseDir := filepath.Dir(configPath)
                
                for _, includePath := range config.Includes </span><span class="cov8" title="1">{
                        resolvedPath, err := resolveIncludePath(baseDir, includePath.Path)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to resolve include path %s: %w", includePath.Path, err)
                        }</span>

                        <span class="cov8" title="1">includedConfig, err := loadConfigRecursive(resolvedPath, visited)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("failed to load included config %s: %w", resolvedPath, err)
                        }</span>

                        // Merge the included config into the current config
                        <span class="cov8" title="1">if err := mergeConfigs(&amp;config, includedConfig); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to merge config %s: %w", resolvedPath, err)
                        }</span>
                }
        }

        // Clean up the visited map for this branch
        <span class="cov8" title="1">delete(visited, absPath)

        return &amp;config, nil</span>
}

// resolveIncludePath resolves include paths with support for directories and default.yaml
func resolveIncludePath(baseDir, includePath string) (string, error) <span class="cov8" title="1">{
        // Normalize trailing slash for consistency
        normalizedPath := includePath
        if strings.HasSuffix(includePath, "/") </span><span class="cov8" title="1">{
                // Remove trailing slash to avoid double slashes when joining
                normalizedPath = strings.TrimSuffix(includePath, "/")
        }</span>
        
        <span class="cov8" title="1">fullPath := filepath.Join(baseDir, normalizedPath)

        // If the original path had a trailing slash, treat as directory
        if strings.HasSuffix(includePath, "/") </span><span class="cov8" title="1">{
                // Must be a directory, look for default.yaml
                if info, err := os.Stat(fullPath); err != nil || !info.IsDir() </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("directory %s not found", fullPath)
                }</span>
                <span class="cov8" title="1">defaultPath := filepath.Join(fullPath, "default.yaml")
                if _, err := os.Stat(defaultPath); err == nil </span><span class="cov8" title="1">{
                        return defaultPath, nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("directory %s exists but no default.yaml found", fullPath)</span>
        }

        // Check if it's a directory (without trailing slash)
        <span class="cov8" title="1">if info, err := os.Stat(fullPath); err == nil &amp;&amp; info.IsDir() </span><span class="cov8" title="1">{
                // If directory, look for default.yaml
                defaultPath := filepath.Join(fullPath, "default.yaml")
                if _, err := os.Stat(defaultPath); err == nil </span><span class="cov8" title="1">{
                        return defaultPath, nil
                }</span>
                <span class="cov0" title="0">return "", fmt.Errorf("directory %s exists but no default.yaml found", fullPath)</span>
        }

        // Check if explicit file exists
        <span class="cov8" title="1">if _, err := os.Stat(fullPath); err == nil </span><span class="cov8" title="1">{
                return fullPath, nil
        }</span>

        // If no extension, assume .yaml
        <span class="cov8" title="1">if filepath.Ext(fullPath) == "" </span><span class="cov0" title="0">{
                yamlPath := fullPath + ".yaml"
                if _, err := os.Stat(yamlPath); err == nil </span><span class="cov0" title="0">{
                        return yamlPath, nil
                }</span>
        }

        <span class="cov8" title="1">return "", fmt.Errorf("include path not found: %s", includePath)</span>
}

// mergeConfigs merges src config into dst config
func mergeConfigs(dst, src *Config) error <span class="cov8" title="1">{
        // Merge packages (remove duplicates)
        dst.Packages.Apt = removeDuplicatePackages(append(dst.Packages.Apt, src.Packages.Apt...))
        dst.Packages.Flatpak = removeDuplicatePackages(append(dst.Packages.Flatpak, src.Packages.Flatpak...))
        dst.Packages.Snap = removeDuplicatePackages(append(dst.Packages.Snap, src.Packages.Snap...))

        // Merge files (src overwrites dst if same key)
        if dst.Files == nil </span><span class="cov8" title="1">{
                dst.Files = make(map[string]File)
        }</span>
        <span class="cov8" title="1">for key, file := range src.Files </span><span class="cov8" title="1">{
                dst.Files[key] = file
        }</span>

        // Merge dconf settings (src overwrites dst if same key)
        <span class="cov8" title="1">if dst.DConf.Settings == nil </span><span class="cov8" title="1">{
                dst.DConf.Settings = make(map[string]string)
        }</span>
        <span class="cov8" title="1">for key, value := range src.DConf.Settings </span><span class="cov8" title="1">{
                dst.DConf.Settings[key] = value
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// removeDuplicates removes duplicate strings from a slice while preserving order
func removeDuplicates(slice []string) []string <span class="cov0" title="0">{
        seen := make(map[string]bool)
        result := make([]string, 0, len(slice))
        
        for _, item := range slice </span><span class="cov0" title="0">{
                if !seen[item] </span><span class="cov0" title="0">{
                        seen[item] = true
                        result = append(result, item)
                }</span>
        }
        
        <span class="cov0" title="0">return result</span>
}

// removeDuplicatePackages removes duplicate PackageEntry instances from a slice while preserving order
// Duplicates are determined by package name only (flags can differ)
func removeDuplicatePackages(slice []PackageEntry) []PackageEntry <span class="cov8" title="1">{
        seen := make(map[string]bool)
        result := make([]PackageEntry, 0, len(slice))
        
        for _, item := range slice </span><span class="cov8" title="1">{
                if !seen[item.Name] </span><span class="cov8" title="1">{
                        seen[item.Name] = true
                        result = append(result, item)
                }</span>
        }
        
        <span class="cov8" title="1">return result</span>
}</pre>
		
		<pre class="file" id="file17" style="display: none">package config

import (
        "os"

        "github.com/charmbracelet/log"
)

var Logger *log.Logger

func init() <span class="cov8" title="1">{
        Logger = log.NewWithOptions(os.Stderr, log.Options{
                ReportCaller:    false,
                ReportTimestamp: false,
                Prefix:         "configr",
        })
        
        // Set default level to info (can be overridden)
        Logger.SetLevel(log.InfoLevel)
}</span>

// SetVerbose enables verbose logging
func SetVerbose(verbose bool) <span class="cov0" title="0">{
        if verbose </span><span class="cov0" title="0">{
                Logger.SetLevel(log.DebugLevel)
        }</span> else<span class="cov0" title="0"> {
                Logger.SetLevel(log.InfoLevel)
        }</span>
}

// Success logs a success message with checkmark
func Success(msg string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Info("✓ "+msg, args...)
}</span>

// Warning logs a warning message
func Warning(msg string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Warn("⚠ "+msg, args...)
}</span>

// Error logs an error message
func Error(msg string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Error("✗ "+msg, args...)
}</span>

// Info logs an info message
func Info(msg string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Info(msg, args...)
}</span>

// Debug logs a debug message (only shown in verbose mode)
func Debug(msg string, args ...interface{}) <span class="cov0" title="0">{
        Logger.Debug(msg, args...)
}</pre>
		
		<pre class="file" id="file18" style="display: none">package config

import (
        "fmt"

        "gopkg.in/yaml.v3"
)

// UnmarshalYAML implements custom unmarshaling for PackageEntry
// Supports both simple string and complex nested formats:
//   Simple: - "package-name"
//   Complex: - "package-name":
//              flags: ["--flag1", "--flag2"]
func (pe *PackageEntry) UnmarshalYAML(node *yaml.Node) error <span class="cov8" title="1">{
        // Handle simple string format: - "package-name"
        if node.Kind == yaml.ScalarNode </span><span class="cov8" title="1">{
                pe.Name = node.Value
                pe.Flags = []string{}
                return nil
        }</span>

        // Handle complex nested format: - "package-name": { flags: [...] }
        <span class="cov8" title="1">if node.Kind == yaml.MappingNode </span><span class="cov8" title="1">{
                if len(node.Content) != 2 </span><span class="cov8" title="1">{
                        return fmt.Errorf("package entry must have exactly one key-value pair")
                }</span>

                // First node is the package name (key)
                <span class="cov8" title="1">if node.Content[0].Kind != yaml.ScalarNode </span><span class="cov0" title="0">{
                        return fmt.Errorf("package name must be a string")
                }</span>
                <span class="cov8" title="1">pe.Name = node.Content[0].Value

                // Second node is the configuration (value)
                configNode := node.Content[1]
                
                // Initialize with empty flags
                pe.Flags = []string{}

                // If the value is a mapping, parse the configuration
                if configNode.Kind == yaml.MappingNode </span><span class="cov8" title="1">{
                        var config struct {
                                Flags []string `yaml:"flags,omitempty"`
                        }
                        if err := configNode.Decode(&amp;config); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to decode package configuration for %s: %w", pe.Name, err)
                        }</span>
                        <span class="cov8" title="1">pe.Flags = config.Flags</span>
                }

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("package entry must be either a string or a mapping")</span>
}

// MarshalYAML implements custom marshaling for PackageEntry
// Outputs simple format if no flags, complex format if flags exist
func (pe PackageEntry) MarshalYAML() (interface{}, error) <span class="cov8" title="1">{
        // Simple format if no flags
        if len(pe.Flags) == 0 </span><span class="cov8" title="1">{
                return pe.Name, nil
        }</span>

        // Complex format with flags
        <span class="cov8" title="1">return map[string]interface{}{
                pe.Name: map[string]interface{}{
                        "flags": pe.Flags,
                },
        }, nil</span>
}

// GetEffectiveFlags returns the flags that should be used for this package
// considering the three-tier hierarchy: internal defaults -&gt; user defaults -&gt; package flags
func (pe *PackageEntry) GetEffectiveFlags(packageManager string, userDefaults map[string][]string) []string <span class="cov0" title="0">{
        // Tier 3: If package has specific flags, use those (highest priority)
        if len(pe.Flags) &gt; 0 </span><span class="cov0" title="0">{
                result := make([]string, len(pe.Flags))
                copy(result, pe.Flags)
                return result
        }</span>

        // Tier 2: If user has defaults for this package manager, use those
        <span class="cov0" title="0">if userDefaults != nil </span><span class="cov0" title="0">{
                if userFlags, exists := userDefaults[packageManager]; exists </span><span class="cov0" title="0">{
                        result := make([]string, len(userFlags))
                        copy(result, userFlags)
                        return result
                }</span>
        }

        // Tier 1: Use internal defaults (lowest priority)
        <span class="cov0" title="0">return GetDefaultFlags(packageManager)</span>
}

// HasCustomFlags returns true if this package entry has custom flags defined
func (pe *PackageEntry) HasCustomFlags() bool <span class="cov0" title="0">{
        return len(pe.Flags) &gt; 0
}</span>

// String returns a string representation of the package entry for debugging
func (pe PackageEntry) String() string <span class="cov0" title="0">{
        if len(pe.Flags) == 0 </span><span class="cov0" title="0">{
                return pe.Name
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s (flags: %v)", pe.Name, pe.Flags)</span>
}</pre>
		
		<pre class="file" id="file19" style="display: none">package config

import (
        "fmt"
        "os"
        "strings"

        "gopkg.in/yaml.v3"
)

// ConfigWithPosition contains config data with line/column position information
type ConfigWithPosition struct {
        Config   *Config
        YAMLNode *yaml.Node
        FilePath string
}

// ParseConfigWithPosition parses YAML and retains position information for better error reporting
func ParseConfigWithPosition(configPath string) (*ConfigWithPosition, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read config file %s: %w", configPath, err)
        }</span>

        <span class="cov0" title="0">var rootNode yaml.Node
        if err := yaml.Unmarshal(data, &amp;rootNode); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse YAML in %s: %w", configPath, err)
        }</span>

        <span class="cov0" title="0">var config Config
        if err := rootNode.Decode(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode config in %s: %w", configPath, err)
        }</span>

        <span class="cov0" title="0">return &amp;ConfigWithPosition{
                Config:   &amp;config,
                YAMLNode: &amp;rootNode,
                FilePath: configPath,
        }, nil</span>
}

// FindFieldPosition finds the line and column for a given field path
func (cp *ConfigWithPosition) FindFieldPosition(fieldPath string) (line, column int) <span class="cov0" title="0">{
        if cp.YAMLNode == nil || len(cp.YAMLNode.Content) == 0 </span><span class="cov0" title="0">{
                return 0, 0
        }</span>

        // Split field path (e.g., "files.vimrc.source")
        <span class="cov0" title="0">parts := strings.Split(fieldPath, ".")
        
        // Start with the document root
        node := cp.YAMLNode.Content[0] // Document node
        
        for _, part := range parts </span><span class="cov0" title="0">{
                node = findMapValue(node, part)
                if node == nil </span><span class="cov0" title="0">{
                        return 0, 0
                }</span>
        }

        <span class="cov0" title="0">return node.Line, node.Column</span>
}

// findMapValue finds a value in a YAML mapping node
func findMapValue(node *yaml.Node, key string) *yaml.Node <span class="cov0" title="0">{
        if node == nil || node.Kind != yaml.MappingNode </span><span class="cov0" title="0">{
                return nil
        }</span>

        // YAML mapping nodes have alternating key-value content
        <span class="cov0" title="0">for i := 0; i &lt; len(node.Content); i += 2 </span><span class="cov0" title="0">{
                if i+1 &lt; len(node.Content) &amp;&amp; node.Content[i].Value == key </span><span class="cov0" title="0">{
                        return node.Content[i+1] // Return the value node
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetValueAtPosition gets the actual YAML value at a specific field position
func (cp *ConfigWithPosition) GetValueAtPosition(fieldPath string) string <span class="cov0" title="0">{
        parts := strings.Split(fieldPath, ".")
        node := cp.YAMLNode.Content[0] // Document root

        for _, part := range parts </span><span class="cov0" title="0">{
                node = findMapValue(node, part)
                if node == nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
        }

        <span class="cov0" title="0">return node.Value</span>
}

// ValidateFieldExists checks if a field path exists in the parsed YAML
func (cp *ConfigWithPosition) ValidateFieldExists(fieldPath string) bool <span class="cov0" title="0">{
        parts := strings.Split(fieldPath, ".")
        node := cp.YAMLNode.Content[0]

        for _, part := range parts </span><span class="cov0" title="0">{
                node = findMapValue(node, part)
                if node == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}</pre>
		
		<pre class="file" id="file20" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "gopkg.in/yaml.v3"
)

// ConfigSplitter handles configuration splitting strategies
type ConfigSplitter struct {
        baseDir string
}

// NewConfigSplitter creates a new configuration splitter
func NewConfigSplitter(baseDir string) *ConfigSplitter <span class="cov0" title="0">{
        return &amp;ConfigSplitter{
                baseDir: baseDir,
        }
}</span>

// SplitStrategy represents different configuration splitting strategies
type SplitStrategy int

const (
        SplitByPackageManager SplitStrategy = iota
        SplitByDomain
        SplitByEnvironment
        SplitByHost
        SplitByFunction
)

// SplitConfig splits a configuration into multiple files based on the specified strategy
func (cs *ConfigSplitter) SplitConfig(config *Config, strategy SplitStrategy) (map[string]*Config, error) <span class="cov0" title="0">{
        switch strategy </span>{
        case SplitByPackageManager:<span class="cov0" title="0">
                return cs.splitByPackageManager(config)</span>
        case SplitByDomain:<span class="cov0" title="0">
                return cs.splitByDomain(config)</span>
        case SplitByEnvironment:<span class="cov0" title="0">
                return cs.splitByEnvironment(config)</span>
        case SplitByHost:<span class="cov0" title="0">
                return cs.splitByHost(config)</span>
        case SplitByFunction:<span class="cov0" title="0">
                return cs.splitByFunction(config)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown split strategy: %d", strategy)</span>
        }
}

// splitByPackageManager splits configuration by package managers
func (cs *ConfigSplitter) splitByPackageManager(config *Config) (map[string]*Config, error) <span class="cov0" title="0">{
        result := make(map[string]*Config)

        // Create base config with common settings
        baseConfig := &amp;Config{
                Version:         config.Version,
                PackageDefaults: config.PackageDefaults,
                BackupPolicy:    config.BackupPolicy,
                Includes:        []IncludeSpec{},
        }

        // Split APT packages
        if len(config.Packages.Apt) &gt; 0 </span><span class="cov0" title="0">{
                aptConfig := &amp;Config{
                        Version: config.Version,
                        Packages: PackageManagement{
                                Apt: config.Packages.Apt,
                        },
                }
                result["packages/apt.yaml"] = aptConfig
                baseConfig.Includes = append(baseConfig.Includes, IncludeSpec{
                        Path:        "packages/apt.yaml",
                        Description: "APT package management",
                })
        }</span>

        // Split Flatpak packages
        <span class="cov0" title="0">if len(config.Packages.Flatpak) &gt; 0 </span><span class="cov0" title="0">{
                flatpakConfig := &amp;Config{
                        Version: config.Version,
                        Packages: PackageManagement{
                                Flatpak: config.Packages.Flatpak,
                        },
                }
                result["packages/flatpak.yaml"] = flatpakConfig
                baseConfig.Includes = append(baseConfig.Includes, IncludeSpec{
                        Path:        "packages/flatpak.yaml",
                        Description: "Flatpak package management",
                })
        }</span>

        // Split Snap packages
        <span class="cov0" title="0">if len(config.Packages.Snap) &gt; 0 </span><span class="cov0" title="0">{
                snapConfig := &amp;Config{
                        Version: config.Version,
                        Packages: PackageManagement{
                                Snap: config.Packages.Snap,
                        },
                }
                result["packages/snap.yaml"] = snapConfig
                baseConfig.Includes = append(baseConfig.Includes, IncludeSpec{
                        Path:        "packages/snap.yaml",
                        Description: "Snap package management",
                })
        }</span>

        // Split repositories
        <span class="cov0" title="0">if len(config.Repositories.Apt) &gt; 0 || len(config.Repositories.Flatpak) &gt; 0 </span><span class="cov0" title="0">{
                repoConfig := &amp;Config{
                        Version:      config.Version,
                        Repositories: config.Repositories,
                }
                result["repositories.yaml"] = repoConfig
                baseConfig.Includes = append(baseConfig.Includes, IncludeSpec{
                        Path:        "repositories.yaml",
                        Description: "Repository management",
                })
        }</span>

        // Split files
        <span class="cov0" title="0">if len(config.Files) &gt; 0 </span><span class="cov0" title="0">{
                filesConfig := &amp;Config{
                        Version: config.Version,
                        Files:   config.Files,
                }
                result["files.yaml"] = filesConfig
                baseConfig.Includes = append(baseConfig.Includes, IncludeSpec{
                        Path:        "files.yaml",
                        Description: "File management",
                })
        }</span>

        // Split DConf settings
        <span class="cov0" title="0">if len(config.DConf.Settings) &gt; 0 </span><span class="cov0" title="0">{
                dconfConfig := &amp;Config{
                        Version: config.Version,
                        DConf:   config.DConf,
                }
                result["dconf.yaml"] = dconfConfig
                baseConfig.Includes = append(baseConfig.Includes, IncludeSpec{
                        Path:        "dconf.yaml",
                        Description: "DConf settings management",
                })
        }</span>

        <span class="cov0" title="0">result["configr.yaml"] = baseConfig
        return result, nil</span>
}

// splitByDomain splits configuration by functional domains
func (cs *ConfigSplitter) splitByDomain(config *Config) (map[string]*Config, error) <span class="cov0" title="0">{
        result := make(map[string]*Config)

        // Create base config
        baseConfig := &amp;Config{
                Version:         config.Version,
                PackageDefaults: config.PackageDefaults,
                BackupPolicy:    config.BackupPolicy,
                Includes:        []IncludeSpec{},
        }

        // Development tools domain
        devPackages := cs.filterPackagesByDomain(config.Packages, "development")
        if len(devPackages.Apt) &gt; 0 || len(devPackages.Flatpak) &gt; 0 || len(devPackages.Snap) &gt; 0 </span><span class="cov0" title="0">{
                devConfig := &amp;Config{
                        Version:  config.Version,
                        Packages: devPackages,
                }
                result["domains/development.yaml"] = devConfig
                baseConfig.Includes = append(baseConfig.Includes, IncludeSpec{
                        Path:        "domains/development.yaml",
                        Description: "Development tools and environments",
                })
        }</span>

        // Media domain
        <span class="cov0" title="0">mediaPackages := cs.filterPackagesByDomain(config.Packages, "media")
        if len(mediaPackages.Apt) &gt; 0 || len(mediaPackages.Flatpak) &gt; 0 || len(mediaPackages.Snap) &gt; 0 </span><span class="cov0" title="0">{
                mediaConfig := &amp;Config{
                        Version:  config.Version,
                        Packages: mediaPackages,
                }
                result["domains/media.yaml"] = mediaConfig
                baseConfig.Includes = append(baseConfig.Includes, IncludeSpec{
                        Path:        "domains/media.yaml",
                        Description: "Media tools and applications",
                })
        }</span>

        // System utilities domain
        <span class="cov0" title="0">systemPackages := cs.filterPackagesByDomain(config.Packages, "system")
        if len(systemPackages.Apt) &gt; 0 || len(systemPackages.Flatpak) &gt; 0 || len(systemPackages.Snap) &gt; 0 </span><span class="cov0" title="0">{
                systemConfig := &amp;Config{
                        Version:  config.Version,
                        Packages: systemPackages,
                }
                result["domains/system.yaml"] = systemConfig
                baseConfig.Includes = append(baseConfig.Includes, IncludeSpec{
                        Path:        "domains/system.yaml",
                        Description: "System utilities and tools",
                })
        }</span>

        <span class="cov0" title="0">result["configr.yaml"] = baseConfig
        return result, nil</span>
}

// splitByEnvironment splits configuration by environment (dev, staging, prod)
func (cs *ConfigSplitter) splitByEnvironment(config *Config) (map[string]*Config, error) <span class="cov0" title="0">{
        result := make(map[string]*Config)

        // Create base config with common settings
        baseConfig := &amp;Config{
                Version:         config.Version,
                PackageDefaults: config.PackageDefaults,
                BackupPolicy:    config.BackupPolicy,
                Repositories:    config.Repositories,
                Includes: []IncludeSpec{
                        {
                                Path:        "environments/common.yaml",
                                Description: "Common packages and settings",
                        },
                        {
                                Path:        "environments/development.yaml",
                                Description: "Development environment specific settings",
                                Optional:    true,
                                Conditions: []IncludeCondition{
                                        {
                                                Type:     "env",
                                                Value:    "NODE_ENV=development",
                                                Operator: "equals",
                                        },
                                },
                        },
                        {
                                Path:        "environments/production.yaml",
                                Description: "Production environment specific settings",
                                Optional:    true,
                                Conditions: []IncludeCondition{
                                        {
                                                Type:     "env",
                                                Value:    "NODE_ENV=production",
                                                Operator: "equals",
                                        },
                                },
                        },
                },
        }

        // Common packages (subset of original)
        commonPackages := cs.getCommonPackages(config.Packages)
        commonConfig := &amp;Config{
                Version:  config.Version,
                Packages: commonPackages,
                Files:    config.Files, // Most files are common
                DConf:    config.DConf, // DConf settings are usually common
        }
        result["environments/common.yaml"] = commonConfig

        // Development-specific packages
        devPackages := cs.getDevelopmentPackages(config.Packages)
        if len(devPackages.Apt) &gt; 0 || len(devPackages.Flatpak) &gt; 0 || len(devPackages.Snap) &gt; 0 </span><span class="cov0" title="0">{
                devConfig := &amp;Config{
                        Version:  config.Version,
                        Packages: devPackages,
                }
                result["environments/development.yaml"] = devConfig
        }</span>

        // Production-specific packages (minimal)
        <span class="cov0" title="0">prodPackages := cs.getProductionPackages(config.Packages)
        if len(prodPackages.Apt) &gt; 0 || len(prodPackages.Flatpak) &gt; 0 || len(prodPackages.Snap) &gt; 0 </span><span class="cov0" title="0">{
                prodConfig := &amp;Config{
                        Version:  config.Version,
                        Packages: prodPackages,
                }
                result["environments/production.yaml"] = prodConfig
        }</span>

        <span class="cov0" title="0">result["configr.yaml"] = baseConfig
        return result, nil</span>
}

// splitByHost splits configuration by hostname patterns
func (cs *ConfigSplitter) splitByHost(config *Config) (map[string]*Config, error) <span class="cov0" title="0">{
        result := make(map[string]*Config)

        // Create base config with common settings
        baseConfig := &amp;Config{
                Version:         config.Version,
                PackageDefaults: config.PackageDefaults,
                BackupPolicy:    config.BackupPolicy,
                Repositories:    config.Repositories,
                Includes: []IncludeSpec{
                        {
                                Path:        "hosts/common.yaml",
                                Description: "Common configuration for all hosts",
                        },
                        {
                                Path:        "hosts/workstation-*.yaml",
                                Description: "Workstation-specific configuration",
                                Optional:    true,
                                Conditions: []IncludeCondition{
                                        {
                                                Type:     "hostname",
                                                Value:    "workstation",
                                                Operator: "contains",
                                        },
                                },
                        },
                        {
                                Path:        "hosts/laptop-*.yaml",
                                Description: "Laptop-specific configuration",
                                Optional:    true,
                                Conditions: []IncludeCondition{
                                        {
                                                Type:     "hostname",
                                                Value:    "laptop",
                                                Operator: "contains",
                                        },
                                },
                        },
                        {
                                Path:        "hosts/server-*.yaml",
                                Description: "Server-specific configuration",
                                Optional:    true,
                                Conditions: []IncludeCondition{
                                        {
                                                Type:     "hostname",
                                                Value:    "server",
                                                Operator: "contains",
                                        },
                                },
                        },
                },
        }

        // Common configuration
        commonConfig := &amp;Config{
                Version:  config.Version,
                Packages: cs.getCommonPackages(config.Packages),
                Files:    cs.getCommonFiles(config.Files),
                DConf:    config.DConf,
        }
        result["hosts/common.yaml"] = commonConfig

        // Workstation-specific
        workstationConfig := &amp;Config{
                Version:  config.Version,
                Packages: cs.getWorkstationPackages(config.Packages),
                Files:    cs.getWorkstationFiles(config.Files),
        }
        result["hosts/workstation-packages.yaml"] = workstationConfig

        result["configr.yaml"] = baseConfig
        return result, nil
}</span>

// splitByFunction splits configuration by functional areas
func (cs *ConfigSplitter) splitByFunction(config *Config) (map[string]*Config, error) <span class="cov0" title="0">{
        result := make(map[string]*Config)

        // Create base config
        baseConfig := &amp;Config{
                Version:         config.Version,
                PackageDefaults: config.PackageDefaults,
                BackupPolicy:    config.BackupPolicy,
                Includes: []IncludeSpec{
                        {Path: "functions/repositories.yaml", Description: "Repository management"},
                        {Path: "functions/system-packages.yaml", Description: "Core system packages"},
                        {Path: "functions/development.yaml", Description: "Development tools"},
                        {Path: "functions/desktop.yaml", Description: "Desktop applications"},
                        {Path: "functions/dotfiles.yaml", Description: "Dotfiles and configuration files"},
                        {Path: "functions/desktop-settings.yaml", Description: "Desktop environment settings"},
                },
        }

        // Split by function
        result["functions/repositories.yaml"] = &amp;Config{Version: config.Version, Repositories: config.Repositories}
        result["functions/system-packages.yaml"] = &amp;Config{Version: config.Version, Packages: cs.getSystemPackages(config.Packages)}
        result["functions/development.yaml"] = &amp;Config{Version: config.Version, Packages: cs.getDevelopmentPackages(config.Packages)}
        result["functions/desktop.yaml"] = &amp;Config{Version: config.Version, Packages: cs.getDesktopPackages(config.Packages)}
        result["functions/dotfiles.yaml"] = &amp;Config{Version: config.Version, Files: config.Files}
        result["functions/desktop-settings.yaml"] = &amp;Config{Version: config.Version, DConf: config.DConf}

        result["configr.yaml"] = baseConfig
        return result, nil
}</span>

// WriteConfigFiles writes the split configuration files to disk
func (cs *ConfigSplitter) WriteConfigFiles(configs map[string]*Config) error <span class="cov0" title="0">{
        for fileName, config := range configs </span><span class="cov0" title="0">{
                filePath := filepath.Join(cs.baseDir, fileName)
                
                // Create directory if needed
                dir := filepath.Dir(filePath)
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %w", dir, err)
                }</span>

                // Marshal config to YAML
                <span class="cov0" title="0">data, err := yaml.Marshal(config)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to marshal config for %s: %w", fileName, err)
                }</span>

                // Write file
                <span class="cov0" title="0">if err := os.WriteFile(filePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write config file %s: %w", filePath, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Helper methods for package filtering

func (cs *ConfigSplitter) filterPackagesByDomain(packages PackageManagement, domain string) PackageManagement <span class="cov0" title="0">{
        // This is a simplified implementation. In a real scenario, you'd have
        // a database or configuration mapping packages to domains.
        domainPackages := map[string][]string{
                "development": {"git", "vim", "code", "nodejs", "python3", "build-essential", "docker.io"},
                "media":       {"vlc", "gimp", "audacity", "ffmpeg", "obs-studio"},
                "system":      {"htop", "tree", "curl", "wget", "unzip", "neofetch"},
        }

        packageList := domainPackages[domain]
        if packageList == nil </span><span class="cov0" title="0">{
                return PackageManagement{}
        }</span>

        <span class="cov0" title="0">result := PackageManagement{}
        
        // Filter APT packages
        for _, pkg := range packages.Apt </span><span class="cov0" title="0">{
                if contains(packageList, pkg.Name) </span><span class="cov0" title="0">{
                        result.Apt = append(result.Apt, pkg)
                }</span>
        }

        // Filter Flatpak packages
        <span class="cov0" title="0">for _, pkg := range packages.Flatpak </span><span class="cov0" title="0">{
                if contains(packageList, pkg.Name) </span><span class="cov0" title="0">{
                        result.Flatpak = append(result.Flatpak, pkg)
                }</span>
        }

        // Filter Snap packages
        <span class="cov0" title="0">for _, pkg := range packages.Snap </span><span class="cov0" title="0">{
                if contains(packageList, pkg.Name) </span><span class="cov0" title="0">{
                        result.Snap = append(result.Snap, pkg)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func (cs *ConfigSplitter) getCommonPackages(packages PackageManagement) PackageManagement <span class="cov0" title="0">{
        // Return essential packages that should be on all systems
        commonPkgs := []string{"git", "curl", "wget", "unzip", "htop", "tree"}
        return cs.filterPackagesByNames(packages, commonPkgs)
}</span>

func (cs *ConfigSplitter) getDevelopmentPackages(packages PackageManagement) PackageManagement <span class="cov0" title="0">{
        devPkgs := []string{"code", "nodejs", "python3", "build-essential", "docker.io", "vim"}
        return cs.filterPackagesByNames(packages, devPkgs)
}</span>

func (cs *ConfigSplitter) getProductionPackages(packages PackageManagement) PackageManagement <span class="cov0" title="0">{
        prodPkgs := []string{"htop", "curl", "wget"}
        return cs.filterPackagesByNames(packages, prodPkgs)
}</span>

func (cs *ConfigSplitter) getSystemPackages(packages PackageManagement) PackageManagement <span class="cov0" title="0">{
        systemPkgs := []string{"htop", "tree", "curl", "wget", "unzip", "neofetch"}
        return cs.filterPackagesByNames(packages, systemPkgs)
}</span>

func (cs *ConfigSplitter) getDesktopPackages(packages PackageManagement) PackageManagement <span class="cov0" title="0">{
        desktopPkgs := []string{"firefox", "thunderbird", "libreoffice", "gimp"}
        return cs.filterPackagesByNames(packages, desktopPkgs)
}</span>

func (cs *ConfigSplitter) getWorkstationPackages(packages PackageManagement) PackageManagement <span class="cov0" title="0">{
        workstationPkgs := []string{"code", "docker.io", "kubernetes", "terraform"}
        return cs.filterPackagesByNames(packages, workstationPkgs)
}</span>

func (cs *ConfigSplitter) filterPackagesByNames(packages PackageManagement, names []string) PackageManagement <span class="cov0" title="0">{
        result := PackageManagement{}

        for _, pkg := range packages.Apt </span><span class="cov0" title="0">{
                if contains(names, pkg.Name) </span><span class="cov0" title="0">{
                        result.Apt = append(result.Apt, pkg)
                }</span>
        }

        <span class="cov0" title="0">for _, pkg := range packages.Flatpak </span><span class="cov0" title="0">{
                if contains(names, pkg.Name) </span><span class="cov0" title="0">{
                        result.Flatpak = append(result.Flatpak, pkg)
                }</span>
        }

        <span class="cov0" title="0">for _, pkg := range packages.Snap </span><span class="cov0" title="0">{
                if contains(names, pkg.Name) </span><span class="cov0" title="0">{
                        result.Snap = append(result.Snap, pkg)
                }</span>
        }

        <span class="cov0" title="0">return result</span>
}

func (cs *ConfigSplitter) getCommonFiles(files map[string]File) map[string]File <span class="cov0" title="0">{
        // Filter files that are common across all hosts
        common := make(map[string]File)
        for name, file := range files </span><span class="cov0" title="0">{
                // Basic heuristic: files in home directory are usually common
                if strings.HasPrefix(file.Destination, "~/") || strings.Contains(name, "bashrc") || strings.Contains(name, "vimrc") </span><span class="cov0" title="0">{
                        common[name] = file
                }</span>
        }
        <span class="cov0" title="0">return common</span>
}

func (cs *ConfigSplitter) getWorkstationFiles(files map[string]File) map[string]File <span class="cov0" title="0">{
        // Filter files specific to workstations
        workstation := make(map[string]File)
        for name, file := range files </span><span class="cov0" title="0">{
                // Basic heuristic: development-related files
                if strings.Contains(name, "code") || strings.Contains(name, "docker") || strings.Contains(file.Source, "dev") </span><span class="cov0" title="0">{
                        workstation[name] = file
                }</span>
        }
        <span class="cov0" title="0">return workstation</span>
}

// GenerateSplitReport generates a report of the split configuration
func (cs *ConfigSplitter) GenerateSplitReport(configs map[string]*Config) string <span class="cov0" title="0">{
        var report strings.Builder
        
        report.WriteString("Configuration Split Report\n")
        report.WriteString("==========================\n\n")

        // Sort file names for consistent output
        var fileNames []string
        for fileName := range configs </span><span class="cov0" title="0">{
                fileNames = append(fileNames, fileName)
        }</span>
        <span class="cov0" title="0">sort.Strings(fileNames)

        for _, fileName := range fileNames </span><span class="cov0" title="0">{
                config := configs[fileName]
                report.WriteString(fmt.Sprintf("File: %s\n", fileName))
                report.WriteString(fmt.Sprintf("  Version: %s\n", config.Version))
                
                if len(config.Includes) &gt; 0 </span><span class="cov0" title="0">{
                        report.WriteString(fmt.Sprintf("  Includes: %d files\n", len(config.Includes)))
                }</span>
                
                <span class="cov0" title="0">aptCount := len(config.Packages.Apt)
                flatpakCount := len(config.Packages.Flatpak)
                snapCount := len(config.Packages.Snap)
                totalPackages := aptCount + flatpakCount + snapCount
                
                if totalPackages &gt; 0 </span><span class="cov0" title="0">{
                        report.WriteString(fmt.Sprintf("  Packages: %d total (APT: %d, Flatpak: %d, Snap: %d)\n", 
                                totalPackages, aptCount, flatpakCount, snapCount))
                }</span>
                
                <span class="cov0" title="0">if len(config.Files) &gt; 0 </span><span class="cov0" title="0">{
                        report.WriteString(fmt.Sprintf("  Files: %d\n", len(config.Files)))
                }</span>
                
                <span class="cov0" title="0">if len(config.DConf.Settings) &gt; 0 </span><span class="cov0" title="0">{
                        report.WriteString(fmt.Sprintf("  DConf Settings: %d\n", len(config.DConf.Settings)))
                }</span>
                
                <span class="cov0" title="0">if len(config.Repositories.Apt) &gt; 0 || len(config.Repositories.Flatpak) &gt; 0 </span><span class="cov0" title="0">{
                        report.WriteString(fmt.Sprintf("  Repositories: APT: %d, Flatpak: %d\n", 
                                len(config.Repositories.Apt), len(config.Repositories.Flatpak)))
                }</span>
                
                <span class="cov0" title="0">report.WriteString("\n")</span>
        }

        <span class="cov0" title="0">return report.String()</span>
}

// Helper function
func contains(slice []string, item string) bool <span class="cov0" title="0">{
        for _, s := range slice </span><span class="cov0" title="0">{
                if s == item </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}</pre>
		
		<pre class="file" id="file21" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "text/template"
        "time"

        "gopkg.in/yaml.v3"
)

// ConfigTemplate represents a configuration template
type ConfigTemplate struct {
        Name        string            `yaml:"name"`
        Description string            `yaml:"description"`
        Version     string            `yaml:"version"`
        Author      string            `yaml:"author"`
        Variables   map[string]string `yaml:"variables"`
        Files       map[string]string `yaml:"files"`
}

// TemplateScaffolder handles configuration template scaffolding
type TemplateScaffolder struct {
        baseDir   string
        templates map[string]*ConfigTemplate
}

// NewTemplateScaffolder creates a new template scaffolder
func NewTemplateScaffolder(baseDir string) *TemplateScaffolder <span class="cov0" title="0">{
        return &amp;TemplateScaffolder{
                baseDir:   baseDir,
                templates: make(map[string]*ConfigTemplate),
        }
}</span>

// RegisterBuiltinTemplates registers built-in configuration templates
func (ts *TemplateScaffolder) RegisterBuiltinTemplates() <span class="cov0" title="0">{
        ts.templates["minimal"] = &amp;ConfigTemplate{
                Name:        "minimal",
                Description: "Minimal configuration with basic packages",
                Version:     "1.0",
                Author:      "configr",
                Variables: map[string]string{
                        "username": "user",
                        "email":    "user@example.com",
                },
                Files: map[string]string{
                        "configr.yaml": minimalTemplate,
                },
        }

        ts.templates["developer"] = &amp;ConfigTemplate{
                Name:        "developer",
                Description: "Developer workstation configuration",
                Version:     "1.0",
                Author:      "configr",
                Variables: map[string]string{
                        "username":     "developer",
                        "email":        "dev@example.com",
                        "github_user":  "username",
                        "editor":       "code",
                        "shell":        "bash",
                },
                Files: map[string]string{
                        "configr.yaml":              developerMainTemplate,
                        "packages/development.yaml": developerPackagesTemplate,
                        "files/dotfiles.yaml":       developerDotfilesTemplate,
                        "repositories.yaml":         developerRepositoriesTemplate,
                },
        }

        ts.templates["server"] = &amp;ConfigTemplate{
                Name:        "server",
                Description: "Server configuration with essential packages",
                Version:     "1.0",
                Author:      "configr",
                Variables: map[string]string{
                        "hostname":    "server",
                        "environment": "production",
                        "admin_user":  "admin",
                },
                Files: map[string]string{
                        "configr.yaml":        serverMainTemplate,
                        "packages/server.yaml": serverPackagesTemplate,
                        "files/system.yaml":   serverFilesTemplate,
                },
        }

        ts.templates["desktop"] = &amp;ConfigTemplate{
                Name:        "desktop",
                Description: "Desktop environment configuration",
                Version:     "1.0",
                Author:      "configr",
                Variables: map[string]string{
                        "username":     "user",
                        "desktop_env":  "gnome",
                        "theme":        "default",
                        "icon_theme":   "default",
                },
                Files: map[string]string{
                        "configr.yaml":           desktopMainTemplate,
                        "packages/desktop.yaml":  desktopPackagesTemplate,
                        "packages/media.yaml":    desktopMediaTemplate,
                        "dconf/gnome.yaml":       desktopDconfTemplate,
                        "files/dotfiles.yaml":    desktopDotfilesTemplate,
                },
        }

        ts.templates["advanced"] = &amp;ConfigTemplate{
                Name:        "advanced",
                Description: "Advanced configuration with includes and conditions",
                Version:     "1.0",
                Author:      "configr",
                Variables: map[string]string{
                        "username":     "user",
                        "environment":  "development",
                        "hostname":     "workstation",
                },
                Files: map[string]string{
                        "configr.yaml":                     advancedMainTemplate,
                        "common/base.yaml":                 advancedBaseTemplate,
                        "environments/development.yaml":    advancedDevelopmentTemplate,
                        "environments/production.yaml":     advancedProductionTemplate,
                        "hosts/workstation.yaml":          advancedWorkstationTemplate,
                        "hosts/laptop.yaml":               advancedLaptopTemplate,
                },
        }
}</span>

// GetTemplate returns a template by name
func (ts *TemplateScaffolder) GetTemplate(name string) (*ConfigTemplate, error) <span class="cov0" title="0">{
        template, exists := ts.templates[name]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("template '%s' not found", name)
        }</span>
        <span class="cov0" title="0">return template, nil</span>
}

// ListTemplates returns a list of available templates
func (ts *TemplateScaffolder) ListTemplates() []string <span class="cov0" title="0">{
        var names []string
        for name := range ts.templates </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>
        <span class="cov0" title="0">return names</span>
}

// ScaffoldProject creates a new project from a template
func (ts *TemplateScaffolder) ScaffoldProject(templateName string, variables map[string]string, outputDir string) error <span class="cov0" title="0">{
        tmpl, err := ts.GetTemplate(templateName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get template: %w", err)
        }</span>

        // Merge template variables with provided variables
        <span class="cov0" title="0">allVars := make(map[string]string)
        for k, v := range tmpl.Variables </span><span class="cov0" title="0">{
                allVars[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range variables </span><span class="cov0" title="0">{
                allVars[k] = v
        }</span>

        // Add system variables
        <span class="cov0" title="0">allVars["timestamp"] = time.Now().Format("2006-01-02 15:04:05")
        allVars["date"] = time.Now().Format("2006-01-02")
        allVars["year"] = time.Now().Format("2006")

        // Create output directory
        if err := os.MkdirAll(outputDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output directory: %w", err)
        }</span>

        // Process each file in the template
        <span class="cov0" title="0">for fileName, content := range tmpl.Files </span><span class="cov0" title="0">{
                if err := ts.createFileFromTemplate(fileName, content, allVars, outputDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create file %s: %w", fileName, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// createFileFromTemplate creates a file from a template
func (ts *TemplateScaffolder) createFileFromTemplate(fileName, templateContent string, variables map[string]string, outputDir string) error <span class="cov0" title="0">{
        // Parse template
        tmpl, err := template.New(fileName).Parse(templateContent)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse template: %w", err)
        }</span>

        // Create file path
        <span class="cov0" title="0">filePath := filepath.Join(outputDir, fileName)
        fileDir := filepath.Dir(filePath)

        // Create directory if needed
        if err := os.MkdirAll(fileDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create directory %s: %w", fileDir, err)
        }</span>

        // Create file
        <span class="cov0" title="0">file, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file %s: %w", filePath, err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Execute template
        if err := tmpl.Execute(file, variables); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to execute template: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateTemplate validates a template configuration
func (ts *TemplateScaffolder) ValidateTemplate(tmpl *ConfigTemplate) error <span class="cov0" title="0">{
        if tmpl.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("template name is required")
        }</span>

        <span class="cov0" title="0">if tmpl.Version == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("template version is required")
        }</span>

        <span class="cov0" title="0">if len(tmpl.Files) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("template must have at least one file")
        }</span>

        // Validate that template files are valid YAML templates
        <span class="cov0" title="0">for fileName, content := range tmpl.Files </span><span class="cov0" title="0">{
                if strings.HasSuffix(fileName, ".yaml") || strings.HasSuffix(fileName, ".yml") </span><span class="cov0" title="0">{
                        // Try to parse the template
                        tmplObj, err := template.New(fileName).Parse(content)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("invalid template syntax in %s: %w", fileName, err)
                        }</span>

                        // Try to execute with sample variables
                        <span class="cov0" title="0">sampleVars := make(map[string]string)
                        for k, v := range tmpl.Variables </span><span class="cov0" title="0">{
                                sampleVars[k] = v
                        }</span>

                        <span class="cov0" title="0">var buf strings.Builder
                        if err := tmplObj.Execute(&amp;buf, sampleVars); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("template execution failed for %s: %w", fileName, err)
                        }</span>

                        // Try to parse as YAML
                        <span class="cov0" title="0">var testConfig interface{}
                        if err := yaml.Unmarshal([]byte(buf.String()), &amp;testConfig); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("template %s does not produce valid YAML: %w", fileName, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// Template definitions

const minimalTemplate = `version: "1.0"

packages:
  apt:
    - git
    - curl
    - htop
    - tree

files:
  bashrc:
    source: "dotfiles/.bashrc"
    destination: "~/.bashrc"
    backup: true

dconf:
  settings:
    "/org/gnome/desktop/interface/clock-show-seconds": "true"
`

const developerMainTemplate = `version: "1.0"

# Developer workstation configuration
# Generated on {{.timestamp}} for {{.username}}

includes:
  - path: "repositories.yaml"
    description: "Development repositories"
  - path: "packages/development.yaml"
    description: "Development packages and tools"
  - path: "files/dotfiles.yaml"
    description: "Developer dotfiles and configurations"

package_defaults:
  apt: ["-y", "--no-install-recommends"]
  flatpak: ["--user", "--assumeyes"]

backup_policy:
  enabled: true
  retention_days: 30
  backup_location: "~/.config/configr/backups"
`

const developerPackagesTemplate = `version: "1.0"

packages:
  apt:
    - git
    - {{.editor}}
    - curl
    - wget
    - htop
    - tree
    - neofetch
    - build-essential
    - nodejs
    - npm
    - python3
    - python3-pip
    - docker.io
    - docker-compose
  
  flatpak:
    - com.visualstudio.code
    - org.mozilla.Firefox
  
  snap:
    - discord
    - slack
`

const developerDotfilesTemplate = `version: "1.0"

files:
  bashrc:
    source: "dotfiles/.bashrc"
    destination: "~/.bashrc"
    backup: true
    interactive: true

  vimrc:
    source: "dotfiles/.vimrc"
    destination: "~/.vimrc"
    backup: true

  gitconfig:
    source: "dotfiles/.gitconfig"
    destination: "~/.gitconfig"
    backup: true

  ssh_config:
    source: "dotfiles/.ssh/config"
    destination: "~/.ssh/config"
    mode: "600"
    backup: true
`

const developerRepositoriesTemplate = `version: "1.0"

repositories:
  apt:
    docker:
      uri: "deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable"
      key: "https://download.docker.com/linux/ubuntu/gpg"
    
    nodejs:
      uri: "deb https://deb.nodesource.com/node_16.x focal main"
      key: "https://deb.nodesource.com/gpgkey/nodesource.gpg.key"

  flatpak:
    flathub:
      url: "https://flathub.org/repo/flathub.flatpakrepo"
      user: false
`

const serverMainTemplate = `version: "1.0"

# Server configuration for {{.hostname}}
# Environment: {{.environment}}
# Generated on {{.timestamp}}

includes:
  - path: "packages/server.yaml"
    description: "Server packages"
  - path: "files/system.yaml"
    description: "System configuration files"

package_defaults:
  apt: ["-y", "--no-install-recommends"]

backup_policy:
  enabled: true
  retention_days: 90
  backup_location: "/var/backups/configr"
`

const serverPackagesTemplate = `version: "1.0"

packages:
  apt:
    - htop
    - tree
    - curl
    - wget
    - unzip
    - git
    - openssh-server
    - ufw
    - fail2ban
    - logrotate
    - rsync
    - cron
`

const serverFilesTemplate = `version: "1.0"

files:
  sshd_config:
    source: "system/sshd_config"
    destination: "/etc/ssh/sshd_config"
    owner: "root"
    group: "root"
    mode: "644"
    backup: true

  ufw_rules:
    source: "system/ufw.rules"
    destination: "/etc/ufw/user.rules"
    owner: "root"
    group: "root"
    mode: "640"
    backup: true
`

const desktopMainTemplate = `version: "1.0"

# Desktop configuration for {{.username}}
# Desktop Environment: {{.desktop_env}}
# Generated on {{.timestamp}}

includes:
  - path: "packages/desktop.yaml"
    description: "Desktop applications"
  - path: "packages/media.yaml"
    description: "Media applications"
  - path: "dconf/gnome.yaml"
    description: "GNOME desktop settings"
    conditions:
      - type: "env"
        value: "DESKTOP_SESSION"
        operator: "contains"
  - path: "files/dotfiles.yaml"
    description: "Desktop dotfiles"

package_defaults:
  flatpak: ["--user", "--assumeyes"]
`

const desktopPackagesTemplate = `version: "1.0"

packages:
  apt:
    - firefox
    - thunderbird
    - libreoffice
    - gimp
    - vlc
    - htop
    - tree
    - curl
    - wget
    - git

  flatpak:
    - org.mozilla.Firefox
    - org.mozilla.Thunderbird
    - org.libreoffice.LibreOffice
    - org.gimp.GIMP

  snap:
    - discord
    - slack
    - spotify
`

const desktopMediaTemplate = `version: "1.0"

packages:
  apt:
    - vlc
    - audacity
    - ffmpeg
    - imagemagick

  flatpak:
    - org.videolan.VLC
    - org.audacityteam.Audacity
    - org.blender.Blender

  snap:
    - obs-studio
`

const desktopDconfTemplate = `version: "1.0"

dconf:
  settings:
    # Desktop interface settings
    "/org/gnome/desktop/interface/clock-show-seconds": "true"
    "/org/gnome/desktop/interface/show-battery-percentage": "true"
    "/org/gnome/desktop/interface/gtk-theme": "'{{.theme}}'"
    "/org/gnome/desktop/interface/icon-theme": "'{{.icon_theme}}'"
    
    # Window manager settings
    "/org/gnome/desktop/wm/preferences/button-layout": "'close,minimize,maximize:'"
    "/org/gnome/desktop/wm/preferences/focus-mode": "'click'"
    
    # Keyboard shortcuts
    "/org/gnome/settings-daemon/plugins/media-keys/terminal": "['&lt;Super&gt;t']"
    "/org/gnome/settings-daemon/plugins/media-keys/home": "['&lt;Super&gt;e']"
`

const desktopDotfilesTemplate = `version: "1.0"

files:
  bashrc:
    source: "dotfiles/.bashrc"
    destination: "~/.bashrc"
    backup: true

  profile:
    source: "dotfiles/.profile"
    destination: "~/.profile"
    backup: true

  gitconfig:
    source: "dotfiles/.gitconfig"
    destination: "~/.gitconfig"
    backup: true
`

const advancedMainTemplate = `version: "1.0"

# Advanced configuration with conditional includes
# User: {{.username}}
# Environment: {{.environment}}
# Hostname: {{.hostname}}
# Generated on {{.timestamp}}

includes:
  # Base configuration (always loaded)
  - path: "common/base.yaml"
    description: "Base configuration for all systems"

  # Environment-specific configuration
  - path: "environments/{{.environment}}.yaml"
    description: "{{.environment}} environment configuration"
    optional: true
    conditions:
      - type: "env"
        value: "ENVIRONMENT={{.environment}}"
        operator: "equals"

  # Host-specific configuration
  - path: "hosts/workstation.yaml"
    description: "Workstation-specific configuration"
    optional: true
    conditions:
      - type: "hostname"
        value: "workstation"
        operator: "contains"

  - path: "hosts/laptop.yaml"
    description: "Laptop-specific configuration"
    optional: true
    conditions:
      - type: "hostname"
        value: "laptop"
        operator: "contains"

  # OS-specific configuration
  - path: "os-specific/*.yaml"
    description: "OS-specific configuration files"
    optional: true
    conditions:
      - type: "os"
        value: "linux"
        operator: "equals"

package_defaults:
  apt: ["-y", "--no-install-recommends"]
  flatpak: ["--user", "--assumeyes"]

backup_policy:
  enabled: true
  retention_days: 30
  backup_location: "~/.config/configr/backups"
`

const advancedBaseTemplate = `version: "1.0"

# Base configuration included by all systems

packages:
  apt:
    - git
    - curl
    - wget
    - htop
    - tree
    - unzip

files:
  bashrc:
    source: "dotfiles/.bashrc"
    destination: "~/.bashrc"
    backup: true

  gitconfig:
    source: "dotfiles/.gitconfig"
    destination: "~/.gitconfig"
    backup: true
`

const advancedDevelopmentTemplate = `version: "1.0"

# Development environment specific configuration

packages:
  apt:
    - build-essential
    - nodejs
    - npm
    - python3
    - python3-pip
    - docker.io
    - docker-compose

  flatpak:
    - com.visualstudio.code

repositories:
  apt:
    docker:
      uri: "deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable"
      key: "https://download.docker.com/linux/ubuntu/gpg"
`

const advancedProductionTemplate = `version: "1.0"

# Production environment specific configuration

packages:
  apt:
    - openssh-server
    - ufw
    - fail2ban
    - logrotate

files:
  sshd_config:
    source: "system/sshd_config"
    destination: "/etc/ssh/sshd_config"
    owner: "root"
    group: "root"
    mode: "644"
    backup: true
`

const advancedWorkstationTemplate = `version: "1.0"

# Workstation-specific configuration

packages:
  apt:
    - code
    - docker.io
    - kubernetes-cli

  snap:
    - discord
    - slack

dconf:
  settings:
    "/org/gnome/desktop/interface/clock-show-seconds": "true"
    "/org/gnome/settings-daemon/plugins/media-keys/terminal": "['&lt;Super&gt;t']"
`

const advancedLaptopTemplate = `version: "1.0"

# Laptop-specific configuration

packages:
  apt:
    - tlp
    - powertop
    - acpi

files:
  tlp_config:
    source: "system/tlp.conf"
    destination: "/etc/tlp.conf"
    owner: "root"
    group: "root"
    mode: "644"
    backup: true

dconf:
  settings:
    "/org/gnome/settings-daemon/plugins/power/sleep-inactive-ac-timeout": "3600"
    "/org/gnome/settings-daemon/plugins/power/sleep-inactive-battery-timeout": "1800"
`</pre>
		
		<pre class="file" id="file22" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
)

// ValidationError represents a single validation error with Rust-style details
type ValidationError struct {
        Type        string // "error", "warning"
        Title       string // Short error title
        File        string // File path where error occurred
        Line        int    // Line number (if available)
        Column      int    // Column number (if available)
        Field       string // YAML field path (e.g., "files.vimrc.source")
        Value       string // The problematic value
        Message     string // Main error message
        Help        string // How to fix it
        Note        string // Additional context
        Suggestion  string // Suggested fix
        Highlighted string // The problematic part to highlight
}

// ValidationResult contains all validation errors and warnings
type ValidationResult struct {
        Errors   []ValidationError
        Warnings []ValidationError
        Valid    bool
}

// ValidationFailedError is returned when configuration validation fails
type ValidationFailedError struct {
        Result *ValidationResult
}

func (e *ValidationFailedError) Error() string <span class="cov0" title="0">{
        return FormatValidationResultSimple(e.Result) + FormatQuickFixSimple(e.Result)
}</span>

// FormatValidationResultEnhanced provides enhanced Rust-style error formatting
func FormatValidationResultEnhanced(result *ValidationResult) string <span class="cov0" title="0">{
        formatter := NewEnhancedFormatter()
        return formatter.FormatValidationResultEnhanced(result)
}</span>

// FormatQuickFixEnhanced provides enhanced quick fix suggestions
func FormatQuickFixEnhanced(result *ValidationResult) string <span class="cov0" title="0">{
        formatter := NewEnhancedFormatter()
        return formatter.FormatQuickFixEnhanced(result)
}</span>

// Add adds a validation error to the result
func (vr *ValidationResult) Add(err ValidationError) <span class="cov8" title="1">{
        if err.Type == "warning" </span><span class="cov8" title="1">{
                vr.Warnings = append(vr.Warnings, err)
        }</span> else<span class="cov8" title="1"> {
                vr.Errors = append(vr.Errors, err)
                vr.Valid = false
        }</span>
}

// HasErrors returns true if there are validation errors
func (vr *ValidationResult) HasErrors() bool <span class="cov8" title="1">{
        return len(vr.Errors) &gt; 0
}</span>

// Validate performs comprehensive validation on the configuration
func Validate(config *Config, configPath string) *ValidationResult <span class="cov8" title="1">{
        result := &amp;ValidationResult{Valid: true}
        
        // Parse with position information for better error reporting
        configWithPos, err := ParseConfigWithPosition(configPath)
        if err != nil </span><span class="cov8" title="1">{
                // If we can't parse with positions, fall back to basic validation
                validateVersion(config, result, nil, configPath)
                validateIncludes(config, result, nil, configPath)
                validateRepositories(config, result, nil, configPath)
                validatePackages(config, result, nil, configPath)
                validateFiles(config, configPath, result, nil, configPath)
                validateDConf(config, result, nil, configPath)
                return result
        }</span>
        
        // Basic structure validation with position information
        <span class="cov0" title="0">validateVersion(config, result, configWithPos, configPath)
        validateIncludes(config, result, configWithPos, configPath)
        validateRepositories(config, result, configWithPos, configPath)
        validatePackages(config, result, configWithPos, configPath)
        validateFiles(config, configPath, result, configWithPos, configPath)
        validateDConf(config, result, configWithPos, configPath)
        
        return result</span>
}

// validateVersion checks the version field
func validateVersion(config *Config, result *ValidationResult, configPos *ConfigWithPosition, configPath string) <span class="cov8" title="1">{
        if config.Version == "" </span><span class="cov8" title="1">{
                line, column := 0, 0
                if configPos != nil </span><span class="cov0" title="0">{
                        line, column = configPos.FindFieldPosition("version")
                }</span>
                
                <span class="cov8" title="1">result.Add(ValidationError{
                        Type:    "error",
                        Title:   "missing version field",
                        File:    configPath,
                        Line:    line,
                        Column:  column,
                        Field:   "version",
                        Message: "configuration version is required",
                        Help:    "add 'version: \"1.0\"' to your configuration",
                        Note:    "version helps ensure compatibility with configr updates",
                })
                return</span>
        }
        
        // Simple version format check
        <span class="cov8" title="1">matched, _ := regexp.MatchString(`^\d+\.\d+(\.\d+)?$`, config.Version)
        if !matched </span><span class="cov8" title="1">{
                line, column := 0, 0
                if configPos != nil </span><span class="cov0" title="0">{
                        line, column = configPos.FindFieldPosition("version")
                }</span>
                
                <span class="cov8" title="1">result.Add(ValidationError{
                        Type:       "error",
                        Title:      "invalid version format",
                        File:       configPath,
                        Line:       line,
                        Column:     column,
                        Field:      "version",
                        Value:      config.Version,
                        Message:    "version must be in semantic version format",
                        Help:       "use format like '1.0' or '1.0.0'",
                        Suggestion: "version: \"1.0\"",
                })</span>
        }
}

// validateIncludes checks include configurations
func validateIncludes(config *Config, result *ValidationResult, configPos *ConfigWithPosition, configPath string) <span class="cov8" title="1">{
        if len(config.Includes) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">loader := NewAdvancedLoader()
        baseDir := filepath.Dir(configPath)

        for i, includeSpec := range config.Includes </span><span class="cov8" title="1">{
                field := fmt.Sprintf("includes[%d]", i)
                line, column := 0, 0
                if configPos != nil </span><span class="cov0" title="0">{
                        line, column = configPos.FindFieldPosition(field)
                }</span>

                // Validate the include spec structure
                <span class="cov8" title="1">if err := loader.ValidateIncludeSpec(includeSpec); err != nil </span><span class="cov0" title="0">{
                        result.Add(ValidationError{
                                Type:    "error",
                                Title:   "invalid include specification",
                                File:    configPath,
                                Line:    line,
                                Column:  column,
                                Field:   field,
                                Message: err.Error(),
                                Help:    "fix the include specification according to the schema",
                                Note:    "includes require 'path' to be specified",
                        })
                        continue</span>
                }

                // Validate conditions
                <span class="cov8" title="1">for j, condition := range includeSpec.Conditions </span><span class="cov0" title="0">{
                        conditionField := fmt.Sprintf("%s.conditions[%d]", field, j)
                        if err := loader.validateCondition(condition); err != nil </span><span class="cov0" title="0">{
                                result.Add(ValidationError{
                                        Type:    "error",
                                        Title:   "invalid include condition",
                                        File:    configPath,
                                        Line:    line,
                                        Column:  column,
                                        Field:   conditionField,
                                        Message: err.Error(),
                                        Help:    "fix the condition specification",
                                        Note:    "valid condition types: os, hostname, env, file_exists, dir_exists",
                                })
                        }</span>
                }

                // Check for potentially dangerous patterns
                <span class="cov8" title="1">if strings.Contains(includeSpec.Path, "..") </span><span class="cov0" title="0">{
                        result.Add(ValidationError{
                                Type:    "warning",
                                Title:   "potentially unsafe include path",
                                File:    configPath,
                                Line:    line,
                                Column:  column,
                                Field:   fmt.Sprintf("%s.path", field),
                                Value:   includeSpec.Path,
                                Message: "include path contains '..' which may access files outside the configuration directory",
                                Help:    "use relative paths within the configuration directory",
                                Note:    "while technically valid, this pattern can make configurations less portable",
                        })
                }</span>

                // Test glob patterns for syntax validity
                <span class="cov8" title="1">if strings.ContainsAny(includeSpec.Path, "*?[") </span><span class="cov0" title="0">{
                        pattern := filepath.Join(baseDir, includeSpec.Path)
                        if _, err := filepath.Glob(pattern); err != nil </span><span class="cov0" title="0">{
                                result.Add(ValidationError{
                                        Type:    "error",
                                        Title:   "invalid glob pattern",
                                        File:    configPath,
                                        Line:    line,
                                        Column:  column,
                                        Field:   fmt.Sprintf("%s.path", field),
                                        Value:   includeSpec.Path,
                                        Message: fmt.Sprintf("invalid glob pattern: %v", err),
                                        Help:    "use valid glob syntax with *, ?, and [] patterns",
                                        Note:    "glob patterns are relative to the configuration file directory",
                                })
                        }</span>
                }

                // Validate paths (non-optional includes should exist)
                <span class="cov8" title="1">if !includeSpec.Optional &amp;&amp; !strings.ContainsAny(includeSpec.Path, "*?[") </span><span class="cov8" title="1">{
                        fullPath := filepath.Join(baseDir, includeSpec.Path)
                        if _, err := os.Stat(fullPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                                // Try with .yaml extension
                                if filepath.Ext(fullPath) == "" </span><span class="cov8" title="1">{
                                        yamlPath := fullPath + ".yaml"
                                        if _, err := os.Stat(yamlPath); err != nil </span><span class="cov8" title="1">{
                                                result.Add(ValidationError{
                                                        Type:    "error",
                                                        Title:   "include file not found",
                                                        File:    configPath,
                                                        Line:    line,
                                                        Column:  column,
                                                        Field:   fmt.Sprintf("%s.path", field),
                                                        Value:   includeSpec.Path,
                                                        Message: fmt.Sprintf("include file does not exist: %s", fullPath),
                                                        Help:    "ensure the include file exists, create it, or mark as optional",
                                                        Note:    "set 'optional: true' if the file may not exist",
                                                })
                                        }</span>
                                }
                        }
                }
        }
}

// validateRepositories checks repository configurations
func validateRepositories(config *Config, result *ValidationResult, configPos *ConfigWithPosition, configPath string) <span class="cov8" title="1">{
        // Validate APT repositories
        validateAptRepositories(config.Repositories.Apt, result, configPos, configPath)
        
        // Validate Flatpak repositories
        validateFlatpakRepositories(config.Repositories.Flatpak, result, configPos, configPath)
}</span>

// validateAptRepositories validates APT repository configurations
func validateAptRepositories(repos []AptRepository, result *ValidationResult, configPos *ConfigWithPosition, configPath string) <span class="cov8" title="1">{
        for _, repo := range repos </span><span class="cov8" title="1">{
                fieldPrefix := fmt.Sprintf("repositories.apt.%s", repo.Name)
                
                // Validate that either PPA or URI is provided, but not both
                hasPPA := repo.PPA != ""
                hasURI := repo.URI != ""
                
                if !hasPPA &amp;&amp; !hasURI </span><span class="cov8" title="1">{
                        result.Add(ValidationError{
                                Type:    "error",
                                Title:   "missing repository configuration",
                                Field:   fieldPrefix,
                                Message: "repository must specify either 'ppa' or 'uri'",
                                Help:    "add 'ppa: \"user/repo\"' for PPA or 'uri: \"deb [arch=amd64] https://...\"' for custom repository",
                                Note:    "PPA format: 'user/repo' (e.g., 'deadsnakes/ppa')",
                        })
                        continue</span>
                }
                
                <span class="cov8" title="1">if hasPPA &amp;&amp; hasURI </span><span class="cov8" title="1">{
                        result.Add(ValidationError{
                                Type:    "error",
                                Title:   "conflicting repository configuration",
                                Field:   fieldPrefix,
                                Message: "repository cannot specify both 'ppa' and 'uri'",
                                Help:    "use 'ppa' for Ubuntu PPAs or 'uri' for custom repositories",
                                Note:    "choose one method based on your repository type",
                        })
                        continue</span>
                }
                
                // Validate PPA format
                <span class="cov8" title="1">if hasPPA </span><span class="cov8" title="1">{
                        if !isValidPPAFormat(repo.PPA) </span><span class="cov8" title="1">{
                                result.Add(ValidationError{
                                        Type:       "error",
                                        Title:      "invalid PPA format",
                                        Field:      fieldPrefix + ".ppa",
                                        Value:      repo.PPA,
                                        Message:    "PPA must be in 'user/repo' format",
                                        Help:       "use format like 'deadsnakes/ppa' or 'ubuntu-toolchain-r/test'",
                                        Suggestion: suggestPPAFormat(repo.PPA),
                                })
                        }</span>
                }
                
                // Validate URI format
                <span class="cov8" title="1">if hasURI </span><span class="cov8" title="1">{
                        if !isValidAPTRepositoryURI(repo.URI) </span><span class="cov8" title="1">{
                                result.Add(ValidationError{
                                        Type:    "error",
                                        Title:   "invalid repository URI",
                                        Field:   fieldPrefix + ".uri",
                                        Value:   repo.URI,
                                        Message: "repository URI format is invalid",
                                        Help:    "use format: 'deb [arch=amd64] https://example.com/repo stable main'",
                                        Note:    "URI should start with 'deb' or 'deb-src'",
                                })
                        }</span>
                }
                
                // Validate GPG key if provided
                <span class="cov8" title="1">if repo.Key != "" </span><span class="cov8" title="1">{
                        if !isValidGPGKeyReference(repo.Key) </span><span class="cov8" title="1">{
                                result.Add(ValidationError{
                                        Type:    "error",
                                        Title:   "invalid GPG key reference",
                                        Field:   fieldPrefix + ".key",
                                        Value:   repo.Key,
                                        Message: "GPG key must be a URL or keyserver key ID",
                                        Help:    "use a HTTPS URL to .gpg file or keyserver key ID",
                                        Note:    "example: 'https://example.com/key.gpg' or '0x1234567890ABCDEF'",
                                })
                        }</span>
                }
        }
}

// validateFlatpakRepositories validates Flatpak repository configurations
func validateFlatpakRepositories(repos []FlatpakRepository, result *ValidationResult, configPos *ConfigWithPosition, configPath string) <span class="cov8" title="1">{
        for _, repo := range repos </span><span class="cov8" title="1">{
                fieldPrefix := fmt.Sprintf("repositories.flatpak.%s", repo.Name)
                
                // Validate required URL field
                if repo.URL == "" </span><span class="cov8" title="1">{
                        result.Add(ValidationError{
                                Type:    "error",
                                Title:   "missing repository URL",
                                Field:   fieldPrefix + ".url",
                                Message: "Flatpak repository URL is required",
                                Help:    "specify the .flatpakrepo URL or repository location",
                                Note:    "example: 'https://flathub.org/repo/flathub.flatpakrepo'",
                        })
                        continue</span>
                }
                
                // Validate URL format
                <span class="cov8" title="1">if !isValidFlatpakRepositoryURL(repo.URL) </span><span class="cov8" title="1">{
                        result.Add(ValidationError{
                                Type:    "error",
                                Title:   "invalid repository URL",
                                Field:   fieldPrefix + ".url",
                                Value:   repo.URL,
                                Message: "Flatpak repository URL format is invalid",
                                Help:    "use HTTPS URL to .flatpakrepo file or repository",
                                Note:    "URLs should use HTTPS for security",
                        })
                }</span>
                
                // Validate repository name
                <span class="cov8" title="1">if !isValidFlatpakRemoteName(repo.Name) </span><span class="cov8" title="1">{
                        result.Add(ValidationError{
                                Type:       "error",
                                Title:      "invalid remote name",
                                Field:      fieldPrefix,
                                Value:      repo.Name,
                                Message:    "Flatpak remote name contains invalid characters",
                                Help:       "use only letters, numbers, hyphens, and underscores",
                                Suggestion: suggestFlatpakRemoteName(repo.Name),
                        })
                }</span>
        }
}

// validatePackages checks package manager configurations
func validatePackages(config *Config, result *ValidationResult, configPos *ConfigWithPosition, configPath string) <span class="cov8" title="1">{
        // Check for duplicate packages across managers
        allPackages := make(map[string]string) // package -&gt; manager
        
        // Validate apt packages
        validatePackageEntries(config.Packages.Apt, "apt", allPackages, result, configPos, configPath)
        
        // Validate flatpak packages
        validatePackageEntries(config.Packages.Flatpak, "flatpak", allPackages, result, configPos, configPath)
        
        // Validate snap packages
        validatePackageEntries(config.Packages.Snap, "snap", allPackages, result, configPos, configPath)
        
        // Validate package_defaults if present
        if config.PackageDefaults != nil </span><span class="cov8" title="1">{
                validatePackageDefaults(config.PackageDefaults, result, configPos, configPath)
        }</span>
}

// validateFiles checks file configurations
func validateFiles(config *Config, configPath string, result *ValidationResult, configPos *ConfigWithPosition, configFile string) <span class="cov8" title="1">{
        configDir := filepath.Dir(configPath)
        
        for name, file := range config.Files </span><span class="cov8" title="1">{
                fieldPrefix := fmt.Sprintf("files.%s", name)
                
                // Validate required fields
                if file.Source == "" </span><span class="cov8" title="1">{
                        result.Add(ValidationError{
                                Type:    "error",
                                Title:   "missing source path",
                                Field:   fieldPrefix + ".source",
                                Message: "source file path is required",
                                Help:    "specify the path to your source file",
                                Note:    "source paths are relative to your config file",
                        })
                        continue</span>
                }
                
                <span class="cov8" title="1">if file.Destination == "" </span><span class="cov8" title="1">{
                        result.Add(ValidationError{
                                Type:    "error",
                                Title:   "missing destination path",
                                Field:   fieldPrefix + ".destination",
                                Message: "destination path is required", 
                                Help:    "specify where the file should be placed",
                                Note:    "use ~ for home directory (e.g., ~/.vimrc)",
                        })
                        continue</span>
                }
                
                // Check if source file exists
                <span class="cov8" title="1">sourcePath := file.Source
                if !filepath.IsAbs(sourcePath) </span><span class="cov8" title="1">{
                        sourcePath = filepath.Join(configDir, file.Source)
                }</span>
                
                <span class="cov8" title="1">if _, err := os.Stat(sourcePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                        // Try to suggest alternatives
                        suggestion := suggestAlternativeFile(sourcePath)
                        
                        result.Add(ValidationError{
                                Type:       "error",
                                Title:      "source file not found",
                                Field:      fieldPrefix + ".source",
                                Value:      file.Source,
                                Message:    "source file does not exist",
                                Help:       "create the file or check the path",
                                Note:       fmt.Sprintf("looked for: %s", sourcePath),
                                Suggestion: suggestion,
                        })
                }</span>
                
                // Validate file mode if provided
                <span class="cov8" title="1">if file.Mode != "" </span><span class="cov8" title="1">{
                        if !isValidFileMode(file.Mode) </span><span class="cov8" title="1">{
                                result.Add(ValidationError{
                                        Type:       "error",
                                        Title:      "invalid file mode",
                                        Field:      fieldPrefix + ".mode",
                                        Value:      file.Mode,
                                        Message:    "file mode must be valid octal (e.g., '644', '755')",
                                        Help:       "use '644' for regular files, '755' for executables",
                                        Suggestion: "mode: \"644\"",
                                })
                        }</span> else<span class="cov8" title="1"> if isOverlyPermissive(file.Mode) </span><span class="cov0" title="0">{
                                result.Add(ValidationError{
                                        Type:    "warning",
                                        Title:   "overly permissive mode",
                                        Field:   fieldPrefix + ".mode",
                                        Value:   file.Mode,
                                        Message: "file mode allows write access for others",
                                        Help:    "consider using '644' for better security",
                                        Note:    "mode '777' or '666' can be security risks",
                                })
                        }</span>
                }
                
                // Validate destination path
                <span class="cov8" title="1">if strings.Contains(file.Destination, "..") </span><span class="cov8" title="1">{
                        result.Add(ValidationError{
                                Type:    "error",
                                Title:   "unsafe destination path",
                                Field:   fieldPrefix + ".destination",
                                Value:   file.Destination,
                                Message: "destination path contains '..' which is not allowed",
                                Help:    "use absolute paths or paths relative to home (~)",
                                Note:    "this prevents accidental file overwrites outside intended directories",
                        })
                }</span>
        }
}

// validateDConf checks dconf settings
func validateDConf(config *Config, result *ValidationResult, configPos *ConfigWithPosition, configPath string) <span class="cov8" title="1">{
        for path, value := range config.DConf.Settings </span><span class="cov8" title="1">{
                fieldPrefix := fmt.Sprintf("dconf.settings[\"%s\"]", path)
                
                // Validate dconf path format
                if !strings.HasPrefix(path, "/") </span><span class="cov8" title="1">{
                        result.Add(ValidationError{
                                Type:       "error",
                                Title:      "invalid dconf path",
                                Field:      fieldPrefix,
                                Value:      path,
                                Message:    "dconf path must start with '/'",
                                Help:       "prefix the path with '/'",
                                Suggestion: fmt.Sprintf("\"%s\": \"%s\"", "/"+path, value),
                        })
                }</span>
                
                // Check for common dconf path mistakes
                <span class="cov8" title="1">if strings.Contains(path, "//") </span><span class="cov8" title="1">{
                        result.Add(ValidationError{
                                Type:    "error",
                                Title:   "malformed dconf path",
                                Field:   fieldPrefix,
                                Value:   path,
                                Message: "dconf path contains double slashes",
                                Help:    "use single slashes to separate path segments",
                        })
                }</span>
        }
}

// Helper functions
func isValidPackageName(name string) bool <span class="cov0" title="0">{
        matched, _ := regexp.MatchString(`^[a-z0-9][a-z0-9\-\.\+]*$`, name)
        return matched
}</span>

func sanitizePackageName(name string) string <span class="cov0" title="0">{
        return strings.ToLower(regexp.MustCompile(`[^a-z0-9\-\.]`).ReplaceAllString(name, "-"))
}</span>

// isValidPackageNameForManager validates package names based on the specific package manager
func isValidPackageNameForManager(name, manager string) bool <span class="cov8" title="1">{
        switch manager </span>{
        case "apt":<span class="cov8" title="1">
                // Check if it's a local .deb file
                if strings.HasSuffix(name, ".deb") </span><span class="cov8" title="1">{
                        // If it ends with .deb, it must be a valid file path
                        return isValidDebFilePath(name)
                }</span>
                // APT package names: lowercase, numbers, hyphens, dots, plus signs
                <span class="cov8" title="1">matched, _ := regexp.MatchString(`^[a-z0-9][a-z0-9\-\.\+]*$`, name)
                return matched</span>
        case "flatpak":<span class="cov8" title="1">
                // Flatpak app IDs: reverse domain notation with dots, letters, numbers
                matched, _ := regexp.MatchString(`^[a-zA-Z0-9][a-zA-Z0-9\-\._]*[a-zA-Z0-9]$`, name)
                return matched</span>
        case "snap":<span class="cov8" title="1">
                // Snap package names: lowercase, numbers, hyphens
                matched, _ := regexp.MatchString(`^[a-z0-9][a-z0-9\-]*$`, name)
                return matched</span>
        default:<span class="cov0" title="0">
                // Fallback to original validation
                return isValidPackageName(name)</span>
        }
}

// getPackageNameValidationMessage returns validation message for specific package manager
func getPackageNameValidationMessage(manager string) string <span class="cov8" title="1">{
        switch manager </span>{
        case "apt":<span class="cov8" title="1">
                return "APT package name or .deb file path contains invalid characters"</span>
        case "flatpak":<span class="cov0" title="0">
                return "Flatpak app ID contains invalid characters"</span>
        case "snap":<span class="cov8" title="1">
                return "Snap package name contains invalid characters"</span>
        default:<span class="cov0" title="0">
                return "package name contains invalid characters"</span>
        }
}

// getPackageNameValidationHelp returns validation help for specific package manager
func getPackageNameValidationHelp(manager string) string <span class="cov8" title="1">{
        switch manager </span>{
        case "apt":<span class="cov8" title="1">
                return "use only lowercase letters, numbers, hyphens, dots, and plus signs"</span>
        case "flatpak":<span class="cov0" title="0">
                return "use reverse domain notation like org.app.Name or com.company.App"</span>
        case "snap":<span class="cov8" title="1">
                return "use only lowercase letters, numbers, and hyphens"</span>
        default:<span class="cov0" title="0">
                return "use only lowercase letters, numbers, hyphens, and dots"</span>
        }
}

// sanitizePackageNameForManager sanitizes package names based on the specific package manager
func sanitizePackageNameForManager(name, manager string) string <span class="cov8" title="1">{
        switch manager </span>{
        case "apt":<span class="cov8" title="1">
                return strings.ToLower(regexp.MustCompile(`[^a-z0-9\-\.\+]`).ReplaceAllString(name, "-"))</span>
        case "flatpak":<span class="cov0" title="0">
                // For flatpak, preserve case and dots, replace invalid chars with dots
                return regexp.MustCompile(`[^a-zA-Z0-9\-\._]`).ReplaceAllString(name, ".")</span>
        case "snap":<span class="cov8" title="1">
                return strings.ToLower(regexp.MustCompile(`[^a-z0-9\-]`).ReplaceAllString(name, "-"))</span>
        default:<span class="cov0" title="0">
                return sanitizePackageName(name)</span>
        }
}

// validatePackageEntries validates a list of PackageEntry instances
func validatePackageEntries(packages []PackageEntry, manager string, allPackages map[string]string, result *ValidationResult, configPos *ConfigWithPosition, configPath string) <span class="cov8" title="1">{
        for _, pkg := range packages </span><span class="cov8" title="1">{
                // Validate package name
                if pkg.Name == "" </span><span class="cov8" title="1">{
                        result.Add(ValidationError{
                                Type:    "error",
                                Title:   "empty package name",
                                Field:   fmt.Sprintf("packages.%s", manager),
                                Message: "package name cannot be empty",
                                Help:    "remove empty entries or provide valid package names",
                        })
                        continue</span>
                }
                
                <span class="cov8" title="1">if !isValidPackageNameForManager(pkg.Name, manager) </span><span class="cov8" title="1">{
                        result.Add(ValidationError{
                                Type:       "error",
                                Title:      "invalid package name",
                                Field:      fmt.Sprintf("packages.%s", manager),
                                Value:      pkg.Name,
                                Message:    getPackageNameValidationMessage(manager),
                                Help:       getPackageNameValidationHelp(manager),
                                Suggestion: fmt.Sprintf("did you mean \"%s\"?", sanitizePackageNameForManager(pkg.Name, manager)),
                        })
                }</span>
                
                // Check for duplicates
                <span class="cov8" title="1">if existing, found := allPackages[pkg.Name]; found </span><span class="cov0" title="0">{
                        result.Add(ValidationError{
                                Type:    "warning",
                                Title:   "duplicate package",
                                Field:   fmt.Sprintf("packages.%s", manager),
                                Value:   pkg.Name,
                                Message: fmt.Sprintf("package '%s' is already listed in %s", pkg.Name, existing),
                                Help:    "remove the duplicate entry",
                                Note:    "duplicate packages are ignored but clutter configuration",
                        })
                }</span> else<span class="cov8" title="1"> {
                        allPackages[pkg.Name] = manager
                }</span>
                
                // Validate package flags
                <span class="cov8" title="1">validatePackageFlags(pkg, manager, result)</span>
        }
}

// validatePackageFlags validates the flags for a specific package entry
func validatePackageFlags(pkg PackageEntry, manager string, result *ValidationResult) <span class="cov8" title="1">{
        if len(pkg.Flags) == 0 </span><span class="cov8" title="1">{
                return // No flags to validate
        }</span>
        
        // Check for dangerous flag combinations
        <span class="cov8" title="1">validateFlagSafety(pkg.Flags, pkg.Name, manager, result)
        
        // Check for conflicting flags
        validateFlagConflicts(pkg.Flags, pkg.Name, manager, result)
        
        // Suggest common patterns for specific packages
        suggestCommonFlags(pkg, manager, result)</span>
}

// validateFlagSafety checks for potentially dangerous flags
func validateFlagSafety(flags []string, packageName, manager string, result *ValidationResult) <span class="cov8" title="1">{
        dangerousFlags := map[string]string{
                "--allow-unauthenticated": "installs packages without authentication",
                "--force":                 "bypasses safety checks",
                "--dangerous":             "bypasses snap security",
        }
        
        for _, flag := range flags </span><span class="cov8" title="1">{
                if warning, isDangerous := dangerousFlags[flag]; isDangerous </span><span class="cov0" title="0">{
                        result.Add(ValidationError{
                                Type:    "warning",
                                Title:   "potentially dangerous flag",
                                Field:   fmt.Sprintf("packages.%s", manager),
                                Value:   packageName,
                                Message: fmt.Sprintf("flag '%s' %s", flag, warning),
                                Help:    "ensure you understand the security implications",
                                Note:    "this flag reduces security but may be necessary for your use case",
                        })
                }</span>
        }
}

// validateFlagConflicts checks for conflicting flags
func validateFlagConflicts(flags []string, packageName, manager string, result *ValidationResult) <span class="cov8" title="1">{
        conflicts := map[string][]string{
                "flatpak": {"--user", "--system"}, // Can't install both user and system
        }
        
        if conflictingFlags, exists := conflicts[manager]; exists </span><span class="cov8" title="1">{
                found := make([]string, 0)
                for _, flag := range flags </span><span class="cov8" title="1">{
                        for _, conflictFlag := range conflictingFlags </span><span class="cov8" title="1">{
                                if flag == conflictFlag </span><span class="cov8" title="1">{
                                        found = append(found, flag)
                                }</span>
                        }
                }
                
                <span class="cov8" title="1">if len(found) &gt; 1 </span><span class="cov0" title="0">{
                        result.Add(ValidationError{
                                Type:    "error",
                                Title:   "conflicting flags",
                                Field:   fmt.Sprintf("packages.%s", manager),
                                Value:   packageName,
                                Message: fmt.Sprintf("conflicting flags: %v", found),
                                Help:    "choose either --user OR --system, not both",
                        })
                }</span>
        }
}

// suggestCommonFlags suggests commonly needed flags for specific packages
func suggestCommonFlags(pkg PackageEntry, manager string, result *ValidationResult) <span class="cov8" title="1">{
        suggestions := map[string]map[string][]string{
                "snap": {
                        "code":          {"--classic"},
                        "discord":       {},
                        "slack":         {"--classic"},
                        "postman":       {"--classic"},
                        "android-studio": {"--classic"},
                },
        }
        
        if managerSuggestions, exists := suggestions[manager]; exists </span><span class="cov8" title="1">{
                if suggestedFlags, exists := managerSuggestions[pkg.Name]; exists &amp;&amp; len(suggestedFlags) &gt; 0 </span><span class="cov0" title="0">{
                        // Check if package is missing commonly needed flags
                        hasAllSuggested := true
                        for _, suggested := range suggestedFlags </span><span class="cov0" title="0">{
                                found := false
                                for _, actual := range pkg.Flags </span><span class="cov0" title="0">{
                                        if actual == suggested </span><span class="cov0" title="0">{
                                                found = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                        hasAllSuggested = false
                                        break</span>
                                }
                        }
                        
                        <span class="cov0" title="0">if !hasAllSuggested &amp;&amp; len(pkg.Flags) == 0 </span><span class="cov0" title="0">{
                                result.Add(ValidationError{
                                        Type:       "warning",
                                        Title:      "missing common flags",
                                        Field:      fmt.Sprintf("packages.%s", manager),
                                        Value:      pkg.Name,
                                        Message:    fmt.Sprintf("'%s' commonly needs flags: %v", pkg.Name, suggestedFlags),
                                        Help:       "consider adding the suggested flags if the package fails to install",
                                        Suggestion: fmt.Sprintf("\"%s\":\n  flags: %v", pkg.Name, suggestedFlags),
                                })
                        }</span>
                }
        }
}

// validatePackageDefaults validates the package_defaults section
func validatePackageDefaults(defaults map[string][]string, result *ValidationResult, configPos *ConfigWithPosition, configPath string) <span class="cov8" title="1">{
        supportedManagers := GetSupportedPackageManagers()
        
        for manager, flags := range defaults </span><span class="cov8" title="1">{
                // Check if manager is supported
                supported := false
                for _, supported_manager := range supportedManagers </span><span class="cov8" title="1">{
                        if manager == supported_manager </span><span class="cov8" title="1">{
                                supported = true
                                break</span>
                        }
                }
                
                <span class="cov8" title="1">if !supported </span><span class="cov8" title="1">{
                        result.Add(ValidationError{
                                Type:       "error",
                                Title:      "unsupported package manager",
                                Field:      fmt.Sprintf("package_defaults.%s", manager),
                                Value:      manager,
                                Message:    fmt.Sprintf("'%s' is not a supported package manager", manager),
                                Help:       fmt.Sprintf("use one of: %v", supportedManagers),
                                Suggestion: "remove this entry or check for typos",
                        })
                }</span>
                
                // Validate the flags themselves
                <span class="cov8" title="1">validateFlagSafety(flags, fmt.Sprintf("(defaults for %s)", manager), manager, result)
                validateFlagConflicts(flags, fmt.Sprintf("(defaults for %s)", manager), manager, result)</span>
        }
}

func isValidFileMode(mode string) bool <span class="cov8" title="1">{
        if len(mode) != 3 &amp;&amp; len(mode) != 4 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">_, err := strconv.ParseInt(mode, 8, 32)
        return err == nil</span>
}

func isOverlyPermissive(mode string) bool <span class="cov8" title="1">{
        // Check for world-writable permissions
        return strings.HasSuffix(mode, "6") || strings.HasSuffix(mode, "7") ||
                   strings.Contains(mode, "66") || strings.Contains(mode, "77")
}</span>

func suggestAlternativeFile(path string) string <span class="cov8" title="1">{
        dir := filepath.Dir(path)
        base := filepath.Base(path)
        
        // Try common alternatives
        alternatives := []string{
                filepath.Join(dir, "."+base), // Hidden file
                filepath.Join(dir, base+".example"),
                filepath.Join(dir, base+".template"),
        }
        
        for _, alt := range alternatives </span><span class="cov8" title="1">{
                if _, err := os.Stat(alt); err == nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("did you mean \"%s\"?", strings.TrimPrefix(alt, filepath.Dir(path)+"/"))
                }</span>
        }
        
        <span class="cov8" title="1">return ""</span>
}

// isValidDebFilePath validates a local .deb file path
func isValidDebFilePath(debPath string) bool <span class="cov8" title="1">{
        // Must end with .deb
        if !strings.HasSuffix(debPath, ".deb") </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // Must contain a path separator (absolute or relative path)
        <span class="cov8" title="1">if !strings.Contains(debPath, "/") </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // Basic path sanitization - no path traversal
        <span class="cov8" title="1">if strings.Contains(debPath, "..") </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // Extract filename and check it's not just ".deb"
        <span class="cov8" title="1">parts := strings.Split(debPath, "/")
        filename := parts[len(parts)-1]
        if filename == ".deb" </span><span class="cov8" title="1">{
                return false
        }</span>
        
        <span class="cov8" title="1">return true</span>
}

// Repository validation helper functions

// isValidPPAFormat validates PPA format (user/repo)
func isValidPPAFormat(ppa string) bool <span class="cov8" title="1">{
        // PPA format: user/repo
        matched, _ := regexp.MatchString(`^[a-z0-9][a-z0-9\-]*\/[a-z0-9][a-z0-9\-]*$`, ppa)
        return matched
}</span>

// suggestPPAFormat suggests a corrected PPA format
func suggestPPAFormat(ppa string) string <span class="cov8" title="1">{
        // Remove common prefixes that users might add
        ppa = strings.TrimPrefix(ppa, "ppa:")
        ppa = strings.TrimSpace(ppa)
        
        // If it doesn't contain a slash, suggest adding one
        if !strings.Contains(ppa, "/") </span><span class="cov8" title="1">{
                return fmt.Sprintf("did you mean \"%s/ppa\"?", ppa)
        }</span>
        
        // Clean up the format
        <span class="cov0" title="0">parts := strings.Split(ppa, "/")
        if len(parts) == 2 </span><span class="cov0" title="0">{
                user := strings.ToLower(regexp.MustCompile(`[^a-z0-9\-]`).ReplaceAllString(parts[0], "-"))
                repo := strings.ToLower(regexp.MustCompile(`[^a-z0-9\-]`).ReplaceAllString(parts[1], "-"))
                return fmt.Sprintf("did you mean \"%s/%s\"?", user, repo)
        }</span>
        
        <span class="cov0" title="0">return ""</span>
}

// isValidAPTRepositoryURI validates APT repository URI format
func isValidAPTRepositoryURI(uri string) bool <span class="cov8" title="1">{
        // Must start with "deb" or "deb-src"
        if !strings.HasPrefix(uri, "deb ") &amp;&amp; !strings.HasPrefix(uri, "deb-src ") </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // Basic format check - should contain URL
        <span class="cov8" title="1">return strings.Contains(uri, "http://") || strings.Contains(uri, "https://") || strings.Contains(uri, "file://")</span>
}

// isValidGPGKeyReference validates GPG key URL or key ID
func isValidGPGKeyReference(key string) bool <span class="cov8" title="1">{
        // Check if it's a URL
        if strings.HasPrefix(key, "https://") &amp;&amp; (strings.HasSuffix(key, ".gpg") || strings.HasSuffix(key, ".asc")) </span><span class="cov8" title="1">{
                return true
        }</span>
        
        // Check if it's a keyserver key ID (hex format, optionally prefixed with 0x)
        <span class="cov8" title="1">keyID := strings.TrimPrefix(key, "0x")
        matched, _ := regexp.MatchString(`^[A-Fa-f0-9]{8,40}$`, keyID)
        return matched</span>
}

// isValidFlatpakRepositoryURL validates Flatpak repository URL
func isValidFlatpakRepositoryURL(url string) bool <span class="cov8" title="1">{
        // Must be HTTPS for security (or HTTP for local testing)
        if !strings.HasPrefix(url, "https://") &amp;&amp; !strings.HasPrefix(url, "http://") </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // Should end with .flatpakrepo or be a valid repository URL
        <span class="cov8" title="1">return strings.HasSuffix(url, ".flatpakrepo") || strings.Contains(url, "/repo/")</span>
}

// isValidFlatpakRemoteName validates Flatpak remote name
func isValidFlatpakRemoteName(name string) bool <span class="cov8" title="1">{
        // Remote names: letters, numbers, hyphens, underscores
        // Must start and end with alphanumeric character
        matched, _ := regexp.MatchString(`^[a-zA-Z0-9][a-zA-Z0-9\-_]*[a-zA-Z0-9]$|^[a-zA-Z0-9]$`, name)
        return matched
}</span>

// suggestFlatpakRemoteName suggests a corrected remote name
func suggestFlatpakRemoteName(name string) string <span class="cov8" title="1">{
        // Clean up the name
        suggested := regexp.MustCompile(`[^a-zA-Z0-9\-_]`).ReplaceAllString(name, "-")
        suggested = strings.Trim(suggested, "-_")
        
        if suggested != "" &amp;&amp; suggested != name </span><span class="cov8" title="1">{
                return fmt.Sprintf("did you mean \"%s\"?", suggested)
        }</span>
        
        <span class="cov8" title="1">return ""</span>
}</pre>
		
		<pre class="file" id="file23" style="display: none">package pkg

import (
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/charmbracelet/log"
)

// AptManager handles APT package management operations
type AptManager struct {
        logger *log.Logger
        dryRun bool
}

// NewAptManager creates a new APT package manager
func NewAptManager(logger *log.Logger, dryRun bool) *AptManager <span class="cov8" title="1">{
        return &amp;AptManager{
                logger: logger,
                dryRun: dryRun,
        }
}</span>

// InstallPackages installs the specified APT packages
func (am *AptManager) InstallPackages(packages []config.PackageEntry, packageDefaults map[string][]string) error <span class="cov8" title="1">{
        if len(packages) == 0 </span><span class="cov8" title="1">{
                am.logger.Debug("No APT packages to install")
                return nil
        }</span>

        <span class="cov8" title="1">am.logger.Info("Managing APT packages...")

        // Check if apt is available
        if err := am.checkAptAvailable(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("apt not available: %w", err)
        }</span>

        // Group packages by their resolved flags to minimize apt calls
        <span class="cov8" title="1">flagGroups := am.groupPackagesByFlags(packages, packageDefaults)

        for flagsKey, packageGroup := range flagGroups </span><span class="cov8" title="1">{
                if err := am.installPackageGroup(packageGroup, strings.Split(flagsKey, "|")); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// checkAptAvailable verifies that apt is available on the system
func (am *AptManager) checkAptAvailable() error <span class="cov8" title="1">{
        _, err := exec.LookPath("apt")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("apt command not found - is this a Debian/Ubuntu system?")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// groupPackagesByFlags groups packages with the same resolved flags together
func (am *AptManager) groupPackagesByFlags(packages []config.PackageEntry, packageDefaults map[string][]string) map[string][]config.PackageEntry <span class="cov8" title="1">{
        flagGroups := make(map[string][]config.PackageEntry)

        for _, pkg := range packages </span><span class="cov8" title="1">{
                flags := am.resolvePackageFlags(pkg, packageDefaults)
                flagsKey := strings.Join(flags, "|") // Use "|" as separator since it's not valid in flags
                flagGroups[flagsKey] = append(flagGroups[flagsKey], pkg)
        }</span>

        <span class="cov8" title="1">return flagGroups</span>
}

// resolvePackageFlags implements the three-tier flag resolution system
func (am *AptManager) resolvePackageFlags(pkg config.PackageEntry, packageDefaults map[string][]string) []string <span class="cov8" title="1">{
        // Tier 3: Per-package flags (highest priority)
        // Note: pkg.Flags != nil means the user explicitly set flags (even if empty)
        if pkg.Flags != nil </span><span class="cov8" title="1">{
                am.logger.Debug("Using per-package flags", "package", pkg.Name, "flags", pkg.Flags)
                return pkg.Flags
        }</span>

        // Tier 2: User package defaults
        <span class="cov8" title="1">if userDefaults, exists := packageDefaults["apt"]; exists </span><span class="cov8" title="1">{
                am.logger.Debug("Using user default flags", "package", pkg.Name, "flags", userDefaults)
                return userDefaults
        }</span>

        // Tier 1: Internal defaults
        <span class="cov8" title="1">internalDefaults := config.GetDefaultFlags("apt")
        am.logger.Debug("Using internal default flags", "package", pkg.Name, "flags", internalDefaults)
        return internalDefaults</span>
}

// installPackageGroup installs a group of packages with the same flags
func (am *AptManager) installPackageGroup(packages []config.PackageEntry, flags []string) error <span class="cov8" title="1">{
        packageNames := make([]string, len(packages))
        localDebFiles := make([]string, 0)
        
        for i, pkg := range packages </span><span class="cov8" title="1">{
                packageNames[i] = pkg.Name
                
                // Check if this is a local .deb file
                if am.isLocalDebFile(pkg.Name) </span><span class="cov0" title="0">{
                        localDebFiles = append(localDebFiles, pkg.Name)
                }</span>
        }

        // Handle local .deb files separately
        <span class="cov8" title="1">if len(localDebFiles) &gt; 0 </span><span class="cov0" title="0">{
                if err := am.installLocalDebFiles(localDebFiles, flags); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // Remove local files from regular package installation
                <span class="cov0" title="0">packageNames = am.filterOutLocalFiles(packageNames)</span>
        }

        // Install regular packages from repositories
        <span class="cov8" title="1">if len(packageNames) &gt; 0 </span><span class="cov8" title="1">{
                if err := am.installRepositoryPackages(packageNames, flags); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// isLocalDebFile checks if a package name refers to a local .deb file
func (am *AptManager) isLocalDebFile(packageName string) bool <span class="cov8" title="1">{
        return strings.HasSuffix(packageName, ".deb") &amp;&amp; (strings.HasPrefix(packageName, "/") || strings.Contains(packageName, "/"))
}</span>

// filterOutLocalFiles removes local .deb files from the package list
func (am *AptManager) filterOutLocalFiles(packageNames []string) []string <span class="cov8" title="1">{
        filtered := make([]string, 0, len(packageNames))
        for _, name := range packageNames </span><span class="cov8" title="1">{
                if !am.isLocalDebFile(name) </span><span class="cov8" title="1">{
                        filtered = append(filtered, name)
                }</span>
        }
        <span class="cov8" title="1">return filtered</span>
}

// installLocalDebFiles installs local .deb files
func (am *AptManager) installLocalDebFiles(debFiles []string, flags []string) error <span class="cov0" title="0">{
        for _, debFile := range debFiles </span><span class="cov0" title="0">{
                if err := am.installSingleDebFile(debFile, flags); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// installSingleDebFile installs a single local .deb file
func (am *AptManager) installSingleDebFile(debFile string, flags []string) error <span class="cov8" title="1">{
        // Resolve relative paths
        if !filepath.IsAbs(debFile) </span><span class="cov8" title="1">{
                wd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get working directory: %w", err)
                }</span>
                <span class="cov8" title="1">debFile = filepath.Join(wd, debFile)</span>
        }

        // Verify file exists
        <span class="cov8" title="1">if _, err := os.Stat(debFile); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return fmt.Errorf("local .deb file not found: %s", debFile)
        }</span>

        // Build apt install command for local file
        <span class="cov8" title="1">args := append([]string{"install"}, flags...)
        args = append(args, debFile)

        am.logger.Info("Installing local .deb file", "file", debFile, "flags", flags)

        if am.dryRun </span><span class="cov8" title="1">{
                am.logger.Debug("DRY RUN: Would run apt command", "args", args)
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("apt", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install local .deb file %s: %w", debFile, err)
        }</span>

        <span class="cov0" title="0">config.Success("Installed local .deb file: %s", filepath.Base(debFile))
        return nil</span>
}

// installRepositoryPackages installs packages from repositories
func (am *AptManager) installRepositoryPackages(packageNames []string, flags []string) error <span class="cov8" title="1">{
        // Check which packages are already installed
        installedPackages, err := am.getInstalledPackages(packageNames)
        if err != nil </span><span class="cov0" title="0">{
                am.logger.Warn("Failed to check installed packages, proceeding anyway", "error", err)
                installedPackages = make(map[string]bool) // Empty map means check all packages
        }</span>

        // Filter out already installed packages
        <span class="cov8" title="1">packagesToInstall := make([]string, 0, len(packageNames))
        for _, pkg := range packageNames </span><span class="cov8" title="1">{
                if !installedPackages[pkg] </span><span class="cov8" title="1">{
                        packagesToInstall = append(packagesToInstall, pkg)
                }</span> else<span class="cov0" title="0"> {
                        am.logger.Debug("Package already installed", "package", pkg)
                }</span>
        }

        <span class="cov8" title="1">if len(packagesToInstall) == 0 </span><span class="cov0" title="0">{
                am.logger.Info("All APT packages already installed")
                return nil
        }</span>

        // Build apt install command
        <span class="cov8" title="1">args := append([]string{"install"}, flags...)
        args = append(args, packagesToInstall...)

        am.logger.Info("Installing APT packages", "packages", packagesToInstall, "flags", flags)

        if am.dryRun </span><span class="cov8" title="1">{
                am.logger.Debug("DRY RUN: Would run apt command", "args", args)
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("apt", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install packages %v: %w", packagesToInstall, err)
        }</span>

        <span class="cov0" title="0">for _, pkg := range packagesToInstall </span><span class="cov0" title="0">{
                config.Success("Installed package: %s", pkg)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getInstalledPackages checks which packages from the list are already installed
func (am *AptManager) getInstalledPackages(packageNames []string) (map[string]bool, error) <span class="cov8" title="1">{
        installed := make(map[string]bool)

        for _, pkg := range packageNames </span><span class="cov8" title="1">{
                isInstalled, err := am.isPackageInstalled(pkg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to check if package %s is installed: %w", pkg, err)
                }</span>
                <span class="cov8" title="1">installed[pkg] = isInstalled</span>
        }

        <span class="cov8" title="1">return installed, nil</span>
}

// isPackageInstalled checks if a single package is installed
func (am *AptManager) isPackageInstalled(packageName string) (bool, error) <span class="cov8" title="1">{
        cmd := exec.Command("dpkg", "-s", packageName)
        output, err := cmd.CombinedOutput()
        
        if err != nil </span><span class="cov8" title="1">{
                // dpkg returns non-zero if package is not installed
                return false, nil
        }</span>

        // Check if the package status indicates it's installed
        <span class="cov0" title="0">outputStr := string(output)
        return strings.Contains(outputStr, "Status: install ok installed"), nil</span>
}

// RemovePackages removes packages that are no longer in the configuration
func (am *AptManager) RemovePackages(packagesToRemove []string) error <span class="cov0" title="0">{
        if len(packagesToRemove) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">am.logger.Info("Removing APT packages no longer in configuration", "packages", packagesToRemove)

        // Filter to only remove packages that are actually installed
        installedToRemove := make([]string, 0, len(packagesToRemove))
        for _, pkg := range packagesToRemove </span><span class="cov0" title="0">{
                if installed, err := am.isPackageInstalled(pkg); err != nil </span><span class="cov0" title="0">{
                        am.logger.Warn("Could not check if package is installed", "package", pkg, "error", err)
                }</span> else<span class="cov0" title="0"> if installed </span><span class="cov0" title="0">{
                        installedToRemove = append(installedToRemove, pkg)
                }</span>
        }

        <span class="cov0" title="0">if len(installedToRemove) == 0 </span><span class="cov0" title="0">{
                am.logger.Info("No installed APT packages to remove")
                return nil
        }</span>

        // Build apt remove command
        <span class="cov0" title="0">args := append([]string{"remove", "-y"}, installedToRemove...)

        if am.dryRun </span><span class="cov0" title="0">{
                am.logger.Debug("DRY RUN: Would run apt command", "args", args)
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("apt", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove packages %v: %w", installedToRemove, err)
        }</span>

        <span class="cov0" title="0">for _, pkg := range installedToRemove </span><span class="cov0" title="0">{
                config.Success("Removed package: %s", pkg)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SearchPackages searches for APT packages using apt search
func (am *AptManager) SearchPackages(searchTerm string) ([]string, error) <span class="cov0" title="0">{
        if searchTerm == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("search term cannot be empty")
        }</span>

        <span class="cov0" title="0">if am.dryRun </span><span class="cov0" title="0">{
                am.logger.Info("DRY RUN: Would search for packages", "term", searchTerm)
                return []string{}, nil
        }</span>

        // Check if apt is available
        <span class="cov0" title="0">if err := am.checkAptAvailable(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("apt not available: %w", err)
        }</span>

        <span class="cov0" title="0">args := []string{"search", searchTerm}
        cmd := exec.Command("apt", args...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("apt search failed: %w", err)
        }</span>

        <span class="cov0" title="0">var packages []string
        lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "WARNING:") || strings.HasPrefix(line, "NOTE:") </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // APT search output format: "packagename/repository - description"
                <span class="cov0" title="0">if strings.Contains(line, "/") &amp;&amp; strings.Contains(line, " - ") </span><span class="cov0" title="0">{
                        parts := strings.Split(line, "/")
                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                packageName := strings.TrimSpace(parts[0])
                                if packageName != "" </span><span class="cov0" title="0">{
                                        packages = append(packages, packageName)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">am.logger.Debug("Found APT packages", "search", searchTerm, "count", len(packages))
        return packages, nil</span>
}

// GetPackageInfo returns detailed information about an APT package
func (am *AptManager) GetPackageInfo(packageName string) (string, error) <span class="cov0" title="0">{
        if packageName == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("package name cannot be empty")
        }</span>

        <span class="cov0" title="0">if am.dryRun </span><span class="cov0" title="0">{
                am.logger.Info("DRY RUN: Would get package info", "package", packageName)
                return "", nil
        }</span>

        // Check if apt is available
        <span class="cov0" title="0">if err := am.checkAptAvailable(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("apt not available: %w", err)
        }</span>

        <span class="cov0" title="0">args := []string{"show", packageName}
        cmd := exec.Command("apt", args...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("apt show failed for package %s: %w", packageName, err)
        }</span>

        <span class="cov0" title="0">return string(output), nil</span>
}

// ListUpgradablePackages returns a list of packages that can be upgraded
func (am *AptManager) ListUpgradablePackages() ([]string, error) <span class="cov0" title="0">{
        if am.dryRun </span><span class="cov0" title="0">{
                am.logger.Info("DRY RUN: Would list upgradable packages")
                return []string{}, nil
        }</span>

        // Check if apt is available
        <span class="cov0" title="0">if err := am.checkAptAvailable(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("apt not available: %w", err)
        }</span>

        <span class="cov0" title="0">args := []string{"list", "--upgradable"}
        cmd := exec.Command("apt", args...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("apt list --upgradable failed: %w", err)
        }</span>

        <span class="cov0" title="0">var packages []string
        lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "WARNING:") || strings.HasPrefix(line, "Listing...") </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // APT list output format: "packagename/repository version [upgradable from: oldversion]"
                <span class="cov0" title="0">if strings.Contains(line, "/") &amp;&amp; strings.Contains(line, "[upgradable from:") </span><span class="cov0" title="0">{
                        parts := strings.Split(line, "/")
                        if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                                packageName := strings.TrimSpace(parts[0])
                                if packageName != "" </span><span class="cov0" title="0">{
                                        packages = append(packages, packageName)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">am.logger.Debug("Found upgradable APT packages", "count", len(packages))
        return packages, nil</span>
}

// UpgradePackages upgrades all upgradable packages or specific packages
func (am *AptManager) UpgradePackages(packageNames []string, flags []string) error <span class="cov0" title="0">{
        // Check if apt is available
        if err := am.checkAptAvailable(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("apt not available: %w", err)
        }</span>

        <span class="cov0" title="0">var args []string
        if len(packageNames) == 0 </span><span class="cov0" title="0">{
                // Upgrade all packages
                args = append([]string{"upgrade"}, flags...)
                am.logger.Info("Upgrading all APT packages", "flags", flags)
        }</span> else<span class="cov0" title="0"> {
                // Upgrade specific packages
                args = append([]string{"install", "--only-upgrade"}, flags...)
                args = append(args, packageNames...)
                am.logger.Info("Upgrading specific APT packages", "packages", packageNames, "flags", flags)
        }</span>

        <span class="cov0" title="0">if am.dryRun </span><span class="cov0" title="0">{
                am.logger.Debug("DRY RUN: Would run apt command", "args", args)
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("apt", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to upgrade packages: %w", err)
        }</span>

        <span class="cov0" title="0">if len(packageNames) == 0 </span><span class="cov0" title="0">{
                config.Success("All APT packages upgraded successfully")
        }</span> else<span class="cov0" title="0"> {
                for _, pkg := range packageNames </span><span class="cov0" title="0">{
                        config.Success("Upgraded package: %s", pkg)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetPackageDependencies returns the dependencies of an APT package
func (am *AptManager) GetPackageDependencies(packageName string) ([]string, error) <span class="cov0" title="0">{
        if packageName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("package name cannot be empty")
        }</span>

        <span class="cov0" title="0">if am.dryRun </span><span class="cov0" title="0">{
                am.logger.Info("DRY RUN: Would get package dependencies", "package", packageName)
                return []string{}, nil
        }</span>

        // Check if apt is available
        <span class="cov0" title="0">if err := am.checkAptAvailable(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("apt not available: %w", err)
        }</span>

        <span class="cov0" title="0">args := []string{"depends", packageName}
        cmd := exec.Command("apt", args...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("apt depends failed for package %s: %w", packageName, err)
        }</span>

        <span class="cov0" title="0">var dependencies []string
        lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, packageName+":") </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // APT depends output format: "  Depends: packagename"
                <span class="cov0" title="0">if strings.HasPrefix(line, "Depends:") || strings.HasPrefix(line, "  ") </span><span class="cov0" title="0">{
                        parts := strings.Fields(line)
                        if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                                // Remove "Depends:" prefix and extract package name
                                depName := parts[len(parts)-1]
                                // Clean up package name (remove version constraints)
                                if idx := strings.Index(depName, "("); idx != -1 </span><span class="cov0" title="0">{
                                        depName = depName[:idx]
                                }</span>
                                <span class="cov0" title="0">if depName != "" &amp;&amp; depName != packageName </span><span class="cov0" title="0">{
                                        dependencies = append(dependencies, depName)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">am.logger.Debug("Found package dependencies", "package", packageName, "count", len(dependencies))
        return dependencies, nil</span>
}

// SimulateInstall simulates package installation to show what would be installed
func (am *AptManager) SimulateInstall(packageNames []string, flags []string) ([]string, error) <span class="cov0" title="0">{
        if len(packageNames) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no packages specified")
        }</span>

        <span class="cov0" title="0">if am.dryRun </span><span class="cov0" title="0">{
                am.logger.Info("DRY RUN: Would simulate package installation", "packages", packageNames)
                return []string{}, nil
        }</span>

        // Check if apt is available
        <span class="cov0" title="0">if err := am.checkAptAvailable(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("apt not available: %w", err)
        }</span>

        // Build apt install command with simulation flag
        <span class="cov0" title="0">args := append([]string{"install", "--simulate"}, flags...)
        args = append(args, packageNames...)

        cmd := exec.Command("apt", args...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("apt simulate failed: %w", err)
        }</span>

        <span class="cov0" title="0">var willInstall []string
        lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                // Look for "Inst" lines which show what would be installed
                if strings.HasPrefix(line, "Inst ") </span><span class="cov0" title="0">{
                        parts := strings.Fields(line)
                        if len(parts) &gt;= 2 </span><span class="cov0" title="0">{
                                packageName := parts[1]
                                willInstall = append(willInstall, packageName)
                        }</span>
                }
        }

        <span class="cov0" title="0">am.logger.Debug("Simulated package installation", "packages", packageNames, "will_install", len(willInstall))
        return willInstall, nil</span>
}</pre>
		
		<pre class="file" id="file24" style="display: none">package pkg

import (
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/charmbracelet/log"
)

// CacheManager handles configuration and system state caching for performance optimization
type CacheManager struct {
        logger    *log.Logger
        cacheDir  string
}

// CachedConfig represents a cached configuration with metadata
type CachedConfig struct {
        Config       *config.Config    `json:"config"`
        ConfigHash   string            `json:"config_hash"`
        ConfigPaths  []string          `json:"config_paths"`
        ModTimes     map[string]int64  `json:"mod_times"`
        CachedAt     time.Time         `json:"cached_at"`
        Version      string            `json:"version"`
}

// SystemStateCache represents cached system state information
type SystemStateCache struct {
        PackageState    PackageInstallationState `json:"package_state"`
        FileState       FileDeploymentState      `json:"file_state"`
        LastChecked     time.Time                `json:"last_checked"`
        SystemHash      string                   `json:"system_hash"`
        Version         string                   `json:"version"`
}

// PackageInstallationState caches package manager state
type PackageInstallationState struct {
        AptPackages     map[string]PackageCacheEntry `json:"apt_packages"`
        FlatpakPackages map[string]PackageCacheEntry `json:"flatpak_packages"`
        SnapPackages    map[string]PackageCacheEntry `json:"snap_packages"`
        LastUpdated     time.Time                    `json:"last_updated"`
}

// FileDeploymentState caches file system state
type FileDeploymentState struct {
        Files       map[string]FileCacheEntry `json:"files"`
        LastUpdated time.Time                 `json:"last_updated"`
}

// PackageCacheEntry represents a cached package state
type PackageCacheEntry struct {
        Name        string    `json:"name"`
        Installed   bool      `json:"installed"`
        Version     string    `json:"version,omitempty"`
        LastChecked time.Time `json:"last_checked"`
}

// FileCacheEntry represents a cached file state
type FileCacheEntry struct {
        Path         string    `json:"path"`
        ModTime      time.Time `json:"mod_time"`
        Size         int64     `json:"size"`
        IsSymlink    bool      `json:"is_symlink"`
        Target       string    `json:"target,omitempty"`
        Hash         string    `json:"hash,omitempty"`
        LastChecked  time.Time `json:"last_checked"`
}

// NewCacheManager creates a new cache manager
func NewCacheManager(logger *log.Logger) *CacheManager <span class="cov8" title="1">{
        // Default cache directory: ~/.cache/configr/
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Could not determine home directory, using /tmp for cache", "error", err)
                homeDir = "/tmp"
        }</span>
        
        <span class="cov8" title="1">cacheDir := filepath.Join(homeDir, ".cache", "configr")
        
        return &amp;CacheManager{
                logger:   logger,
                cacheDir: cacheDir,
        }</span>
}

// NewCacheManagerWithPath creates a cache manager with custom cache directory
func NewCacheManagerWithPath(logger *log.Logger, cacheDir string) *CacheManager <span class="cov8" title="1">{
        return &amp;CacheManager{
                logger:   logger,
                cacheDir: cacheDir,
        }
}</span>

// LoadCachedConfig attempts to load a cached configuration
func (cm *CacheManager) LoadCachedConfig(configPaths []string) (*CachedConfig, error) <span class="cov8" title="1">{
        cm.logger.Debug("Attempting to load cached configuration", "paths", configPaths)
        
        // Generate cache key from config paths
        cacheKey := cm.generateConfigCacheKey(configPaths)
        cachePath := filepath.Join(cm.cacheDir, "config", cacheKey+".json")
        
        // Check if cache file exists
        if _, err := os.Stat(cachePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                cm.logger.Debug("No cached configuration found", "cache_path", cachePath)
                return nil, nil
        }</span>
        
        // Load cache file
        <span class="cov8" title="1">data, err := os.ReadFile(cachePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read cache file: %w", err)
        }</span>
        
        <span class="cov8" title="1">var cached CachedConfig
        if err := json.Unmarshal(data, &amp;cached); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse cache file: %w", err)
        }</span>
        
        // Validate cache is still valid
        <span class="cov8" title="1">if !cm.isCacheValid(&amp;cached, configPaths) </span><span class="cov8" title="1">{
                cm.logger.Debug("Cached configuration is invalid, will regenerate")
                return nil, nil
        }</span>
        
        <span class="cov8" title="1">cm.logger.Debug("Loaded cached configuration successfully", "cached_at", cached.CachedAt)
        return &amp;cached, nil</span>
}

// SaveCachedConfig saves a configuration to cache
func (cm *CacheManager) SaveCachedConfig(cfg *config.Config, configPaths []string) error <span class="cov8" title="1">{
        cm.logger.Debug("Saving configuration to cache", "paths", configPaths)
        
        // Ensure cache directory exists
        cacheConfigDir := filepath.Join(cm.cacheDir, "config")
        if err := os.MkdirAll(cacheConfigDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create cache directory: %w", err)
        }</span>
        
        // Generate modification time map
        <span class="cov8" title="1">modTimes := make(map[string]int64)
        for _, path := range configPaths </span><span class="cov8" title="1">{
                if info, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                        modTimes[path] = info.ModTime().Unix()
                }</span>
        }
        
        // Create cached config
        <span class="cov8" title="1">configHash := cm.generateConfigHash(cfg, configPaths)
        cached := CachedConfig{
                Config:      cfg,
                ConfigHash:  configHash,
                ConfigPaths: configPaths,
                ModTimes:    modTimes,
                CachedAt:    time.Now(),
                Version:     "1.0",
        }
        
        // Marshal to JSON
        data, err := json.MarshalIndent(cached, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal cache: %w", err)
        }</span>
        
        // Write to cache file
        <span class="cov8" title="1">cacheKey := cm.generateConfigCacheKey(configPaths)
        cachePath := filepath.Join(cacheConfigDir, cacheKey+".json")
        
        if err := os.WriteFile(cachePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write cache file: %w", err)
        }</span>
        
        <span class="cov8" title="1">cm.logger.Debug("Configuration cached successfully", "cache_path", cachePath)
        return nil</span>
}

// LoadSystemStateCache loads cached system state
func (cm *CacheManager) LoadSystemStateCache() (*SystemStateCache, error) <span class="cov8" title="1">{
        cachePath := filepath.Join(cm.cacheDir, "system_state.json")
        
        if _, err := os.Stat(cachePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                cm.logger.Debug("No system state cache found")
                return nil, nil
        }</span>
        
        <span class="cov8" title="1">data, err := os.ReadFile(cachePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read system state cache: %w", err)
        }</span>
        
        <span class="cov8" title="1">var cache SystemStateCache
        if err := json.Unmarshal(data, &amp;cache); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse system state cache: %w", err)
        }</span>
        
        // Check if cache is too old (default: 1 hour)
        <span class="cov8" title="1">if time.Since(cache.LastChecked) &gt; time.Hour </span><span class="cov8" title="1">{
                cm.logger.Debug("System state cache is stale, will refresh")
                return nil, nil
        }</span>
        
        <span class="cov8" title="1">cm.logger.Debug("Loaded system state cache successfully", "last_checked", cache.LastChecked)
        return &amp;cache, nil</span>
}

// SaveSystemStateCache saves system state to cache
func (cm *CacheManager) SaveSystemStateCache(cache *SystemStateCache) error <span class="cov8" title="1">{
        if err := os.MkdirAll(cm.cacheDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create cache directory: %w", err)
        }</span>
        
        <span class="cov8" title="1">cache.LastChecked = time.Now()
        cache.Version = "1.0"
        
        data, err := json.MarshalIndent(cache, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal system state cache: %w", err)
        }</span>
        
        <span class="cov8" title="1">cachePath := filepath.Join(cm.cacheDir, "system_state.json")
        if err := os.WriteFile(cachePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write system state cache: %w", err)
        }</span>
        
        <span class="cov8" title="1">cm.logger.Debug("System state cache saved successfully")
        return nil</span>
}

// ClearCache removes all cached data
func (cm *CacheManager) ClearCache() error <span class="cov8" title="1">{
        cm.logger.Info("Clearing all cache data", "cache_dir", cm.cacheDir)
        
        if err := os.RemoveAll(cm.cacheDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear cache: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// GetCacheStats returns information about cache usage
func (cm *CacheManager) GetCacheStats() (*CacheStats, error) <span class="cov8" title="1">{
        stats := &amp;CacheStats{
                CacheDir: cm.cacheDir,
        }
        
        // Check if cache directory exists
        if _, err := os.Stat(cm.cacheDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return stats, nil
        }</span>
        
        // Walk cache directory to collect stats
        <span class="cov8" title="1">err := filepath.Walk(cm.cacheDir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                        stats.TotalFiles++
                        stats.TotalSize += info.Size()
                        
                        if info.ModTime().After(stats.LastModified) </span><span class="cov8" title="1">{
                                stats.LastModified = info.ModTime()
                        }</span>
                }
                
                <span class="cov8" title="1">return nil</span>
        })
        
        <span class="cov8" title="1">return stats, err</span>
}

// CacheStats represents cache usage statistics
type CacheStats struct {
        CacheDir     string    `json:"cache_dir"`
        TotalFiles   int       `json:"total_files"`
        TotalSize    int64     `json:"total_size"`
        LastModified time.Time `json:"last_modified"`
}

// isCacheValid checks if a cached configuration is still valid
func (cm *CacheManager) isCacheValid(cached *CachedConfig, configPaths []string) bool <span class="cov8" title="1">{
        // Check if config paths have changed
        if len(cached.ConfigPaths) != len(configPaths) </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov8" title="1">for i, path := range configPaths </span><span class="cov8" title="1">{
                if i &gt;= len(cached.ConfigPaths) || cached.ConfigPaths[i] != path </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        
        // Check modification times
        <span class="cov8" title="1">for _, path := range configPaths </span><span class="cov8" title="1">{
                info, err := os.Stat(path)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                
                <span class="cov8" title="1">cachedModTime, exists := cached.ModTimes[path]
                if !exists || info.ModTime().Unix() != cachedModTime </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        
        <span class="cov8" title="1">return true</span>
}

// generateConfigCacheKey creates a unique cache key for configuration paths
func (cm *CacheManager) generateConfigCacheKey(configPaths []string) string <span class="cov8" title="1">{
        hasher := sha256.New()
        for _, path := range configPaths </span><span class="cov8" title="1">{
                hasher.Write([]byte(path))
        }</span>
        <span class="cov8" title="1">return hex.EncodeToString(hasher.Sum(nil))[:16]</span> // Use first 16 chars
}

// generateConfigHash creates a hash of the configuration content
func (cm *CacheManager) generateConfigHash(cfg *config.Config, configPaths []string) string <span class="cov8" title="1">{
        hasher := sha256.New()
        
        // Hash config content
        if data, err := json.Marshal(cfg); err == nil </span><span class="cov8" title="1">{
                hasher.Write(data)
        }</span>
        
        // Hash file modification times
        <span class="cov8" title="1">for _, path := range configPaths </span><span class="cov8" title="1">{
                hasher.Write([]byte(path))
                if info, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                        hasher.Write([]byte(fmt.Sprintf("%d", info.ModTime().Unix())))
                }</span>
        }
        
        <span class="cov8" title="1">return hex.EncodeToString(hasher.Sum(nil))</span>
}</pre>
		
		<pre class="file" id="file25" style="display: none">package pkg

import (
        "fmt"
        "os/exec"
        "strings"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/charmbracelet/log"
)

// DConfManager handles dconf configuration management operations
type DConfManager struct {
        logger *log.Logger
        dryRun bool
}

// NewDConfManager creates a new dconf manager
func NewDConfManager(logger *log.Logger, dryRun bool) *DConfManager <span class="cov8" title="1">{
        return &amp;DConfManager{
                logger: logger,
                dryRun: dryRun,
        }
}</span>

// ApplySettings applies all dconf settings
func (dm *DConfManager) ApplySettings(dconfConfig config.DConfConfig) error <span class="cov8" title="1">{
        if len(dconfConfig.Settings) == 0 </span><span class="cov8" title="1">{
                dm.logger.Debug("No dconf settings to apply")
                return nil
        }</span>

        <span class="cov8" title="1">dm.logger.Info("Applying dconf settings...", "count", len(dconfConfig.Settings))

        // Check if dconf is available (skip in dry-run for testing)
        if !dm.dryRun </span><span class="cov0" title="0">{
                if err := dm.checkDConfAvailable(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("dconf not available: %w", err)
                }</span>
        }

        <span class="cov8" title="1">for path, value := range dconfConfig.Settings </span><span class="cov8" title="1">{
                if err := dm.setSetting(path, value); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set dconf setting '%s': %w", path, err)
                }</span>
        }

        <span class="cov8" title="1">dm.logger.Info("✓ DConf settings applied successfully")
        return nil</span>
}

// setSetting sets a single dconf setting
func (dm *DConfManager) setSetting(path, value string) error <span class="cov8" title="1">{
        args := []string{"dconf", "write", path, value}

        dm.logger.Info("Setting dconf value", "path", path, "value", value)

        if dm.dryRun </span><span class="cov8" title="1">{
                dm.logger.Info("  [DRY RUN] Would run:", "command", strings.Join(args, " "))
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                dm.logger.Error("Failed to set dconf value", "path", path, "error", err, "output", string(output))
                return fmt.Errorf("dconf write failed: %w", err)
        }</span>

        <span class="cov0" title="0">dm.logger.Debug("DConf value set successfully", "path", path, "output", string(output))
        return nil</span>
}

// GetSetting retrieves a single dconf setting value
func (dm *DConfManager) GetSetting(path string) (string, error) <span class="cov8" title="1">{
        if dm.dryRun </span><span class="cov8" title="1">{
                dm.logger.Info("  [DRY RUN] Would run:", "command", fmt.Sprintf("dconf read %s", path))
                return "", nil
        }</span>

        <span class="cov0" title="0">args := []string{"dconf", "read", path}
        cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                dm.logger.Error("Failed to read dconf value", "path", path, "error", err, "output", string(output))
                return "", fmt.Errorf("dconf read failed: %w", err)
        }</span>

        <span class="cov0" title="0">value := strings.TrimSpace(string(output))
        dm.logger.Debug("DConf value retrieved", "path", path, "value", value)
        return value, nil</span>
}

// ResetSetting resets a dconf setting to its default value
func (dm *DConfManager) ResetSetting(path string) error <span class="cov8" title="1">{
        args := []string{"dconf", "reset", path}

        dm.logger.Info("Resetting dconf value", "path", path)

        if dm.dryRun </span><span class="cov8" title="1">{
                dm.logger.Info("  [DRY RUN] Would run:", "command", strings.Join(args, " "))
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                dm.logger.Error("Failed to reset dconf value", "path", path, "error", err, "output", string(output))
                return fmt.Errorf("dconf reset failed: %w", err)
        }</span>

        <span class="cov0" title="0">dm.logger.Debug("DConf value reset successfully", "path", path, "output", string(output))
        return nil</span>
}

// ListSettings lists all dconf settings under a given path
func (dm *DConfManager) ListSettings(path string) ([]string, error) <span class="cov8" title="1">{
        if dm.dryRun </span><span class="cov8" title="1">{
                dm.logger.Info("  [DRY RUN] Would run:", "command", fmt.Sprintf("dconf list %s", path))
                return []string{}, nil
        }</span>

        <span class="cov0" title="0">args := []string{"dconf", "list", path}
        cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                dm.logger.Error("Failed to list dconf settings", "path", path, "error", err, "output", string(output))
                return nil, fmt.Errorf("dconf list failed: %w", err)
        }</span>

        // Split output into lines and filter out empty lines
        <span class="cov0" title="0">lines := strings.Split(strings.TrimSpace(string(output)), "\n")
        var settings []string
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line != "" </span><span class="cov0" title="0">{
                        settings = append(settings, line)
                }</span>
        }

        <span class="cov0" title="0">dm.logger.Debug("DConf settings listed", "path", path, "count", len(settings))
        return settings, nil</span>
}

// DumpSettings dumps all dconf settings under a given path
func (dm *DConfManager) DumpSettings(path string) (map[string]string, error) <span class="cov8" title="1">{
        if dm.dryRun </span><span class="cov8" title="1">{
                dm.logger.Info("  [DRY RUN] Would run:", "command", fmt.Sprintf("dconf dump %s", path))
                return map[string]string{}, nil
        }</span>

        <span class="cov0" title="0">args := []string{"dconf", "dump", path}
        cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                dm.logger.Error("Failed to dump dconf settings", "path", path, "error", err, "output", string(output))
                return nil, fmt.Errorf("dconf dump failed: %w", err)
        }</span>

        // Parse the ini-like output format
        <span class="cov0" title="0">settings := make(map[string]string)
        lines := strings.Split(string(output), "\n")
        var currentSection string

        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Handle section headers like [org/gnome/desktop/interface]
                <span class="cov0" title="0">if strings.HasPrefix(line, "[") &amp;&amp; strings.HasSuffix(line, "]") </span><span class="cov0" title="0">{
                        currentSection = strings.Trim(line, "[]")
                        // Convert section format to dconf path format
                        if !strings.HasPrefix(currentSection, "/") </span><span class="cov0" title="0">{
                                currentSection = "/" + strings.ReplaceAll(currentSection, "/", "/")
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Handle key=value pairs
                <span class="cov0" title="0">if strings.Contains(line, "=") </span><span class="cov0" title="0">{
                        parts := strings.SplitN(line, "=", 2)
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                key := strings.TrimSpace(parts[0])
                                value := strings.TrimSpace(parts[1])
                                fullPath := currentSection + "/" + key
                                settings[fullPath] = value
                        }</span>
                }
        }

        <span class="cov0" title="0">dm.logger.Debug("DConf settings dumped", "path", path, "count", len(settings))
        return settings, nil</span>
}

// checkDConfAvailable checks if dconf command is available
func (dm *DConfManager) checkDConfAvailable() error <span class="cov8" title="1">{
        if _, err := exec.LookPath("dconf"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dconf command not found - install dconf package")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateSettings validates dconf settings before applying them
func (dm *DConfManager) ValidateSettings(dconfConfig config.DConfConfig) error <span class="cov8" title="1">{
        dm.logger.Debug("Validating dconf settings", "count", len(dconfConfig.Settings))

        for path, value := range dconfConfig.Settings </span><span class="cov8" title="1">{
                // Validate path format
                if !strings.HasPrefix(path, "/") </span><span class="cov8" title="1">{
                        return fmt.Errorf("dconf path '%s' must start with '/'", path)
                }</span>

                <span class="cov8" title="1">if strings.Contains(path, "//") </span><span class="cov8" title="1">{
                        return fmt.Errorf("dconf path '%s' contains double slashes", path)
                }</span>

                // Validate value format (basic checks)
                <span class="cov8" title="1">if value == "" </span><span class="cov0" title="0">{
                        dm.logger.Warn("Empty dconf value", "path", path, "value", value)
                }</span>

                // Check if value looks like it should be quoted
                <span class="cov8" title="1">if !strings.HasPrefix(value, "'") &amp;&amp; !strings.HasPrefix(value, "\"") &amp;&amp; 
                   !strings.HasPrefix(value, "[") &amp;&amp; !isNumericValue(value) &amp;&amp; !isBooleanValue(value) </span><span class="cov0" title="0">{
                        dm.logger.Warn("DConf value may need quotes", "path", path, "value", value, 
                                "suggestion", fmt.Sprintf("'%s'", value))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// isNumericValue checks if a value looks like a number
func isNumericValue(value string) bool <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        
        <span class="cov8" title="1">dotCount := 0
        eCount := 0
        
        for i, char := range value </span><span class="cov8" title="1">{
                switch </span>{
                case char &gt;= '0' &amp;&amp; char &lt;= '9':<span class="cov8" title="1">
                        // Numbers are always valid
                        continue</span>
                case char == '.':<span class="cov8" title="1">
                        dotCount++
                        if dotCount &gt; 1 </span><span class="cov8" title="1">{
                                return false // Multiple decimal points
                        }</span>
                case char == '-' || char == '+':<span class="cov8" title="1">
                        // Signs only valid at start or after 'e'/'E'
                        if i != 0 &amp;&amp; (value[i-1] != 'e' &amp;&amp; value[i-1] != 'E') </span><span class="cov0" title="0">{
                                return false
                        }</span>
                case char == 'e' || char == 'E':<span class="cov8" title="1">
                        eCount++
                        if eCount &gt; 1 || i == 0 || i == len(value)-1 </span><span class="cov0" title="0">{
                                return false // Multiple 'e' or at start/end
                        }</span>
                default:<span class="cov8" title="1">
                        return false</span> // Invalid character
                }
        }
        
        <span class="cov8" title="1">return true</span>
}

// isBooleanValue checks if a value looks like a boolean
func isBooleanValue(value string) bool <span class="cov8" title="1">{
        lower := strings.ToLower(value)
        return lower == "true" || lower == "false"
}</pre>
		
		<pre class="file" id="file26" style="display: none">package pkg

import (
        "fmt"
        "os"
        "os/user"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/charmbracelet/log"
)

// FileManager handles file operations including deployment, backup, and permission management
type FileManager struct {
        logger      *log.Logger
        dryRun      bool
        configDir   string
        interactive *InteractiveManager
}

// BackupInfo contains information about available backups
type BackupInfo struct {
        FileName       string    `json:"file_name"`
        BackupPath     string    `json:"backup_path"`
        OriginalPath   string    `json:"original_path"`
        BackupTime     time.Time `json:"backup_time"`
        BackupSize     int64     `json:"backup_size"`
        OriginalExists bool      `json:"original_exists"`
}

// NewFileManager creates a new FileManager instance
func NewFileManager(logger *log.Logger, dryRun bool, configDir string) *FileManager <span class="cov8" title="1">{
        return &amp;FileManager{
                logger:      logger,
                dryRun:      dryRun,
                configDir:   configDir,
                interactive: NewInteractiveManager(logger),
        }
}</span>

// DeployFiles processes all files in the configuration and returns deployed file info
func (fm *FileManager) DeployFiles(files map[string]config.File) ([]ManagedFile, error) <span class="cov8" title="1">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                fm.logger.Debug("No files to deploy")
                return []ManagedFile{}, nil
        }</span>

        <span class="cov8" title="1">fm.logger.Info("Processing file deployments", "count", len(files))

        var deployedFiles []ManagedFile
        for name, file := range files </span><span class="cov8" title="1">{
                managedFile, err := fm.deployFile(name, file)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to deploy file '%s': %w", name, err)
                }</span>
                <span class="cov8" title="1">deployedFiles = append(deployedFiles, managedFile)</span>
        }

        <span class="cov8" title="1">fm.logger.Info("✓ All files deployed successfully")
        return deployedFiles, nil</span>
}

// deployFile handles the deployment of a single file and returns file info
func (fm *FileManager) deployFile(name string, file config.File) (ManagedFile, error) <span class="cov8" title="1">{
        fm.logger.Debug("Deploying file", "name", name, "source", file.Source, "destination", file.Destination)

        // Resolve source path
        sourcePath, err := fm.resolveSourcePath(file.Source)
        if err != nil </span><span class="cov0" title="0">{
                return ManagedFile{}, fmt.Errorf("failed to resolve source path: %w", err)
        }</span>

        // Resolve destination path
        <span class="cov8" title="1">destPath, err := fm.resolveDestinationPath(file.Destination)
        if err != nil </span><span class="cov0" title="0">{
                return ManagedFile{}, fmt.Errorf("failed to resolve destination path: %w", err)
        }</span>

        // Check if source file exists
        <span class="cov8" title="1">if _, err := os.Stat(sourcePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return ManagedFile{}, fmt.Errorf("source file does not exist: %s", sourcePath)
        }</span>

        // Create destination directory if it doesn't exist
        <span class="cov8" title="1">destDir := filepath.Dir(destPath)
        if err := fm.ensureDirectory(destDir); err != nil </span><span class="cov0" title="0">{
                return ManagedFile{}, fmt.Errorf("failed to create destination directory: %w", err)
        }</span>

        // Handle existing file (backup if needed, with interactive support)
        <span class="cov8" title="1">backupPath, err := fm.handleExistingFile(name, destPath, sourcePath, file)
        if err != nil </span><span class="cov0" title="0">{
                return ManagedFile{}, fmt.Errorf("failed to handle existing file: %w", err)
        }</span>

        // Deploy file (either copy or symlink)
        <span class="cov8" title="1">isSymlink := !file.Copy
        if file.Copy </span><span class="cov8" title="1">{
                if err := fm.copyFile(sourcePath, destPath); err != nil </span><span class="cov0" title="0">{
                        return ManagedFile{}, fmt.Errorf("failed to copy file: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                if err := fm.createSymlink(sourcePath, destPath); err != nil </span><span class="cov0" title="0">{
                        return ManagedFile{}, fmt.Errorf("failed to create symlink: %w", err)
                }</span>
        }

        // Set ownership and permissions if specified
        <span class="cov8" title="1">if err := fm.setFileAttributes(destPath, file); err != nil </span><span class="cov0" title="0">{
                return ManagedFile{}, fmt.Errorf("failed to set file attributes: %w", err)
        }</span>

        <span class="cov8" title="1">fm.logger.Info("✓ File deployed", "name", name, "destination", destPath)
        
        // Return managed file info
        return ManagedFile{
                Name:        name,
                Destination: destPath,
                IsSymlink:   isSymlink,
                BackupPath:  backupPath,
        }, nil</span>
}

// resolveSourcePath resolves the source file path, handling relative paths
func (fm *FileManager) resolveSourcePath(source string) (string, error) <span class="cov8" title="1">{
        if filepath.IsAbs(source) </span><span class="cov8" title="1">{
                return source, nil
        }</span>

        // Relative to config directory
        <span class="cov8" title="1">return filepath.Join(fm.configDir, source), nil</span>
}

// resolveDestinationPath resolves the destination path, handling ~ expansion
func (fm *FileManager) resolveDestinationPath(destination string) (string, error) <span class="cov8" title="1">{
        if strings.HasPrefix(destination, "~/") </span><span class="cov8" title="1">{
                currentUser, err := user.Current()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to get current user: %w", err)
                }</span>
                <span class="cov8" title="1">return filepath.Join(currentUser.HomeDir, destination[2:]), nil</span>
        }

        <span class="cov8" title="1">if strings.HasPrefix(destination, "~") &amp;&amp; len(destination) &gt; 1 </span><span class="cov0" title="0">{
                // Handle ~username/ expansion
                username := destination[1:]
                if idx := strings.Index(username, "/"); idx != -1 </span><span class="cov0" title="0">{
                        username = username[:idx]
                }</span>

                <span class="cov0" title="0">targetUser, err := user.Lookup(username)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to lookup user '%s': %w", username, err)
                }</span>

                <span class="cov0" title="0">if idx := strings.Index(destination[1:], "/"); idx != -1 </span><span class="cov0" title="0">{
                        return filepath.Join(targetUser.HomeDir, destination[2+idx:]), nil
                }</span>
                <span class="cov0" title="0">return targetUser.HomeDir, nil</span>
        }

        <span class="cov8" title="1">return destination, nil</span>
}

// ensureDirectory creates the directory if it doesn't exist
func (fm *FileManager) ensureDirectory(dir string) error <span class="cov8" title="1">{
        if fm.dryRun </span><span class="cov8" title="1">{
                fm.logger.Debug("DRY RUN: Would create directory", "path", dir)
                return nil
        }</span>

        <span class="cov8" title="1">if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fm.logger.Debug("Creating directory", "path", dir)
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create directory %s: %w", dir, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// handleExistingFile handles existing files at the destination, with interactive support
// Returns the backup path if a backup was created, empty string otherwise
func (fm *FileManager) handleExistingFile(name, destPath, sourcePath string, file config.File) (string, error) <span class="cov8" title="1">{
        if _, err := os.Lstat(destPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                // File doesn't exist, nothing to handle
                return "", nil
        }</span>

        // Get file info for interactive prompts
        <span class="cov8" title="1">fileInfo, err := os.Lstat(destPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov8" title="1">isSymlink := fileInfo.Mode()&amp;os.ModeSymlink != 0

        if fm.dryRun </span><span class="cov0" title="0">{
                if file.Backup </span><span class="cov0" title="0">{
                        fm.logger.Debug("DRY RUN: Would backup existing file", "path", destPath)
                        return fmt.Sprintf("%s.backup.%s", destPath, time.Now().Format("20060102-150405")), nil
                }</span> else<span class="cov0" title="0"> {
                        fm.logger.Debug("DRY RUN: Would remove existing file", "path", destPath)
                        return "", nil
                }</span>
        }

        // Check if it's already a symlink to our source (only relevant for symlink mode)
        <span class="cov8" title="1">if isSymlink &amp;&amp; !file.Copy </span><span class="cov0" title="0">{
                if link, err := os.Readlink(destPath); err == nil </span><span class="cov0" title="0">{
                        // If it's already pointing to the right place, we're done
                        if filepath.Clean(link) == filepath.Clean(sourcePath) </span><span class="cov0" title="0">{
                                fm.logger.Debug("File already correctly symlinked", "path", destPath)
                                return "", nil
                        }</span>
                }
        }

        // Interactive conflict resolution
        <span class="cov8" title="1">if file.Interactive &amp;&amp; fm.interactive.IsInteractiveMode() </span><span class="cov0" title="0">{
                conflict := FileConflictInfo{
                        Name:            name,
                        SourcePath:      sourcePath,
                        DestinationPath: destPath,
                        ExistingInfo:    fileInfo,
                        IsSymlink:       isSymlink,
                        BackupEnabled:   file.Backup,
                }

                for </span><span class="cov0" title="0">{
                        resolution, err := fm.interactive.PromptForConflictResolution(conflict)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("failed to get user input: %w", err)
                        }</span>

                        <span class="cov0" title="0">switch resolution </span>{
                        case ResolutionSkip:<span class="cov0" title="0">
                                fm.logger.Info("⏭ Skipping file", "name", name)
                                return "", fmt.Errorf("file skipped by user: %s", name)</span>
                        case ResolutionQuit:<span class="cov0" title="0">
                                return "", fmt.Errorf("operation cancelled by user")</span>
                        case ResolutionViewDiff:<span class="cov0" title="0">
                                if err := fm.interactive.ShowFileDiff(sourcePath, destPath); err != nil </span><span class="cov0" title="0">{
                                        fm.logger.Warn("Failed to show diff", "error", err)
                                }</span>
                                <span class="cov0" title="0">continue</span> // Ask again
                        case ResolutionOverwrite:<span class="cov0" title="0">
                                break</span> // Continue with overwrite
                        case ResolutionBackup:<span class="cov0" title="0">
                                // Force backup for this file
                                break</span> // Continue with backup
                        }
                        <span class="cov0" title="0">break</span>
                }
        }

        // Determine if we should backup based on config or user choice
        <span class="cov8" title="1">shouldBackup := file.Backup
        
        if shouldBackup </span><span class="cov8" title="1">{
                backupPath := fmt.Sprintf("%s.backup.%s", destPath, time.Now().Format("20060102-150405"))
                fm.logger.Info("⚠ Backing up existing file", "from", destPath, "to", backupPath)
                
                if err := os.Rename(destPath, backupPath); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to backup file: %w", err)
                }</span>
                <span class="cov8" title="1">return backupPath, nil</span>
        } else<span class="cov8" title="1"> {
                fm.logger.Info("⚠ Removing existing file", "path", destPath)
                if err := os.Remove(destPath); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to remove existing file: %w", err)
                }</span>
                <span class="cov8" title="1">return "", nil</span>
        }
}

// createSymlink creates a symlink from source to destination
func (fm *FileManager) createSymlink(sourcePath, destPath string) error <span class="cov8" title="1">{
        if fm.dryRun </span><span class="cov8" title="1">{
                fm.logger.Debug("DRY RUN: Would create symlink", "from", sourcePath, "to", destPath)
                return nil
        }</span>

        <span class="cov8" title="1">fm.logger.Debug("Creating symlink", "from", sourcePath, "to", destPath)
        
        if err := os.Symlink(sourcePath, destPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create symlink: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// copyFile copies a file from source to destination
func (fm *FileManager) copyFile(sourcePath, destPath string) error <span class="cov8" title="1">{
        if fm.dryRun </span><span class="cov8" title="1">{
                fm.logger.Debug("DRY RUN: Would copy file", "from", sourcePath, "to", destPath)
                return nil
        }</span>

        <span class="cov8" title="1">fm.logger.Debug("Copying file", "from", sourcePath, "to", destPath)

        // Open source file
        src, err := os.Open(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open source file: %w", err)
        }</span>
        <span class="cov8" title="1">defer src.Close()

        // Create destination file
        dst, err := os.Create(destPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination file: %w", err)
        }</span>
        <span class="cov8" title="1">defer dst.Close()

        // Copy file contents
        _, err = dst.ReadFrom(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file contents: %w", err)
        }</span>

        // Sync to ensure data is written
        <span class="cov8" title="1">if err := dst.Sync(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to sync file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// setFileAttributes sets ownership and permissions on the file if specified
func (fm *FileManager) setFileAttributes(destPath string, file config.File) error <span class="cov8" title="1">{
        if fm.dryRun </span><span class="cov8" title="1">{
                fm.logger.Debug("DRY RUN: Would set file attributes", "path", destPath, "mode", file.Mode, "owner", file.Owner, "group", file.Group)
                return nil
        }</span>
        
        // Get current file info for interactive prompts
        <span class="cov8" title="1">fileInfo, err := os.Lstat(destPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get file info: %w", err)
        }</span>

        <span class="cov8" title="1">owner := file.Owner
        group := file.Group
        mode := file.Mode

        // Interactive permission prompting
        if file.PromptPermissions &amp;&amp; fm.interactive.IsInteractiveMode() </span><span class="cov0" title="0">{
                if promptedMode, err := fm.interactive.PromptForPermissions(destPath, fileInfo.Mode()); err != nil </span><span class="cov0" title="0">{
                        fm.logger.Warn("Failed to prompt for permissions", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        mode = promptedMode
                }</span>
        }

        // Interactive ownership prompting
        <span class="cov8" title="1">if file.PromptOwnership &amp;&amp; fm.interactive.IsInteractiveMode() </span><span class="cov0" title="0">{
                // Get current ownership info
                currentOwner, currentGroup := fm.getCurrentOwnership(destPath)
                
                if promptedOwner, promptedGroup, err := fm.interactive.PromptForOwnership(destPath, currentOwner, currentGroup); err != nil </span><span class="cov0" title="0">{
                        fm.logger.Warn("Failed to prompt for ownership", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        owner = promptedOwner
                        group = promptedGroup
                }</span>
        }

        // Set ownership if specified or prompted
        <span class="cov8" title="1">if owner != "" || group != "" </span><span class="cov0" title="0">{
                if err := fm.setOwnership(destPath, owner, group); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set ownership: %w", err)
                }</span>
        }

        // Set permissions if specified or prompted
        <span class="cov8" title="1">if mode != "" </span><span class="cov8" title="1">{
                if err := fm.setPermissions(destPath, mode); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set permissions: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// getCurrentOwnership gets the current owner and group names for a file
func (fm *FileManager) getCurrentOwnership(path string) (string, string) <span class="cov0" title="0">{
        _, err := os.Lstat(path)
        if err != nil </span><span class="cov0" title="0">{
                return "unknown", "unknown"
        }</span>

        // This is a simplified implementation - in practice you'd want to
        // resolve UIDs/GIDs to names using os/user package
        <span class="cov0" title="0">return "current", "current"</span>
}

// setOwnership sets the owner and group of a file
func (fm *FileManager) setOwnership(path, owner, group string) error <span class="cov0" title="0">{
        if fm.dryRun </span><span class="cov0" title="0">{
                fm.logger.Debug("DRY RUN: Would set ownership", "path", path, "owner", owner, "group", group)
                return nil
        }</span>

        <span class="cov0" title="0">var uid, gid int = -1, -1

        // Resolve owner
        if owner != "" </span><span class="cov0" title="0">{
                if u, err := user.Lookup(owner); err == nil </span><span class="cov0" title="0">{
                        if parsed, err := strconv.Atoi(u.Uid); err == nil </span><span class="cov0" title="0">{
                                uid = parsed
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Try as numeric UID
                        if parsed, err := strconv.Atoi(owner); err == nil </span><span class="cov0" title="0">{
                                uid = parsed
                        }</span> else<span class="cov0" title="0"> {
                                return fmt.Errorf("failed to lookup user '%s': %w", owner, err)
                        }</span>
                }
        }

        // Resolve group
        <span class="cov0" title="0">if group != "" </span><span class="cov0" title="0">{
                if g, err := user.LookupGroup(group); err == nil </span><span class="cov0" title="0">{
                        if parsed, err := strconv.Atoi(g.Gid); err == nil </span><span class="cov0" title="0">{
                                gid = parsed
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Try as numeric GID
                        if parsed, err := strconv.Atoi(group); err == nil </span><span class="cov0" title="0">{
                                gid = parsed
                        }</span> else<span class="cov0" title="0"> {
                                return fmt.Errorf("failed to lookup group '%s': %w", group, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">fm.logger.Debug("Setting ownership", "path", path, "uid", uid, "gid", gid)
        
        if err := os.Lchown(path, uid, gid); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to change ownership: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// setPermissions sets the file mode/permissions
func (fm *FileManager) setPermissions(path, mode string) error <span class="cov8" title="1">{
        if fm.dryRun </span><span class="cov0" title="0">{
                fm.logger.Debug("DRY RUN: Would set permissions", "path", path, "mode", mode)
                return nil
        }</span>

        // Parse octal mode
        <span class="cov8" title="1">modeInt, err := strconv.ParseUint(mode, 8, 32)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid file mode '%s': %w", mode, err)
        }</span>

        <span class="cov8" title="1">fm.logger.Debug("Setting permissions", "path", path, "mode", mode)
        
        if err := os.Chmod(path, os.FileMode(modeInt)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to change permissions: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}



// ValidateFilePermissions checks if we have the necessary permissions to deploy files
func (fm *FileManager) ValidateFilePermissions(files map[string]config.File) error <span class="cov8" title="1">{
        for name, file := range files </span><span class="cov8" title="1">{
                destPath, err := fm.resolveDestinationPath(file.Destination)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to resolve destination for '%s': %w", name, err)
                }</span>

                <span class="cov8" title="1">destDir := filepath.Dir(destPath)
                
                // Check if we can write to the destination directory
                if err := fm.checkWritePermission(destDir); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("insufficient permissions for '%s': %w", name, err)
                }</span>

                // If setting ownership, check if we're root or have appropriate capabilities
                <span class="cov8" title="1">if file.Owner != "" || file.Group != "" </span><span class="cov0" title="0">{
                        if os.Geteuid() != 0 </span><span class="cov0" title="0">{
                                fm.logger.Warn("Setting ownership requires root privileges", "file", name)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// checkWritePermission checks if we can write to a directory
func (fm *FileManager) checkWritePermission(dir string) error <span class="cov8" title="1">{
        // Create directory if it doesn't exist (for testing purposes)
        if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                testDir := dir
                for </span><span class="cov0" title="0">{
                        parent := filepath.Dir(testDir)
                        if parent == testDir || parent == "/" </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov0" title="0">if _, err := os.Stat(parent); err == nil </span><span class="cov0" title="0">{
                                // Found existing parent, check write permission
                                return fm.testWriteAccess(parent)
                        }</span>
                        <span class="cov0" title="0">testDir = parent</span>
                }
        }

        // Directory exists, check write permission
        <span class="cov8" title="1">return fm.testWriteAccess(dir)</span>
}

// testWriteAccess tests write access by attempting to create a temporary file
func (fm *FileManager) testWriteAccess(dir string) error <span class="cov8" title="1">{
        // Try to create a temporary file to test write access
        tempFile := filepath.Join(dir, ".configr-write-test")
        f, err := os.Create(tempFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("no write permission to directory %s: %w", dir, err)
        }</span>
        <span class="cov8" title="1">f.Close()
        os.Remove(tempFile) // Clean up
        return nil</span>
}

// RemoveFiles removes files that are no longer in the configuration
func (fm *FileManager) RemoveFiles(filesToRemove []ManagedFile) error <span class="cov0" title="0">{
        if len(filesToRemove) == 0 </span><span class="cov0" title="0">{
                fm.logger.Debug("No files to remove")
                return nil
        }</span>

        <span class="cov0" title="0">fm.logger.Info("Removing files no longer in configuration", "count", len(filesToRemove))

        for _, file := range filesToRemove </span><span class="cov0" title="0">{
                if err := fm.removeFile(file); err != nil </span><span class="cov0" title="0">{
                        fm.logger.Error("Failed to remove file", "name", file.Name, "destination", file.Destination, "error", err)
                        return fmt.Errorf("failed to remove file '%s': %w", file.Name, err)
                }</span>
        }

        <span class="cov0" title="0">fm.logger.Info("✓ All files removed successfully")
        return nil</span>
}

// removeFile removes a single managed file with safety checks
func (fm *FileManager) removeFile(file ManagedFile) error <span class="cov0" title="0">{
        fm.logger.Debug("Removing file", "name", file.Name, "destination", file.Destination, "is_symlink", file.IsSymlink)

        // Check if file still exists at destination
        fileInfo, err := os.Lstat(file.Destination)
        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                fm.logger.Debug("File already removed", "destination", file.Destination)
                return nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check file status: %w", err)
        }</span>

        // Safety check: verify file type matches what we expect
        <span class="cov0" title="0">isCurrentlySymlink := fileInfo.Mode()&amp;os.ModeSymlink != 0
        if isCurrentlySymlink != file.IsSymlink </span><span class="cov0" title="0">{
                fm.logger.Warn("File type changed since deployment", 
                        "destination", file.Destination, 
                        "expected_symlink", file.IsSymlink, 
                        "actual_symlink", isCurrentlySymlink)
                
                // For safety, don't remove files that changed type
                return fmt.Errorf("file type changed since deployment, skipping removal for safety: %s", file.Destination)
        }</span>

        // Additional safety check for symlinks - verify they point to expected location
        <span class="cov0" title="0">if file.IsSymlink </span><span class="cov0" title="0">{
                if err := fm.verifySymlinkSafety(file.Destination); err != nil </span><span class="cov0" title="0">{
                        fm.logger.Warn("Symlink safety check failed", "destination", file.Destination, "error", err)
                        return fmt.Errorf("symlink safety check failed, skipping removal: %w", err)
                }</span>
        }

        // For copied files, check if user has modified the file
        <span class="cov0" title="0">if !file.IsSymlink </span><span class="cov0" title="0">{
                if modified, err := fm.isFileModifiedByUser(file.Destination, file); err != nil </span><span class="cov0" title="0">{
                        fm.logger.Warn("Could not check if file was modified", "destination", file.Destination, "error", err)
                        // Continue with removal but log the warning
                }</span> else<span class="cov0" title="0"> if modified </span><span class="cov0" title="0">{
                        fm.logger.Warn("File appears to be modified by user, skipping removal for safety", "destination", file.Destination)
                        return fmt.Errorf("file appears modified by user, skipping removal for safety: %s", file.Destination)
                }</span>
        }

        <span class="cov0" title="0">if fm.dryRun </span><span class="cov0" title="0">{
                fm.logger.Info("DRY RUN: Would remove file", "destination", file.Destination)
                return nil
        }</span>

        // Perform the removal
        <span class="cov0" title="0">if err := os.Remove(file.Destination); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove file: %w", err)
        }</span>

        <span class="cov0" title="0">fm.logger.Info("✓ File removed", "name", file.Name, "destination", file.Destination)

        // If there was a backup, optionally restore it
        if file.BackupPath != "" </span><span class="cov0" title="0">{
                if err := fm.offerBackupRestore(file); err != nil </span><span class="cov0" title="0">{
                        fm.logger.Warn("Could not restore backup", "backup", file.BackupPath, "error", err)
                        // Don't fail the removal operation for backup restoration issues
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// verifySymlinkSafety checks if a symlink is safe to remove
func (fm *FileManager) verifySymlinkSafety(symlinkPath string) error <span class="cov0" title="0">{
        target, err := os.Readlink(symlinkPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read symlink: %w", err)
        }</span>

        // Basic safety check - ensure it's not pointing to system files
        <span class="cov0" title="0">if strings.HasPrefix(target, "/etc/") || strings.HasPrefix(target, "/usr/") || strings.HasPrefix(target, "/bin/") </span><span class="cov0" title="0">{
                return fmt.Errorf("symlink points to system directory, unsafe to remove: %s", target)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// isFileModifiedByUser attempts to detect if a copied file was modified by the user
func (fm *FileManager) isFileModifiedByUser(filePath string, file ManagedFile) (bool, error) <span class="cov0" title="0">{
        // This is a basic heuristic - in a full implementation, you might:
        // 1. Store checksums of deployed files
        // 2. Compare modification times
        // 3. Use more sophisticated change detection
        
        // For now, we'll be conservative and assume files might be modified
        // A more sophisticated implementation would store file hashes in the state
        
        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // If file is very recent (deployed in last few minutes), probably not modified
        <span class="cov0" title="0">if time.Since(fileInfo.ModTime()) &lt; 5*time.Minute </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        // For now, assume older copied files might have been modified
        // This is conservative but safe
        <span class="cov0" title="0">return true, nil</span>
}

// offerBackupRestore handles backup restoration when removing files
func (fm *FileManager) offerBackupRestore(file ManagedFile) error <span class="cov0" title="0">{
        // Check if backup still exists
        if _, err := os.Stat(file.BackupPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                fm.logger.Debug("Backup file no longer exists", "backup", file.BackupPath)
                return nil
        }</span>

        <span class="cov0" title="0">fm.logger.Info("📁 Backup available for removed file", "backup", file.BackupPath, "original", file.Destination)
        
        // Interactive backup restoration offer
        if fm.interactive.IsInteractiveMode() </span><span class="cov0" title="0">{
                shouldRestore, err := fm.interactive.PromptYesNo(
                        fmt.Sprintf("Restore backup for %s?", file.Name),
                        false, // default to no
                )
                if err != nil </span><span class="cov0" title="0">{
                        fm.logger.Warn("Failed to prompt for backup restoration", "error", err)
                        return nil
                }</span>
                
                <span class="cov0" title="0">if shouldRestore </span><span class="cov0" title="0">{
                        return fm.RestoreFromBackup(file.BackupPath, file.Destination)
                }</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// RestoreFromBackup restores a file from its backup
func (fm *FileManager) RestoreFromBackup(backupPath, originalDestination string) error <span class="cov0" title="0">{
        fm.logger.Info("🔄 Restoring file from backup", "backup", backupPath, "destination", originalDestination)
        
        if fm.dryRun </span><span class="cov0" title="0">{
                fm.logger.Info("DRY RUN: Would restore file from backup", "backup", backupPath, "destination", originalDestination)
                return nil
        }</span>
        
        // Check if backup exists
        <span class="cov0" title="0">if _, err := os.Stat(backupPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("backup file does not exist: %s", backupPath)
        }</span>
        
        // Create destination directory if needed
        <span class="cov0" title="0">destDir := filepath.Dir(originalDestination)
        if err := fm.ensureDirectory(destDir); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create destination directory: %w", err)
        }</span>
        
        // Remove existing file at destination if it exists
        <span class="cov0" title="0">if _, err := os.Lstat(originalDestination); err == nil </span><span class="cov0" title="0">{
                fm.logger.Debug("Removing existing file before restore", "path", originalDestination)
                if err := os.Remove(originalDestination); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to remove existing file: %w", err)
                }</span>
        }
        
        // Move backup to original location
        <span class="cov0" title="0">if err := os.Rename(backupPath, originalDestination); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restore backup: %w", err)
        }</span>
        
        <span class="cov0" title="0">fm.logger.Info("✓ File restored from backup successfully", "destination", originalDestination)
        return nil</span>
}

// RestoreAllBackups restores all available backups for managed files
func (fm *FileManager) RestoreAllBackups(managedFiles []ManagedFile) error <span class="cov0" title="0">{
        var restored, failed int
        
        for _, file := range managedFiles </span><span class="cov0" title="0">{
                if file.BackupPath == "" </span><span class="cov0" title="0">{
                        continue</span> // No backup for this file
                }
                
                // Check if backup still exists
                <span class="cov0" title="0">if _, err := os.Stat(file.BackupPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        fm.logger.Debug("Backup no longer exists", "backup", file.BackupPath)
                        continue</span>
                }
                
                // Check if original file exists (don't restore if file is still there)
                <span class="cov0" title="0">if _, err := os.Lstat(file.Destination); err == nil </span><span class="cov0" title="0">{
                        fm.logger.Debug("Original file still exists, skipping restore", "destination", file.Destination)
                        continue</span>
                }
                
                <span class="cov0" title="0">if err := fm.RestoreFromBackup(file.BackupPath, file.Destination); err != nil </span><span class="cov0" title="0">{
                        fm.logger.Error("Failed to restore backup", "file", file.Name, "backup", file.BackupPath, "error", err)
                        failed++
                }</span> else<span class="cov0" title="0"> {
                        restored++
                }</span>
        }
        
        <span class="cov0" title="0">if restored &gt; 0 </span><span class="cov0" title="0">{
                fm.logger.Info("✓ Backup restoration completed", "restored", restored, "failed", failed)
        }</span>
        
        <span class="cov0" title="0">if failed &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restore %d backup(s)", failed)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// ListBackups returns information about available backups
func (fm *FileManager) ListBackups(managedFiles []ManagedFile) []BackupInfo <span class="cov0" title="0">{
        var backups []BackupInfo
        
        for _, file := range managedFiles </span><span class="cov0" title="0">{
                if file.BackupPath == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">backupStat, err := os.Stat(file.BackupPath)
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        continue</span> // Backup doesn't exist
                }
                
                // Check if original file exists
                <span class="cov0" title="0">originalExists := true
                if _, err := os.Lstat(file.Destination); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        originalExists = false
                }</span>
                
                <span class="cov0" title="0">backup := BackupInfo{
                        FileName:       file.Name,
                        BackupPath:     file.BackupPath,
                        OriginalPath:   file.Destination,
                        BackupTime:     backupStat.ModTime(),
                        BackupSize:     backupStat.Size(),
                        OriginalExists: originalExists,
                }
                
                backups = append(backups, backup)</span>
        }
        
        <span class="cov0" title="0">return backups</span>
}

// CleanupExpiredBackups removes backups older than the specified duration
func (fm *FileManager) CleanupExpiredBackups(managedFiles []ManagedFile, maxAge time.Duration) error <span class="cov0" title="0">{
        var cleaned, failed int
        cutoffTime := time.Now().Add(-maxAge)
        
        fm.logger.Info("Cleaning up expired backups", "max_age", maxAge, "cutoff", cutoffTime.Format("2006-01-02 15:04:05"))
        
        for _, file := range managedFiles </span><span class="cov0" title="0">{
                if file.BackupPath == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">backupStat, err := os.Stat(file.BackupPath)
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        continue</span> // Backup doesn't exist
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        fm.logger.Warn("Could not stat backup file", "backup", file.BackupPath, "error", err)
                        continue</span>
                }
                
                // Check if backup is older than cutoff
                <span class="cov0" title="0">if backupStat.ModTime().Before(cutoffTime) </span><span class="cov0" title="0">{
                        if fm.dryRun </span><span class="cov0" title="0">{
                                fm.logger.Info("DRY RUN: Would remove expired backup", "backup", file.BackupPath, "age", time.Since(backupStat.ModTime()))
                                cleaned++
                                continue</span>
                        }
                        
                        <span class="cov0" title="0">fm.logger.Debug("Removing expired backup", "backup", file.BackupPath, "age", time.Since(backupStat.ModTime()))
                        if err := os.Remove(file.BackupPath); err != nil </span><span class="cov0" title="0">{
                                fm.logger.Error("Failed to remove expired backup", "backup", file.BackupPath, "error", err)
                                failed++
                        }</span> else<span class="cov0" title="0"> {
                                cleaned++
                        }</span>
                }
        }
        
        <span class="cov0" title="0">if cleaned &gt; 0 || failed &gt; 0 </span><span class="cov0" title="0">{
                fm.logger.Info("✓ Backup cleanup completed", "cleaned", cleaned, "failed", failed)
        }</span>
        
        <span class="cov0" title="0">if failed &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clean %d backup(s)", failed)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// FindOrphanedBackups finds backup files that are no longer tracked in state
func (fm *FileManager) FindOrphanedBackups(managedFiles []ManagedFile) ([]string, error) <span class="cov0" title="0">{
        var orphanedBackups []string
        
        // Get all backup paths from managed files
        knownBackups := make(map[string]bool)
        for _, file := range managedFiles </span><span class="cov0" title="0">{
                if file.BackupPath != "" </span><span class="cov0" title="0">{
                        knownBackups[file.BackupPath] = true
                }</span>
        }
        
        // Search common backup directories for orphaned backups
        <span class="cov0" title="0">searchDirs := []string{
                "~/.config",
                "~/.local",
                "~/",
        }
        
        for _, dir := range searchDirs </span><span class="cov0" title="0">{
                // Expand home directory
                if dir[0] == '~' </span><span class="cov0" title="0">{
                        homeDir, err := os.UserHomeDir()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">dir = filepath.Join(homeDir, dir[1:])</span>
                }
                
                <span class="cov0" title="0">orphaned, err := fm.searchForOrphanedBackups(dir, knownBackups)
                if err != nil </span><span class="cov0" title="0">{
                        fm.logger.Debug("Could not search for orphaned backups", "dir", dir, "error", err)
                        continue</span>
                }
                
                <span class="cov0" title="0">orphanedBackups = append(orphanedBackups, orphaned...)</span>
        }
        
        <span class="cov0" title="0">return orphanedBackups, nil</span>
}

// searchForOrphanedBackups recursively searches for backup files in a directory
func (fm *FileManager) searchForOrphanedBackups(dir string, knownBackups map[string]bool) ([]string, error) <span class="cov0" title="0">{
        var orphaned []string
        
        err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Skip directories we can't access
                }</span>
                
                // Skip directories
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                
                // Check if this looks like a configr backup file
                <span class="cov0" title="0">if fm.isLikelyConfigrBackup(path, info) &amp;&amp; !knownBackups[path] </span><span class="cov0" title="0">{
                        orphaned = append(orphaned, path)
                }</span>
                
                <span class="cov0" title="0">return nil</span>
        })
        
        <span class="cov0" title="0">return orphaned, err</span>
}

// isLikelyConfigrBackup checks if a file appears to be a configr backup
func (fm *FileManager) isLikelyConfigrBackup(path string, info os.FileInfo) bool <span class="cov0" title="0">{
        // Check for backup naming pattern: *.backup.YYYYMMDD-HHMMSS
        filename := info.Name()
        
        // Must contain ".backup." and end with timestamp pattern
        if !strings.Contains(filename, ".backup.") </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Extract timestamp part
        <span class="cov0" title="0">parts := strings.Split(filename, ".backup.")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">timestamp := parts[1]
        // Check if it matches our timestamp format: YYYYMMDD-HHMMSS
        if len(timestamp) != 15 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Basic validation of timestamp format
        <span class="cov0" title="0">if timestamp[8] != '-' </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov0" title="0">return true</span>
}

// GetBackupStatistics returns comprehensive backup statistics
func (fm *FileManager) GetBackupStatistics(managedFiles []ManagedFile) (*BackupStatistics, error) <span class="cov0" title="0">{
        stats := &amp;BackupStatistics{
                TotalBackups:    0,
                TotalSize:       0,
                OldestBackup:    time.Now(),
                NewestBackup:    time.Time{},
                BackupsByAge:    make(map[string]int),
                RestorableCount: 0,
        }
        
        now := time.Now()
        
        for _, file := range managedFiles </span><span class="cov0" title="0">{
                if file.BackupPath == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">backupInfo, err := os.Stat(file.BackupPath)
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        continue</span> // Backup doesn't exist
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip files we can't stat
                }
                
                <span class="cov0" title="0">stats.TotalBackups++
                stats.TotalSize += backupInfo.Size()
                
                // Track oldest and newest
                if backupInfo.ModTime().Before(stats.OldestBackup) </span><span class="cov0" title="0">{
                        stats.OldestBackup = backupInfo.ModTime()
                }</span>
                <span class="cov0" title="0">if backupInfo.ModTime().After(stats.NewestBackup) </span><span class="cov0" title="0">{
                        stats.NewestBackup = backupInfo.ModTime()
                }</span>
                
                // Check if restorable (original doesn't exist)
                <span class="cov0" title="0">if _, err := os.Lstat(file.Destination); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        stats.RestorableCount++
                }</span>
                
                // Categorize by age
                <span class="cov0" title="0">age := now.Sub(backupInfo.ModTime())
                switch </span>{
                case age &lt; 24*time.Hour:<span class="cov0" title="0">
                        stats.BackupsByAge["&lt; 1 day"]++</span>
                case age &lt; 7*24*time.Hour:<span class="cov0" title="0">
                        stats.BackupsByAge["&lt; 1 week"]++</span>
                case age &lt; 30*24*time.Hour:<span class="cov0" title="0">
                        stats.BackupsByAge["&lt; 1 month"]++</span>
                case age &lt; 365*24*time.Hour:<span class="cov0" title="0">
                        stats.BackupsByAge["&lt; 1 year"]++</span>
                default:<span class="cov0" title="0">
                        stats.BackupsByAge["&gt; 1 year"]++</span>
                }
        }
        
        <span class="cov0" title="0">if stats.TotalBackups == 0 </span><span class="cov0" title="0">{
                stats.OldestBackup = time.Time{}
        }</span>
        
        <span class="cov0" title="0">return stats, nil</span>
}

// CleanupOrphanedBackups removes backup files that are no longer tracked
func (fm *FileManager) CleanupOrphanedBackups(managedFiles []ManagedFile) error <span class="cov0" title="0">{
        orphaned, err := fm.FindOrphanedBackups(managedFiles)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to find orphaned backups: %w", err)
        }</span>
        
        <span class="cov0" title="0">if len(orphaned) == 0 </span><span class="cov0" title="0">{
                fm.logger.Info("No orphaned backups found")
                return nil
        }</span>
        
        <span class="cov0" title="0">fm.logger.Info("Found orphaned backups", "count", len(orphaned))
        
        var removed, failed int
        for _, backupPath := range orphaned </span><span class="cov0" title="0">{
                if fm.dryRun </span><span class="cov0" title="0">{
                        fm.logger.Info("DRY RUN: Would remove orphaned backup", "path", backupPath)
                        removed++
                        continue</span>
                }
                
                <span class="cov0" title="0">fm.logger.Debug("Removing orphaned backup", "path", backupPath)
                if err := os.Remove(backupPath); err != nil </span><span class="cov0" title="0">{
                        fm.logger.Error("Failed to remove orphaned backup", "path", backupPath, "error", err)
                        failed++
                }</span> else<span class="cov0" title="0"> {
                        removed++
                }</span>
        }
        
        <span class="cov0" title="0">fm.logger.Info("✓ Orphaned backup cleanup completed", "removed", removed, "failed", failed)
        
        if failed &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove %d orphaned backup(s)", failed)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// BackupStatistics contains comprehensive backup information
type BackupStatistics struct {
        TotalBackups    int               `json:"total_backups"`
        TotalSize       int64             `json:"total_size"`
        OldestBackup    time.Time         `json:"oldest_backup"`
        NewestBackup    time.Time         `json:"newest_backup"`
        BackupsByAge    map[string]int    `json:"backups_by_age"`
        RestorableCount int               `json:"restorable_count"`
}

// ApplyBackupPolicy enforces the configured backup policy
func (fm *FileManager) ApplyBackupPolicy(managedFiles []ManagedFile, policy config.BackupPolicy) error <span class="cov0" title="0">{
        if !policy.AutoCleanup </span><span class="cov0" title="0">{
                fm.logger.Debug("Backup policy auto-cleanup disabled")
                return nil
        }</span>

        <span class="cov0" title="0">fm.logger.Info("Applying backup policy", "max_age", policy.MaxAge, "max_count", policy.MaxCount, "cleanup_orphaned", policy.CleanupOrphaned)

        var errors []error

        // Clean up orphaned backups if enabled
        if policy.CleanupOrphaned </span><span class="cov0" title="0">{
                if err := fm.CleanupOrphanedBackups(managedFiles); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("orphaned backup cleanup failed: %w", err))
                }</span>
        }

        // Apply age-based cleanup
        <span class="cov0" title="0">if policy.MaxAge != "" </span><span class="cov0" title="0">{
                maxAge, err := fm.parseBackupAge(policy.MaxAge)
                if err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("invalid max_age in backup policy: %w", err))
                }</span> else<span class="cov0" title="0"> {
                        if err := fm.CleanupExpiredBackups(managedFiles, maxAge); err != nil </span><span class="cov0" title="0">{
                                errors = append(errors, fmt.Errorf("age-based cleanup failed: %w", err))
                        }</span>
                }
        }

        // Apply count-based cleanup
        <span class="cov0" title="0">if policy.MaxCount &gt; 0 </span><span class="cov0" title="0">{
                if err := fm.cleanupByCount(managedFiles, policy.MaxCount, policy.PreserveRecent); err != nil </span><span class="cov0" title="0">{
                        errors = append(errors, fmt.Errorf("count-based cleanup failed: %w", err))
                }</span>
        }

        <span class="cov0" title="0">if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("backup policy enforcement failed: %v", errors)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// cleanupByCount removes excess backups keeping only the most recent ones
func (fm *FileManager) cleanupByCount(managedFiles []ManagedFile, maxCount, preserveRecent int) error <span class="cov0" title="0">{
        // Group backups by original file
        fileBackups := make(map[string][]BackupInfo)
        
        for _, file := range managedFiles </span><span class="cov0" title="0">{
                if file.BackupPath == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">backupStat, err := os.Stat(file.BackupPath)
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov0" title="0">backup := BackupInfo{
                        FileName:     file.Name,
                        BackupPath:   file.BackupPath,
                        OriginalPath: file.Destination,
                        BackupTime:   backupStat.ModTime(),
                        BackupSize:   backupStat.Size(),
                }
                
                fileBackups[file.Destination] = append(fileBackups[file.Destination], backup)</span>
        }
        
        <span class="cov0" title="0">var cleaned, failed int
        
        // Process each file's backups
        for _, backups := range fileBackups </span><span class="cov0" title="0">{
                if len(backups) &lt;= maxCount </span><span class="cov0" title="0">{
                        continue</span> // No cleanup needed
                }
                
                // Sort by backup time (newest first)
                <span class="cov0" title="0">for i := 0; i &lt; len(backups)-1; i++ </span><span class="cov0" title="0">{
                        for j := i + 1; j &lt; len(backups); j++ </span><span class="cov0" title="0">{
                                if backups[i].BackupTime.Before(backups[j].BackupTime) </span><span class="cov0" title="0">{
                                        backups[i], backups[j] = backups[j], backups[i]
                                }</span>
                        }
                }
                
                // Determine how many to preserve
                <span class="cov0" title="0">preserveCount := maxCount
                if preserveRecent &gt; preserveCount </span><span class="cov0" title="0">{
                        preserveCount = preserveRecent
                }</span>
                
                // Remove excess backups
                <span class="cov0" title="0">for i := preserveCount; i &lt; len(backups); i++ </span><span class="cov0" title="0">{
                        backup := backups[i]
                        
                        if fm.dryRun </span><span class="cov0" title="0">{
                                fm.logger.Info("DRY RUN: Would remove excess backup", 
                                        "file", backup.FileName, 
                                        "backup", backup.BackupPath,
                                        "age", time.Since(backup.BackupTime))
                                cleaned++
                                continue</span>
                        }
                        
                        <span class="cov0" title="0">fm.logger.Debug("Removing excess backup", 
                                "file", backup.FileName, 
                                "backup", backup.BackupPath, 
                                "age", time.Since(backup.BackupTime))
                                
                        if err := os.Remove(backup.BackupPath); err != nil </span><span class="cov0" title="0">{
                                fm.logger.Error("Failed to remove excess backup", "backup", backup.BackupPath, "error", err)
                                failed++
                        }</span> else<span class="cov0" title="0"> {
                                cleaned++
                        }</span>
                }
        }
        
        <span class="cov0" title="0">if cleaned &gt; 0 || failed &gt; 0 </span><span class="cov0" title="0">{
                fm.logger.Info("✓ Count-based backup cleanup completed", "cleaned", cleaned, "failed", failed)
        }</span>
        
        <span class="cov0" title="0">if failed &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clean %d backup(s)", failed)
        }</span>
        
        <span class="cov0" title="0">return nil</span>
}

// parseBackupAge parses duration strings for backup policies
func (fm *FileManager) parseBackupAge(ageStr string) (time.Duration, error) <span class="cov0" title="0">{
        // Handle common suffixes
        switch </span>{
        case len(ageStr) == 0:<span class="cov0" title="0">
                return 0, fmt.Errorf("empty duration")</span>
        case ageStr[len(ageStr)-1] == 'd':<span class="cov0" title="0">
                // Days - convert to hours
                daysStr := ageStr[:len(ageStr)-1]
                days, err := time.ParseDuration(daysStr + "h")
                if err != nil </span><span class="cov0" title="0">{
                        return 0, err
                }</span>
                <span class="cov0" title="0">return days * 24, nil</span>
        default:<span class="cov0" title="0">
                // Standard Go duration parsing
                return time.ParseDuration(ageStr)</span>
        }
}</pre>
		
		<pre class="file" id="file27" style="display: none">package pkg

import (
        "fmt"
        "os/exec"
        "strings"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/charmbracelet/log"
)

// FlatpakManager handles Flatpak package management operations
type FlatpakManager struct {
        logger *log.Logger
        dryRun bool
}

// NewFlatpakManager creates a new Flatpak manager
func NewFlatpakManager(logger *log.Logger, dryRun bool) *FlatpakManager <span class="cov8" title="1">{
        return &amp;FlatpakManager{
                logger: logger,
                dryRun: dryRun,
        }
}</span>

// InstallPackages installs Flatpak applications
func (fm *FlatpakManager) InstallPackages(packages []config.PackageEntry, packageDefaults map[string][]string) error <span class="cov8" title="1">{
        if len(packages) == 0 </span><span class="cov8" title="1">{
                fm.logger.Debug("No Flatpak packages to install")
                return nil
        }</span>

        <span class="cov8" title="1">fm.logger.Info("Managing Flatpak packages...", "count", len(packages))

        // Check if flatpak is available (skip in dry-run for testing)
        if !fm.dryRun </span><span class="cov0" title="0">{
                if err := fm.checkFlatpakAvailable(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("flatpak not available: %w", err)
                }</span>
        }

        // Group packages by resolved flags to minimize system calls
        <span class="cov8" title="1">packageGroups := fm.groupPackagesByFlags(packages, packageDefaults)

        for _, group := range packageGroups </span><span class="cov8" title="1">{
                if err := fm.installPackageGroup(group, packageDefaults); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to install Flatpak package group: %w", err)
                }</span>
        }

        <span class="cov8" title="1">fm.logger.Info("✓ Flatpak packages processed successfully")
        return nil</span>
}

// groupPackagesByFlags groups packages by their resolved flags to optimize installation
func (fm *FlatpakManager) groupPackagesByFlags(packages []config.PackageEntry, packageDefaults map[string][]string) [][]config.PackageEntry <span class="cov8" title="1">{
        flagGroups := make(map[string][]config.PackageEntry)

        for _, pkg := range packages </span><span class="cov8" title="1">{
                flags := fm.resolvePackageFlags(pkg, packageDefaults)
                flagKey := strings.Join(flags, "|")
                flagGroups[flagKey] = append(flagGroups[flagKey], pkg)
        }</span>

        <span class="cov8" title="1">var groups [][]config.PackageEntry
        for _, group := range flagGroups </span><span class="cov8" title="1">{
                groups = append(groups, group)
        }</span>

        <span class="cov8" title="1">return groups</span>
}

// resolvePackageFlags implements the three-tier flag resolution system
func (fm *FlatpakManager) resolvePackageFlags(pkg config.PackageEntry, packageDefaults map[string][]string) []string <span class="cov8" title="1">{
        // Tier 3: Per-package flags (highest priority)
        if pkg.Flags != nil </span><span class="cov8" title="1">{
                return pkg.Flags
        }</span>

        // Tier 2: User package defaults
        <span class="cov8" title="1">if userDefaults, exists := packageDefaults["flatpak"]; exists </span><span class="cov8" title="1">{
                return userDefaults
        }</span>

        // Tier 1: Internal defaults
        <span class="cov8" title="1">return config.GetDefaultFlags("flatpak")</span>
}

// installPackageGroup installs a group of packages with the same flags
func (fm *FlatpakManager) installPackageGroup(packages []config.PackageEntry, packageDefaults map[string][]string) error <span class="cov8" title="1">{
        if len(packages) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get flags from the first package (all packages in group have same flags)
        <span class="cov8" title="1">flags := fm.resolvePackageFlags(packages[0], packageDefaults)

        // Check if packages are already installed to avoid reinstalling
        var packagesToInstall []string
        for _, pkg := range packages </span><span class="cov8" title="1">{
                if fm.dryRun </span><span class="cov8" title="1">{
                        // In dry-run, assume package needs installation
                        packagesToInstall = append(packagesToInstall, pkg.Name)
                }</span> else<span class="cov0" title="0"> {
                        installed, err := fm.isPackageInstalled(pkg.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                fm.logger.Warn("Failed to check if Flatpak package is installed", "package", pkg.Name, "error", err)
                                // Assume not installed and try to install
                                packagesToInstall = append(packagesToInstall, pkg.Name)
                        }</span> else<span class="cov0" title="0"> if !installed </span><span class="cov0" title="0">{
                                packagesToInstall = append(packagesToInstall, pkg.Name)
                        }</span> else<span class="cov0" title="0"> {
                                fm.logger.Debug("Flatpak package already installed", "package", pkg.Name)
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(packagesToInstall) == 0 </span><span class="cov0" title="0">{
                fm.logger.Debug("All Flatpak packages in group already installed")
                return nil
        }</span>

        // Build the flatpak install command
        <span class="cov8" title="1">args := []string{"flatpak", "install"}
        args = append(args, flags...)
        args = append(args, packagesToInstall...)

        fm.logger.Info("Installing Flatpak packages", "packages", packagesToInstall, "flags", flags)

        if fm.dryRun </span><span class="cov8" title="1">{
                fm.logger.Info("  [DRY RUN] Would run:", "command", strings.Join(args, " "))
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                fm.logger.Error("Failed to install Flatpak packages", "packages", packagesToInstall, "error", err, "output", string(output))
                return fmt.Errorf("flatpak install failed: %w", err)
        }</span>

        <span class="cov0" title="0">fm.logger.Debug("Flatpak packages installed successfully", "packages", packagesToInstall, "output", string(output))
        return nil</span>
}

// isPackageInstalled checks if a Flatpak package is already installed
func (fm *FlatpakManager) isPackageInstalled(packageName string) (bool, error) <span class="cov0" title="0">{
        // Check both system and user installations
        systemInstalled, err := fm.isPackageInstalledInScope(packageName, "--system")
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">userInstalled, err := fm.isPackageInstalledInScope(packageName, "--user")
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return systemInstalled || userInstalled, nil</span>
}

// isPackageInstalledInScope checks if a package is installed in a specific scope (system or user)
func (fm *FlatpakManager) isPackageInstalledInScope(packageName, scope string) (bool, error) <span class="cov8" title="1">{
        args := []string{"flatpak", "list", scope, "--app", "--columns=application"}
        cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                // If flatpak list fails, it might be because no packages are installed
                // or the scope doesn't exist, so we assume the package is not installed
                return false, nil
        }</span>

        <span class="cov8" title="1">installedPackages := strings.Split(string(output), "\n")
        for _, installed := range installedPackages </span><span class="cov8" title="1">{
                if strings.TrimSpace(installed) == packageName </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}

// UninstallPackage removes a Flatpak application
func (fm *FlatpakManager) UninstallPackage(packageName string, flags []string) error <span class="cov8" title="1">{
        args := []string{"flatpak", "uninstall"}
        args = append(args, flags...)
        args = append(args, packageName)

        fm.logger.Info("Uninstalling Flatpak package", "package", packageName, "flags", flags)

        if fm.dryRun </span><span class="cov8" title="1">{
                fm.logger.Info("  [DRY RUN] Would run:", "command", strings.Join(args, " "))
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                fm.logger.Error("Failed to uninstall Flatpak package", "package", packageName, "error", err, "output", string(output))
                return fmt.Errorf("flatpak uninstall failed: %w", err)
        }</span>

        <span class="cov0" title="0">fm.logger.Debug("Flatpak package uninstalled successfully", "package", packageName, "output", string(output))
        return nil</span>
}

// ListInstalledPackages returns a list of installed Flatpak applications
func (fm *FlatpakManager) ListInstalledPackages() ([]string, error) <span class="cov8" title="1">{
        if fm.dryRun </span><span class="cov8" title="1">{
                fm.logger.Info("  [DRY RUN] Would run:", "command", "flatpak list --app --columns=application")
                return []string{}, nil
        }</span>

        <span class="cov0" title="0">args := []string{"flatpak", "list", "--app", "--columns=application"}
        cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                fm.logger.Error("Failed to list Flatpak packages", "error", err, "output", string(output))
                return nil, fmt.Errorf("flatpak list failed: %w", err)
        }</span>

        <span class="cov0" title="0">var packages []string
        lines := strings.Split(strings.TrimSpace(string(output)), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line != "" &amp;&amp; line != "Application ID" </span><span class="cov0" title="0">{ // Skip header
                        packages = append(packages, line)
                }</span>
        }

        <span class="cov0" title="0">fm.logger.Debug("Listed Flatpak packages", "count", len(packages))
        return packages, nil</span>
}

// UpdatePackages updates all installed Flatpak applications
func (fm *FlatpakManager) UpdatePackages(flags []string) error <span class="cov8" title="1">{
        args := []string{"flatpak", "update"}
        args = append(args, flags...)

        fm.logger.Info("Updating Flatpak packages", "flags", flags)

        if fm.dryRun </span><span class="cov8" title="1">{
                fm.logger.Info("  [DRY RUN] Would run:", "command", strings.Join(args, " "))
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                fm.logger.Error("Failed to update Flatpak packages", "error", err, "output", string(output))
                return fmt.Errorf("flatpak update failed: %w", err)
        }</span>

        <span class="cov0" title="0">fm.logger.Debug("Flatpak packages updated successfully", "output", string(output))
        return nil</span>
}

// checkFlatpakAvailable checks if flatpak command is available
func (fm *FlatpakManager) checkFlatpakAvailable() error <span class="cov8" title="1">{
        if _, err := exec.LookPath("flatpak"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flatpak command not found - install flatpak package")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// RemovePackages removes multiple Flatpak applications that are no longer in the configuration
func (fm *FlatpakManager) RemovePackages(packagesToRemove []string) error <span class="cov0" title="0">{
        if len(packagesToRemove) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">fm.logger.Info("Removing Flatpak packages no longer in configuration", "packages", packagesToRemove)

        // Filter to only remove packages that are actually installed
        installedToRemove := make([]string, 0, len(packagesToRemove))
        for _, pkg := range packagesToRemove </span><span class="cov0" title="0">{
                if installed, err := fm.isPackageInstalled(pkg); err != nil </span><span class="cov0" title="0">{
                        fm.logger.Warn("Could not check if Flatpak package is installed", "package", pkg, "error", err)
                }</span> else<span class="cov0" title="0"> if installed </span><span class="cov0" title="0">{
                        installedToRemove = append(installedToRemove, pkg)
                }</span>
        }

        <span class="cov0" title="0">if len(installedToRemove) == 0 </span><span class="cov0" title="0">{
                fm.logger.Info("No installed Flatpak packages to remove")
                return nil
        }</span>

        // Remove packages one by one (more reliable than batch removal)
        <span class="cov0" title="0">for _, pkg := range installedToRemove </span><span class="cov0" title="0">{
                if err := fm.UninstallPackage(pkg, []string{"--assumeyes"}); err != nil </span><span class="cov0" title="0">{
                        fm.logger.Error("Failed to remove Flatpak package", "package", pkg, "error", err)
                        return fmt.Errorf("failed to remove Flatpak package %s: %w", pkg, err)
                }</span>
                <span class="cov0" title="0">config.Success("Removed Flatpak package: %s", pkg)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidatePackageNames validates Flatpak package names (application IDs)
func (fm *FlatpakManager) ValidatePackageNames(packages []config.PackageEntry) error <span class="cov8" title="1">{
        fm.logger.Debug("Validating Flatpak package names", "count", len(packages))

        for _, pkg := range packages </span><span class="cov8" title="1">{
                if err := fm.validatePackageName(pkg.Name); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid Flatpak package name '%s': %w", pkg.Name, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validatePackageName validates a single Flatpak application ID
func (fm *FlatpakManager) validatePackageName(packageName string) error <span class="cov8" title="1">{
        // Flatpak application IDs should follow reverse domain notation
        // e.g., org.mozilla.Firefox, com.spotify.Client
        if packageName == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("package name cannot be empty")
        }</span>

        // Basic validation for reverse domain notation
        <span class="cov8" title="1">parts := strings.Split(packageName, ".")
        if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("Flatpak application ID should use reverse domain notation (e.g., org.mozilla.Firefox)")
        }</span>

        // Check for invalid characters
        <span class="cov8" title="1">for _, part := range parts </span><span class="cov8" title="1">{
                if part == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("application ID parts cannot be empty")
                }</span>
                <span class="cov8" title="1">for _, char := range part </span><span class="cov8" title="1">{
                        if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= 'A' &amp;&amp; char &lt;= 'Z') || 
                                 (char &gt;= '0' &amp;&amp; char &lt;= '9') || char == '-' || char == '_') </span><span class="cov8" title="1">{
                                return fmt.Errorf("application ID contains invalid character: %c", char)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// SearchPackages searches for Flatpak applications using flatpak search
func (fm *FlatpakManager) SearchPackages(searchTerm string) ([]string, error) <span class="cov0" title="0">{
        if searchTerm == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("search term cannot be empty")
        }</span>

        <span class="cov0" title="0">if fm.dryRun </span><span class="cov0" title="0">{
                fm.logger.Info("DRY RUN: Would search for packages", "term", searchTerm)
                return []string{}, nil
        }</span>

        // Check if flatpak is available
        <span class="cov0" title="0">if err := fm.checkFlatpakAvailable(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("flatpak not available: %w", err)
        }</span>

        <span class="cov0" title="0">args := []string{"flatpak", "search", searchTerm}
        cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                fm.logger.Error("Failed to search Flatpak packages", "search", searchTerm, "error", err, "output", string(output))
                return nil, fmt.Errorf("flatpak search failed: %w", err)
        }</span>

        <span class="cov0" title="0">var packages []string
        lines := strings.Split(string(output), "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line == "" || strings.HasPrefix(line, "Name") || strings.HasPrefix(line, "-----") </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Flatpak search output is tabular: Name Description Application ID Version Branch Remote
                <span class="cov0" title="0">fields := strings.Fields(line)
                if len(fields) &gt;= 3 </span><span class="cov0" title="0">{
                        // Application ID is usually the third field
                        appID := fields[2]
                        if strings.Contains(appID, ".") </span><span class="cov0" title="0">{ // Basic check for reverse domain notation
                                packages = append(packages, appID)
                        }</span>
                }
        }

        <span class="cov0" title="0">fm.logger.Debug("Found Flatpak packages", "search", searchTerm, "count", len(packages))
        return packages, nil</span>
}

// GetPackageInfo returns detailed information about a Flatpak application
func (fm *FlatpakManager) GetPackageInfo(packageName string) (string, error) <span class="cov0" title="0">{
        if packageName == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("package name cannot be empty")
        }</span>

        <span class="cov0" title="0">if fm.dryRun </span><span class="cov0" title="0">{
                fm.logger.Info("DRY RUN: Would get package info", "package", packageName)
                return "", nil
        }</span>

        // Check if flatpak is available
        <span class="cov0" title="0">if err := fm.checkFlatpakAvailable(); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("flatpak not available: %w", err)
        }</span>

        <span class="cov0" title="0">args := []string{"flatpak", "info", packageName}
        cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                fm.logger.Error("Failed to get Flatpak package info", "package", packageName, "error", err, "output", string(output))
                return "", fmt.Errorf("flatpak info failed for package %s: %w", packageName, err)
        }</span>

        <span class="cov0" title="0">return string(output), nil</span>
}</pre>
		
		<pre class="file" id="file28" style="display: none">package pkg

import (
        "bufio"
        "fmt"
        "os"
        "os/exec"
        "strings"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/charmbracelet/log"
)

// InteractiveManager handles interactive features like prompts and file diffs
type InteractiveManager struct {
        logger *log.Logger
        reader *bufio.Reader
}

// NewInteractiveManager creates a new InteractiveManager instance
func NewInteractiveManager(logger *log.Logger) *InteractiveManager <span class="cov8" title="1">{
        return &amp;InteractiveManager{
                logger: logger,
                reader: bufio.NewReader(os.Stdin),
        }
}</span>

// ConflictResolution represents the user's choice for conflict resolution
type ConflictResolution int

const (
        ResolutionSkip ConflictResolution = iota
        ResolutionOverwrite
        ResolutionBackup
        ResolutionViewDiff
        ResolutionQuit
)

// FileConflictInfo contains information about a file conflict
type FileConflictInfo struct {
        Name           string
        SourcePath     string
        DestinationPath string
        ExistingInfo   os.FileInfo
        IsSymlink      bool
        BackupEnabled  bool
}

// PromptForConflictResolution prompts the user to resolve a file conflict
func (im *InteractiveManager) PromptForConflictResolution(conflict FileConflictInfo) (ConflictResolution, error) <span class="cov0" title="0">{
        im.logger.Info("📁 File conflict detected", "file", conflict.Name, "destination", conflict.DestinationPath)
        
        // Show file information
        if conflict.IsSymlink </span><span class="cov0" title="0">{
                target, err := os.Readlink(conflict.DestinationPath)
                if err != nil </span><span class="cov0" title="0">{
                        im.logger.Warn("Could not read symlink target", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        im.logger.Info("  Current: symlink → %s", target)
                }</span>
        } else<span class="cov0" title="0"> {
                im.logger.Info("  Current: regular file (modified %s)", conflict.ExistingInfo.ModTime().Format("2006-01-02 15:04:05"))
        }</span>
        
        <span class="cov0" title="0">im.logger.Info("  New: %s", conflict.SourcePath)
        
        fmt.Print("\nHow would you like to proceed?\n")
        fmt.Print("  [o] Overwrite existing file\n")
        if conflict.BackupEnabled </span><span class="cov0" title="0">{
                fmt.Print("  [b] Backup existing file and overwrite\n")
        }</span>
        <span class="cov0" title="0">fmt.Print("  [d] Show diff between files\n")
        fmt.Print("  [s] Skip this file\n")
        fmt.Print("  [q] Quit configuration\n")
        fmt.Print("\nChoice: ")

        input, err := im.reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return ResolutionQuit, fmt.Errorf("failed to read user input: %w", err)
        }</span>

        <span class="cov0" title="0">choice := strings.ToLower(strings.TrimSpace(input))
        switch choice </span>{
        case "o", "overwrite":<span class="cov0" title="0">
                return ResolutionOverwrite, nil</span>
        case "b", "backup":<span class="cov0" title="0">
                if conflict.BackupEnabled </span><span class="cov0" title="0">{
                        return ResolutionBackup, nil
                }</span>
                <span class="cov0" title="0">im.logger.Warn("Backup is not enabled for this file")
                return im.PromptForConflictResolution(conflict)</span> // Ask again
        case "d", "diff":<span class="cov0" title="0">
                return ResolutionViewDiff, nil</span>
        case "s", "skip":<span class="cov0" title="0">
                return ResolutionSkip, nil</span>
        case "q", "quit":<span class="cov0" title="0">
                return ResolutionQuit, nil</span>
        default:<span class="cov0" title="0">
                im.logger.Warn("Invalid choice: %s", choice)
                return im.PromptForConflictResolution(conflict)</span> // Ask again
        }
}

// ShowFileDiff displays a diff between source and destination files
func (im *InteractiveManager) ShowFileDiff(sourcePath, destPath string) error <span class="cov8" title="1">{
        im.logger.Info("📊 Showing diff between files")
        fmt.Printf("\n--- %s\n+++ %s\n", destPath, sourcePath)
        
        // Try to use diff command first
        if err := im.showSystemDiff(destPath, sourcePath); err != nil </span><span class="cov0" title="0">{
                im.logger.Debug("System diff failed, using built-in diff", "error", err)
                return im.showBuiltinDiff(destPath, sourcePath)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// showSystemDiff uses the system diff command
func (im *InteractiveManager) showSystemDiff(file1, file2 string) error <span class="cov8" title="1">{
        cmd := exec.Command("diff", "-u", file1, file2)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        
        // diff returns exit code 1 when files differ, which is normal
        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                if exitError, ok := err.(*exec.ExitError); ok </span><span class="cov8" title="1">{
                        if exitError.ExitCode() == 1 </span><span class="cov8" title="1">{
                                return nil // Files differ, but diff succeeded
                        }</span>
                }
                <span class="cov0" title="0">return err</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// showBuiltinDiff provides a basic built-in diff implementation
func (im *InteractiveManager) showBuiltinDiff(file1, file2 string) error <span class="cov0" title="0">{
        content1, err := os.ReadFile(file1)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read %s: %w", file1, err)
        }</span>
        
        <span class="cov0" title="0">content2, err := os.ReadFile(file2)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read %s: %w", file2, err)
        }</span>
        
        <span class="cov0" title="0">lines1 := strings.Split(string(content1), "\n")
        lines2 := strings.Split(string(content2), "\n")
        
        // Simple line-by-line comparison
        maxLines := len(lines1)
        if len(lines2) &gt; maxLines </span><span class="cov0" title="0">{
                maxLines = len(lines2)
        }</span>
        
        <span class="cov0" title="0">for i := 0; i &lt; maxLines; i++ </span><span class="cov0" title="0">{
                var line1, line2 string
                if i &lt; len(lines1) </span><span class="cov0" title="0">{
                        line1 = lines1[i]
                }</span>
                <span class="cov0" title="0">if i &lt; len(lines2) </span><span class="cov0" title="0">{
                        line2 = lines2[i]
                }</span>
                
                <span class="cov0" title="0">if line1 != line2 </span><span class="cov0" title="0">{
                        if line1 != "" </span><span class="cov0" title="0">{
                                fmt.Printf("-%s\n", line1)
                        }</span>
                        <span class="cov0" title="0">if line2 != "" </span><span class="cov0" title="0">{
                                fmt.Printf("+%s\n", line2)
                        }</span>
                }
        }
        
        <span class="cov0" title="0">return nil</span>
}

// PromptYesNo prompts the user for a yes/no question
func (im *InteractiveManager) PromptYesNo(question string, defaultYes bool) (bool, error) <span class="cov0" title="0">{
        defaultStr := "y/N"
        if defaultYes </span><span class="cov0" title="0">{
                defaultStr = "Y/n"
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("%s [%s]: ", question, defaultStr)
        
        input, err := im.reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to read user input: %w", err)
        }</span>
        
        <span class="cov0" title="0">response := strings.ToLower(strings.TrimSpace(input))
        if response == "" </span><span class="cov0" title="0">{
                return defaultYes, nil
        }</span>
        
        <span class="cov0" title="0">switch response </span>{
        case "y", "yes", "true", "1":<span class="cov0" title="0">
                return true, nil</span>
        case "n", "no", "false", "0":<span class="cov0" title="0">
                return false, nil</span>
        default:<span class="cov0" title="0">
                im.logger.Warn("Please answer yes or no")
                return im.PromptYesNo(question, defaultYes)</span>
        }
}

// PromptForPermissions prompts for file permissions with validation
func (im *InteractiveManager) PromptForPermissions(fileName string, currentMode os.FileMode) (string, error) <span class="cov0" title="0">{
        currentOctal := fmt.Sprintf("%04o", currentMode.Perm())
        
        fmt.Printf("Current permissions for %s: %s (%s)\n", fileName, currentMode.String(), currentOctal)
        fmt.Print("Enter new permissions (octal, e.g., 644, 755) or press Enter to keep current: ")
        
        input, err := im.reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read user input: %w", err)
        }</span>
        
        <span class="cov0" title="0">mode := strings.TrimSpace(input)
        if mode == "" </span><span class="cov0" title="0">{
                return currentOctal, nil
        }</span>
        
        // Validate octal format
        <span class="cov0" title="0">if err := im.validateOctalPermissions(mode); err != nil </span><span class="cov0" title="0">{
                im.logger.Warn("Invalid permissions: %v", err)
                return im.PromptForPermissions(fileName, currentMode)
        }</span>
        
        <span class="cov0" title="0">return mode, nil</span>
}

// validateOctalPermissions validates that a string is a valid octal permission
func (im *InteractiveManager) validateOctalPermissions(mode string) error <span class="cov8" title="1">{
        if len(mode) &lt; 3 || len(mode) &gt; 4 </span><span class="cov8" title="1">{
                return fmt.Errorf("permissions must be 3 or 4 digits")
        }</span>
        
        <span class="cov8" title="1">for _, char := range mode </span><span class="cov8" title="1">{
                if char &lt; '0' || char &gt; '7' </span><span class="cov8" title="1">{
                        return fmt.Errorf("permissions must contain only octal digits (0-7)")
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// PromptForOwnership prompts for file ownership
func (im *InteractiveManager) PromptForOwnership(fileName, currentOwner, currentGroup string) (string, string, error) <span class="cov0" title="0">{
        fmt.Printf("Current ownership for %s: %s:%s\n", fileName, currentOwner, currentGroup)
        
        fmt.Print("Enter new owner (username or UID) or press Enter to keep current: ")
        ownerInput, err := im.reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to read owner input: %w", err)
        }</span>
        
        <span class="cov0" title="0">newOwner := strings.TrimSpace(ownerInput)
        if newOwner == "" </span><span class="cov0" title="0">{
                newOwner = currentOwner
        }</span>
        
        <span class="cov0" title="0">fmt.Print("Enter new group (groupname or GID) or press Enter to keep current: ")
        groupInput, err := im.reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("failed to read group input: %w", err)
        }</span>
        
        <span class="cov0" title="0">newGroup := strings.TrimSpace(groupInput)
        if newGroup == "" </span><span class="cov0" title="0">{
                newGroup = currentGroup
        }</span>
        
        <span class="cov0" title="0">return newOwner, newGroup, nil</span>
}

// ShowPreviewSummary shows a summary of all changes that will be made
func (im *InteractiveManager) ShowPreviewSummary(files map[string]config.File, conflicts []FileConflictInfo) error <span class="cov0" title="0">{
        fmt.Print("\n" + strings.Repeat("=", 60) + "\n")
        fmt.Print("CONFIGURATION PREVIEW\n")
        fmt.Print(strings.Repeat("=", 60) + "\n\n")
        
        // Show files to be deployed
        if len(files) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Files to be deployed (%d):\n", len(files))
                for name, file := range files </span><span class="cov0" title="0">{
                        action := "symlink"
                        if file.Copy </span><span class="cov0" title="0">{
                                action = "copy"
                        }</span>
                        
                        <span class="cov0" title="0">fmt.Printf("  • %s: %s → %s (%s)\n", name, file.Source, file.Destination, action)
                        
                        if file.Owner != "" || file.Group != "" </span><span class="cov0" title="0">{
                                fmt.Printf("    ownership: %s:%s\n", file.Owner, file.Group)
                        }</span>
                        <span class="cov0" title="0">if file.Mode != "" </span><span class="cov0" title="0">{
                                fmt.Printf("    permissions: %s\n", file.Mode)
                        }</span>
                        <span class="cov0" title="0">if file.Backup </span><span class="cov0" title="0">{
                                fmt.Print("    backup: enabled\n")
                        }</span>
                }
                <span class="cov0" title="0">fmt.Print("\n")</span>
        }
        
        // Show conflicts
        <span class="cov0" title="0">if len(conflicts) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Conflicts detected (%d):\n", len(conflicts))
                for _, conflict := range conflicts </span><span class="cov0" title="0">{
                        fmt.Printf("  ⚠ %s: %s (exists)\n", conflict.Name, conflict.DestinationPath)
                }</span>
                <span class="cov0" title="0">fmt.Print("\n")</span>
        }
        
        <span class="cov0" title="0">fmt.Print(strings.Repeat("=", 60) + "\n")
        return nil</span>
}

// WaitForUser waits for user to press Enter to continue
func (im *InteractiveManager) WaitForUser(message string) error <span class="cov0" title="0">{
        if message == "" </span><span class="cov0" title="0">{
                message = "Press Enter to continue..."
        }</span>
        
        <span class="cov0" title="0">fmt.Print(message)
        _, err := im.reader.ReadString('\n')
        return err</span>
}

// IsInteractiveMode checks if we're running in an interactive terminal
func (im *InteractiveManager) IsInteractiveMode() bool <span class="cov8" title="1">{
        // Check if stdin is a terminal
        stat, err := os.Stdin.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        
        <span class="cov8" title="1">return (stat.Mode() &amp; os.ModeCharDevice) != 0</span>
}</pre>
		
		<pre class="file" id="file29" style="display: none">package pkg

import (
        "fmt"
        "time"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/charmbracelet/log"
)

// OptimizedAptManager extends AptManager with caching capabilities
type OptimizedAptManager struct {
        *AptManager
        cache *CacheManager
}

// NewOptimizedAptManager creates a new optimized APT manager with caching
func NewOptimizedAptManager(logger *log.Logger, dryRun bool, cache *CacheManager) *OptimizedAptManager <span class="cov8" title="1">{
        return &amp;OptimizedAptManager{
                AptManager: NewAptManager(logger, dryRun),
                cache:      cache,
        }
}</span>

// InstallPackagesOptimized installs APT packages with cache optimization
func (oam *OptimizedAptManager) InstallPackagesOptimized(packages []config.PackageEntry, packageDefaults map[string][]string) error <span class="cov0" title="0">{
        if len(packages) == 0 </span><span class="cov0" title="0">{
                oam.logger.Debug("No APT packages to install")
                return nil
        }</span>

        <span class="cov0" title="0">oam.logger.Info("Managing APT packages with optimization...", "count", len(packages))

        // Check if apt is available
        if err := oam.checkAptAvailable(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("apt not available: %w", err)
        }</span>

        // Load system state cache
        <span class="cov0" title="0">systemCache, err := oam.cache.LoadSystemStateCache()
        if err != nil </span><span class="cov0" title="0">{
                oam.logger.Warn("Failed to load system cache, falling back to standard mode", "error", err)
                return oam.InstallPackages(packages, packageDefaults)
        }</span>

        // Use cached state if available, otherwise build new cache
        <span class="cov0" title="0">var packageState PackageInstallationState
        if systemCache != nil </span><span class="cov0" title="0">{
                packageState = systemCache.PackageState
                oam.logger.Debug("Using cached package state", "cache_age", time.Since(systemCache.LastChecked))
        }</span> else<span class="cov0" title="0"> {
                packageState = PackageInstallationState{
                        AptPackages: make(map[string]PackageCacheEntry),
                        LastUpdated: time.Now(),
                }
        }</span>

        // Group packages by their resolved flags
        <span class="cov0" title="0">flagGroups := oam.groupPackagesByFlags(packages, packageDefaults)

        packagesInstalled := 0
        for flagsKey, packageGroup := range flagGroups </span><span class="cov0" title="0">{
                flags := oam.parseFlags(flagsKey)
                
                // Filter packages that need installation using cache
                packagesToInstall, cacheUpdates := oam.filterPackagesForInstallation(packageGroup, packageState.AptPackages)
                
                if len(packagesToInstall) == 0 </span><span class="cov0" title="0">{
                        oam.logger.Debug("All packages in group already installed (cached)", "flags", flags)
                        continue</span>
                }

                <span class="cov0" title="0">oam.logger.Info("Installing APT packages", 
                        "to_install", len(packagesToInstall), 
                        "cached_skipped", len(packageGroup)-len(packagesToInstall),
                        "flags", flags)

                // Install the packages that need installation
                if err := oam.installPackageGroupOptimized(packagesToInstall, flags); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to install APT packages: %w", err)
                }</span>

                // Update cache with installation results
                <span class="cov0" title="0">for _, pkg := range packagesToInstall </span><span class="cov0" title="0">{
                        packageState.AptPackages[pkg.Name] = PackageCacheEntry{
                                Name:        pkg.Name,
                                Installed:   true,
                                LastChecked: time.Now(),
                        }
                }</span>

                // Update cache with packages we checked but didn't need to install
                <span class="cov0" title="0">for pkgName, entry := range cacheUpdates </span><span class="cov0" title="0">{
                        packageState.AptPackages[pkgName] = entry
                }</span>

                <span class="cov0" title="0">packagesInstalled += len(packagesToInstall)</span>
        }

        // Save updated cache
        <span class="cov0" title="0">if systemCache == nil </span><span class="cov0" title="0">{
                systemCache = &amp;SystemStateCache{
                        PackageState: packageState,
                }
        }</span> else<span class="cov0" title="0"> {
                systemCache.PackageState = packageState
        }</span>

        <span class="cov0" title="0">if err := oam.cache.SaveSystemStateCache(systemCache); err != nil </span><span class="cov0" title="0">{
                oam.logger.Warn("Failed to save system cache", "error", err)
        }</span>

        <span class="cov0" title="0">if packagesInstalled &gt; 0 </span><span class="cov0" title="0">{
                oam.logger.Info("✓ APT packages installed with optimization", 
                        "installed", packagesInstalled, 
                        "total", len(packages))
        }</span> else<span class="cov0" title="0"> {
                oam.logger.Info("✓ All APT packages already installed (cache hit)")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// filterPackagesForInstallation determines which packages need installation using cache
func (oam *OptimizedAptManager) filterPackagesForInstallation(packages []config.PackageEntry, aptCache map[string]PackageCacheEntry) ([]config.PackageEntry, map[string]PackageCacheEntry) <span class="cov0" title="0">{
        var packagesToInstall []config.PackageEntry
        cacheUpdates := make(map[string]PackageCacheEntry)

        for _, pkg := range packages </span><span class="cov0" title="0">{
                // Check cache first
                if cachedEntry, exists := aptCache[pkg.Name]; exists </span><span class="cov0" title="0">{
                        // If cached as installed and cache is recent, skip
                        if cachedEntry.Installed &amp;&amp; time.Since(cachedEntry.LastChecked) &lt; 10*time.Minute </span><span class="cov0" title="0">{
                                oam.logger.Debug("Package installation status cached", "package", pkg.Name, "installed", true)
                                continue</span>
                        }
                }

                // If not in cache or cache is stale, check actual installation status
                <span class="cov0" title="0">if !oam.dryRun </span><span class="cov0" title="0">{
                        isInstalled, err := oam.isPackageInstalled(pkg.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                oam.logger.Warn("Failed to check package installation status", "package", pkg.Name, "error", err)
                                // If we can't check, assume it needs installation
                                packagesToInstall = append(packagesToInstall, pkg)
                                continue</span>
                        }

                        // Update cache with current status
                        <span class="cov0" title="0">cacheUpdates[pkg.Name] = PackageCacheEntry{
                                Name:        pkg.Name,
                                Installed:   isInstalled,
                                LastChecked: time.Now(),
                        }

                        if !isInstalled </span><span class="cov0" title="0">{
                                packagesToInstall = append(packagesToInstall, pkg)
                        }</span> else<span class="cov0" title="0"> {
                                oam.logger.Debug("Package already installed", "package", pkg.Name)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // In dry-run mode, assume package needs installation for preview
                        packagesToInstall = append(packagesToInstall, pkg)
                }</span>
        }

        <span class="cov0" title="0">return packagesToInstall, cacheUpdates</span>
}

// installPackageGroupOptimized installs a group of packages with optimizations
func (oam *OptimizedAptManager) installPackageGroupOptimized(packages []config.PackageEntry, flags []string) error <span class="cov0" title="0">{
        packageNames := make([]string, len(packages))
        localDebFiles := make([]string, 0)
        
        for i, pkg := range packages </span><span class="cov0" title="0">{
                packageNames[i] = pkg.Name
                
                // Check if this is a local .deb file
                if oam.isLocalDebFile(pkg.Name) </span><span class="cov0" title="0">{
                        localDebFiles = append(localDebFiles, pkg.Name)
                }</span>
        }

        // Handle local .deb files separately (these can't be cached easily)
        <span class="cov0" title="0">if len(localDebFiles) &gt; 0 </span><span class="cov0" title="0">{
                if err := oam.installLocalDebFiles(localDebFiles, flags); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // Remove local files from regular package installation
                <span class="cov0" title="0">packageNames = oam.filterOutLocalFiles(packageNames)</span>
        }

        // Install regular packages from repositories
        <span class="cov0" title="0">if len(packageNames) &gt; 0 </span><span class="cov0" title="0">{
                if err := oam.installRepositoryPackagesOptimized(packageNames, flags); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// installRepositoryPackagesOptimized installs repository packages with optimizations
func (oam *OptimizedAptManager) installRepositoryPackagesOptimized(packageNames []string, flags []string) error <span class="cov0" title="0">{
        if len(packageNames) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Build apt install command (packages are already filtered for installation)
        <span class="cov0" title="0">args := append([]string{"install"}, flags...)
        args = append(args, packageNames...)

        oam.logger.Info("Installing APT packages (optimized)", "packages", packageNames, "flags", flags)

        if oam.dryRun </span><span class="cov0" title="0">{
                oam.logger.Debug("DRY RUN: Would run apt command", "args", args)
                return nil
        }</span>

        // Execute installation
        <span class="cov0" title="0">if err := oam.executeAptCommand(args); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to install packages %v: %w", packageNames, err)
        }</span>

        <span class="cov0" title="0">for _, pkg := range packageNames </span><span class="cov0" title="0">{
                config.Success("Installed package: %s", pkg)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// executeAptCommand executes an apt command with proper error handling
func (oam *OptimizedAptManager) executeAptCommand(args []string) error <span class="cov0" title="0">{
        // This would execute the actual apt command
        // For now, we'll simulate the command execution
        oam.logger.Debug("Executing apt command", "args", args)
        
        // In a real implementation, this would use exec.Command
        // cmd := exec.Command("apt", args...)
        // cmd.Stdout = os.Stdout
        // cmd.Stderr = os.Stderr
        // return cmd.Run()
        
        return nil
}</span>

// parseFlags parses the flags key back into a slice
func (oam *OptimizedAptManager) parseFlags(flagsKey string) []string <span class="cov0" title="0">{
        if flagsKey == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>
        // This is a simple implementation - the original uses "|" as separator
        // but we'd need to import strings to split properly
        <span class="cov0" title="0">return []string{flagsKey}</span> // Simplified for now
}

// InvalidatePackageCache invalidates cached package state for specific packages
func (oam *OptimizedAptManager) InvalidatePackageCache(packageNames []string) error <span class="cov0" title="0">{
        systemCache, err := oam.cache.LoadSystemStateCache()
        if err != nil || systemCache == nil </span><span class="cov0" title="0">{
                return nil // No cache to invalidate
        }</span>

        <span class="cov0" title="0">for _, pkgName := range packageNames </span><span class="cov0" title="0">{
                delete(systemCache.PackageState.AptPackages, pkgName)
        }</span>

        <span class="cov0" title="0">return oam.cache.SaveSystemStateCache(systemCache)</span>
}</pre>
		
		<pre class="file" id="file30" style="display: none">package pkg

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/charmbracelet/log"
        "github.com/spf13/viper"
        "gopkg.in/yaml.v3"
)

// OptimizedLoader handles configuration loading with caching optimization
type OptimizedLoader struct {
        logger *log.Logger
        cache  *CacheManager
}

// NewOptimizedLoader creates a new optimized configuration loader
func NewOptimizedLoader(logger *log.Logger, cache *CacheManager) *OptimizedLoader <span class="cov8" title="1">{
        return &amp;OptimizedLoader{
                logger: logger,
                cache:  cache,
        }
}</span>

// LoadConfigurationOptimized loads configuration with caching optimization
func (ol *OptimizedLoader) LoadConfigurationOptimized(configPath string) (*config.Config, []string, error) <span class="cov0" title="0">{
        startTime := time.Now()
        ol.logger.Debug("Loading configuration with optimization", "config_path", configPath)

        // Resolve the main config path
        resolvedPath, err := ol.resolveConfigPath(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to resolve config path: %w", err)
        }</span>

        // Collect all config paths (including includes)
        <span class="cov0" title="0">configPaths, err := ol.collectAllConfigPaths(resolvedPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to collect config paths: %w", err)
        }</span>

        // Try to load from cache first
        <span class="cov0" title="0">cachedConfig, err := ol.cache.LoadCachedConfig(configPaths)
        if err != nil </span><span class="cov0" title="0">{
                ol.logger.Warn("Failed to load cached config, falling back to standard loading", "error", err)
        }</span>

        <span class="cov0" title="0">if cachedConfig != nil </span><span class="cov0" title="0">{
                loadTime := time.Since(startTime)
                ol.logger.Info("✓ Configuration loaded from cache", 
                        "load_time", loadTime,
                        "files", len(configPaths),
                        "cache_age", time.Since(cachedConfig.CachedAt))
                return cachedConfig.Config, configPaths, nil
        }</span>

        // Cache miss - load configuration normally
        <span class="cov0" title="0">ol.logger.Debug("Cache miss, loading configuration from files", "files", len(configPaths))
        
        // Set the main config file in viper
        viper.SetConfigFile(resolvedPath)
        if err := viper.ReadInConfig(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        // Load configuration with advanced includes
        <span class="cov0" title="0">advancedLoader := config.NewAdvancedLoader()
        configResult, actualPaths, err := advancedLoader.LoadConfigurationAdvanced(resolvedPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to load config with includes: %w", err)
        }</span>
        
        // Update configPaths with actually loaded paths
        <span class="cov0" title="0">configPaths = actualPaths

        // Cache the loaded configuration
        if err := ol.cache.SaveCachedConfig(configResult, configPaths); err != nil </span><span class="cov0" title="0">{
                ol.logger.Warn("Failed to cache configuration", "error", err)
                // Don't fail the operation for caching issues
        }</span>

        <span class="cov0" title="0">loadTime := time.Since(startTime)
        ol.logger.Info("✓ Configuration loaded and cached", 
                "load_time", loadTime,
                "files", len(configPaths))

        return configResult, configPaths, nil</span>
}

// resolveConfigPath resolves the configuration file path
func (ol *OptimizedLoader) resolveConfigPath(configPath string) (string, error) <span class="cov0" title="0">{
        if configPath != "" </span><span class="cov0" title="0">{
                // Explicit path provided
                abs, err := filepath.Abs(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to resolve absolute path: %w", err)
                }</span>
                <span class="cov0" title="0">return abs, nil</span>
        }

        // Use viper's config file discovery
        <span class="cov0" title="0">if viper.ConfigFileUsed() != "" </span><span class="cov0" title="0">{
                return viper.ConfigFileUsed(), nil
        }</span>

        // Fall back to standard search locations
        <span class="cov0" title="0">searchPaths := []string{
                "./configr.yaml",
                "~/.config/configr/configr.yaml",
                "~/configr.yaml",
                "/etc/configr/configr.yaml",
                "/usr/local/etc/configr/configr.yaml",
        }

        for _, path := range searchPaths </span><span class="cov0" title="0">{
                // Expand ~ if present
                if path[0] == '~' </span><span class="cov0" title="0">{
                        home, err := os.UserHomeDir()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">path = filepath.Join(home, path[1:])</span>
                }

                <span class="cov0" title="0">if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        abs, err := filepath.Abs(path)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return abs, nil</span>
                }
        }

        <span class="cov0" title="0">return "", fmt.Errorf("no config file found in standard locations")</span>
}

// collectAllConfigPaths collects all configuration file paths including includes
func (ol *OptimizedLoader) collectAllConfigPaths(mainConfigPath string) ([]string, error) <span class="cov0" title="0">{
        paths := []string{mainConfigPath}
        visited := make(map[string]bool)
        visited[mainConfigPath] = true

        // Parse the main config to find includes
        includePaths, err := ol.extractIncludePaths(mainConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                ol.logger.Warn("Failed to extract include paths", "error", err)
                return paths, nil // Return what we have
        }</span>

        // Recursively collect include paths
        <span class="cov0" title="0">if err := ol.collectIncludePaths(includePaths, filepath.Dir(mainConfigPath), &amp;paths, visited); err != nil </span><span class="cov0" title="0">{
                ol.logger.Warn("Failed to collect all include paths", "error", err)
        }</span>

        <span class="cov0" title="0">return paths, nil</span>
}

// extractIncludePaths extracts include paths from a configuration file
func (ol *OptimizedLoader) extractIncludePaths(configPath string) ([]string, error) <span class="cov0" title="0">{
        // Parse the config file to get include specs
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var configData config.Config
        if err := yaml.Unmarshal(data, &amp;configData); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Extract paths from include specs
        <span class="cov0" title="0">var paths []string
        for _, spec := range configData.Includes </span><span class="cov0" title="0">{
                if spec.Path != "" </span><span class="cov0" title="0">{
                        paths = append(paths, spec.Path)
                }</span>
        }
        
        <span class="cov0" title="0">return paths, nil</span>
}

// collectIncludePaths recursively collects include file paths
func (ol *OptimizedLoader) collectIncludePaths(includes []string, baseDir string, allPaths *[]string, visited map[string]bool) error <span class="cov0" title="0">{
        for _, include := range includes </span><span class="cov0" title="0">{
                // Convert include path to absolute
                var includePath string
                if filepath.IsAbs(include) </span><span class="cov0" title="0">{
                        includePath = include
                }</span> else<span class="cov0" title="0"> {
                        includePath = filepath.Join(baseDir, include)
                }</span>

                // Handle directory includes (load default.yaml)
                <span class="cov0" title="0">if info, err := os.Stat(includePath); err == nil &amp;&amp; info.IsDir() </span><span class="cov0" title="0">{
                        includePath = filepath.Join(includePath, "default.yaml")
                }</span> else<span class="cov0" title="0"> if !strings.HasSuffix(includePath, ".yaml") &amp;&amp; !strings.HasSuffix(includePath, ".yml") </span><span class="cov0" title="0">{
                        // Try adding .yaml extension
                        if _, err := os.Stat(includePath + ".yaml"); err == nil </span><span class="cov0" title="0">{
                                includePath = includePath + ".yaml"
                        }</span>
                }

                // Convert to absolute path
                <span class="cov0" title="0">absPath, err := filepath.Abs(includePath)
                if err != nil </span><span class="cov0" title="0">{
                        ol.logger.Warn("Failed to resolve include path", "path", includePath, "error", err)
                        continue</span>
                }

                // Check for circular includes
                <span class="cov0" title="0">if visited[absPath] </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Check if file exists
                <span class="cov0" title="0">if _, err := os.Stat(absPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                        ol.logger.Warn("Include file not found", "path", absPath)
                        continue</span>
                }

                // Add to paths and mark as visited
                <span class="cov0" title="0">*allPaths = append(*allPaths, absPath)
                visited[absPath] = true

                // Recursively process includes in this file
                nestedIncludes, err := ol.extractIncludePaths(absPath)
                if err != nil </span><span class="cov0" title="0">{
                        ol.logger.Warn("Failed to extract nested includes", "path", absPath, "error", err)
                        continue</span>
                }

                <span class="cov0" title="0">if len(nestedIncludes) &gt; 0 </span><span class="cov0" title="0">{
                        if err := ol.collectIncludePaths(nestedIncludes, filepath.Dir(absPath), allPaths, visited); err != nil </span><span class="cov0" title="0">{
                                ol.logger.Warn("Failed to collect nested includes", "error", err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// InvalidateConfigCache invalidates cached configuration
func (ol *OptimizedLoader) InvalidateConfigCache(configPaths []string) error <span class="cov0" title="0">{
        ol.logger.Debug("Invalidating config cache", "paths", configPaths)
        
        // For now, we'll clear the entire cache since individual file invalidation
        // is complex with includes. A more sophisticated implementation could
        // track which cached configs depend on which files.
        return ol.cache.ClearCache()
}</span>

// GetCacheStats returns cache statistics
func (ol *OptimizedLoader) GetCacheStats() (*CacheStats, error) <span class="cov0" title="0">{
        return ol.cache.GetCacheStats()
}</pre>
		
		<pre class="file" id="file31" style="display: none">package pkg

import (
        "fmt"
        "os/exec"
        "strings"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/charmbracelet/log"
)

// RepositoryManager handles repository management operations for APT and Flatpak
type RepositoryManager struct {
        logger *log.Logger
        dryRun bool
}

// NewRepositoryManager creates a new repository manager
func NewRepositoryManager(logger *log.Logger, dryRun bool) *RepositoryManager <span class="cov8" title="1">{
        return &amp;RepositoryManager{
                logger: logger,
                dryRun: dryRun,
        }
}</span>

// AddRepositories adds both APT and Flatpak repositories
func (rm *RepositoryManager) AddRepositories(repositories config.RepositoryManagement) error <span class="cov8" title="1">{
        // Add APT repositories first (they may be needed for package installations)
        if err := rm.addAptRepositories(repositories.Apt); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add APT repositories: %w", err)
        }</span>

        // Add Flatpak repositories
        <span class="cov8" title="1">if err := rm.addFlatpakRepositories(repositories.Flatpak); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add Flatpak repositories: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// addAptRepositories handles APT repository management
func (rm *RepositoryManager) addAptRepositories(repos []config.AptRepository) error <span class="cov8" title="1">{
        if len(repos) == 0 </span><span class="cov8" title="1">{
                rm.logger.Debug("No APT repositories to add")
                return nil
        }</span>

        <span class="cov8" title="1">rm.logger.Info("Managing APT repositories...", "count", len(repos))

        // Check if add-apt-repository is available (skip in dry-run for testing)
        if !rm.dryRun </span><span class="cov0" title="0">{
                if err := rm.checkAddAptRepositoryAvailable(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("add-apt-repository not available: %w", err)
                }</span>
        }

        <span class="cov8" title="1">for _, repo := range repos </span><span class="cov8" title="1">{
                if err := rm.addAptRepository(repo); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add APT repository '%s': %w", repo.Name, err)
                }</span>
        }

        <span class="cov8" title="1">rm.logger.Info("✓ APT repositories processed successfully")
        return nil</span>
}

// addAptRepository adds a single APT repository
func (rm *RepositoryManager) addAptRepository(repo config.AptRepository) error <span class="cov8" title="1">{
        // Handle PPA repositories
        if repo.PPA != "" </span><span class="cov8" title="1">{
                return rm.addPPARepository(repo)
        }</span>

        // Handle custom URI repositories
        <span class="cov8" title="1">if repo.URI != "" </span><span class="cov8" title="1">{
                return rm.addCustomRepository(repo)
        }</span>

        <span class="cov8" title="1">return fmt.Errorf("repository '%s' has no PPA or URI specified", repo.Name)</span>
}

// addPPARepository adds a PPA repository using add-apt-repository
func (rm *RepositoryManager) addPPARepository(repo config.AptRepository) error <span class="cov8" title="1">{
        ppaArg := fmt.Sprintf("ppa:%s", repo.PPA)
        args := []string{"add-apt-repository", "-y", ppaArg}

        rm.logger.Info("Adding PPA repository", "name", repo.Name, "ppa", repo.PPA)

        if rm.dryRun </span><span class="cov8" title="1">{
                rm.logger.Info("  [DRY RUN] Would run:", "command", fmt.Sprintf("sudo %s", strings.Join(args, " ")))
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("sudo", args...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                rm.logger.Error("Failed to add PPA repository", "name", repo.Name, "error", err, "output", string(output))
                return fmt.Errorf("add-apt-repository failed: %w", err)
        }</span>

        <span class="cov0" title="0">rm.logger.Debug("PPA repository added successfully", "name", repo.Name, "output", string(output))
        return nil</span>
}

// addCustomRepository adds a custom repository with optional GPG key
func (rm *RepositoryManager) addCustomRepository(repo config.AptRepository) error <span class="cov8" title="1">{
        rm.logger.Info("Adding custom APT repository", "name", repo.Name, "uri", repo.URI)

        // Add GPG key first if provided
        if repo.Key != "" </span><span class="cov8" title="1">{
                if err := rm.addGPGKey(repo.Key, repo.Name); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add GPG key for repository '%s': %w", repo.Name, err)
                }</span>
        }

        // Add the repository
        <span class="cov8" title="1">args := []string{"add-apt-repository", "-y", repo.URI}

        if rm.dryRun </span><span class="cov8" title="1">{
                rm.logger.Info("  [DRY RUN] Would run:", "command", fmt.Sprintf("sudo %s", strings.Join(args, " ")))
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("sudo", args...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                rm.logger.Error("Failed to add custom repository", "name", repo.Name, "error", err, "output", string(output))
                return fmt.Errorf("add-apt-repository failed: %w", err)
        }</span>

        <span class="cov0" title="0">rm.logger.Debug("Custom repository added successfully", "name", repo.Name, "output", string(output))
        return nil</span>
}

// addGPGKey adds a GPG key for repository authentication
func (rm *RepositoryManager) addGPGKey(key, repoName string) error <span class="cov8" title="1">{
        rm.logger.Info("Adding GPG key", "repo", repoName, "key", key)

        if rm.dryRun </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, "https://") </span><span class="cov8" title="1">{
                        rm.logger.Info("  [DRY RUN] Would run:", "command", fmt.Sprintf("wget -qO- %s | sudo apt-key add -", key))
                }</span> else<span class="cov8" title="1"> {
                        rm.logger.Info("  [DRY RUN] Would run:", "command", fmt.Sprintf("sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys %s", strings.TrimPrefix(key, "0x")))
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov0" title="0">var cmd *exec.Cmd
        var cmdDescription string

        if strings.HasPrefix(key, "https://") </span><span class="cov0" title="0">{
                // Handle URL-based keys
                cmdDescription = fmt.Sprintf("wget -qO- %s | sudo apt-key add -", key)
                cmd = exec.Command("bash", "-c", cmdDescription)
        }</span> else<span class="cov0" title="0"> {
                // Handle keyserver-based keys
                keyID := strings.TrimPrefix(key, "0x")
                args := []string{"apt-key", "adv", "--keyserver", "keyserver.ubuntu.com", "--recv-keys", keyID}
                cmdDescription = fmt.Sprintf("sudo %s", strings.Join(args, " "))
                cmd = exec.Command("sudo", args...)
        }</span>

        <span class="cov0" title="0">output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                rm.logger.Error("Failed to add GPG key", "repo", repoName, "key", key, "error", err, "output", string(output))
                return fmt.Errorf("GPG key installation failed: %w", err)
        }</span>

        <span class="cov0" title="0">rm.logger.Debug("GPG key added successfully", "repo", repoName, "output", string(output))
        return nil</span>
}

// addFlatpakRepositories handles Flatpak repository management
func (rm *RepositoryManager) addFlatpakRepositories(repos []config.FlatpakRepository) error <span class="cov8" title="1">{
        if len(repos) == 0 </span><span class="cov8" title="1">{
                rm.logger.Debug("No Flatpak repositories to add")
                return nil
        }</span>

        <span class="cov8" title="1">rm.logger.Info("Managing Flatpak repositories...", "count", len(repos))

        // Check if flatpak is available (skip in dry-run for testing)
        if !rm.dryRun </span><span class="cov0" title="0">{
                if err := rm.checkFlatpakAvailable(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("flatpak not available: %w", err)
                }</span>
        }

        <span class="cov8" title="1">for _, repo := range repos </span><span class="cov8" title="1">{
                if err := rm.addFlatpakRepository(repo); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add Flatpak repository '%s': %w", repo.Name, err)
                }</span>
        }

        <span class="cov8" title="1">rm.logger.Info("✓ Flatpak repositories processed successfully")
        return nil</span>
}

// addFlatpakRepository adds a single Flatpak repository
func (rm *RepositoryManager) addFlatpakRepository(repo config.FlatpakRepository) error <span class="cov8" title="1">{
        args := []string{"flatpak", "remote-add", "--if-not-exists"}

        // Add user or system flag
        if repo.User </span><span class="cov8" title="1">{
                args = append(args, "--user")
        }</span> else<span class="cov8" title="1"> {
                args = append(args, "--system")
        }</span>

        <span class="cov8" title="1">args = append(args, repo.Name, repo.URL)

        rm.logger.Info("Adding Flatpak repository", "name", repo.Name, "url", repo.URL, "user", repo.User)

        if rm.dryRun </span><span class="cov8" title="1">{
                rm.logger.Info("  [DRY RUN] Would run:", "command", strings.Join(args, " "))
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                rm.logger.Error("Failed to add Flatpak repository", "name", repo.Name, "error", err, "output", string(output))
                return fmt.Errorf("flatpak remote-add failed: %w", err)
        }</span>

        <span class="cov0" title="0">rm.logger.Debug("Flatpak repository added successfully", "name", repo.Name, "output", string(output))
        return nil</span>
}

// checkAddAptRepositoryAvailable checks if add-apt-repository command is available
func (rm *RepositoryManager) checkAddAptRepositoryAvailable() error <span class="cov8" title="1">{
        if _, err := exec.LookPath("add-apt-repository"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("add-apt-repository command not found - install software-properties-common package")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// checkFlatpakAvailable checks if flatpak command is available
func (rm *RepositoryManager) checkFlatpakAvailable() error <span class="cov8" title="1">{
        if _, err := exec.LookPath("flatpak"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("flatpak command not found - install flatpak package")
        }</span>
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file32" style="display: none">package pkg

import (
        "fmt"
        "os/exec"
        "strings"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/charmbracelet/log"
)

// SnapManager handles Snap package management operations
type SnapManager struct {
        logger *log.Logger
        dryRun bool
}

// NewSnapManager creates a new Snap manager
func NewSnapManager(logger *log.Logger, dryRun bool) *SnapManager <span class="cov8" title="1">{
        return &amp;SnapManager{
                logger: logger,
                dryRun: dryRun,
        }
}</span>

// InstallPackages installs Snap packages
func (sm *SnapManager) InstallPackages(packages []config.PackageEntry, packageDefaults map[string][]string) error <span class="cov8" title="1">{
        if len(packages) == 0 </span><span class="cov8" title="1">{
                sm.logger.Debug("No Snap packages to install")
                return nil
        }</span>

        <span class="cov8" title="1">sm.logger.Info("Managing Snap packages...", "count", len(packages))

        // Check if snap is available (skip in dry-run for testing)
        if !sm.dryRun </span><span class="cov0" title="0">{
                if err := sm.checkSnapAvailable(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("snap not available: %w", err)
                }</span>
        }

        // Group packages by resolved flags to minimize system calls
        <span class="cov8" title="1">packageGroups := sm.groupPackagesByFlags(packages, packageDefaults)

        for _, group := range packageGroups </span><span class="cov8" title="1">{
                if err := sm.installPackageGroup(group, packageDefaults); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to install Snap package group: %w", err)
                }</span>
        }

        <span class="cov8" title="1">sm.logger.Info("✓ Snap packages processed successfully")
        return nil</span>
}

// groupPackagesByFlags groups packages by their resolved flags to optimize installation
func (sm *SnapManager) groupPackagesByFlags(packages []config.PackageEntry, packageDefaults map[string][]string) [][]config.PackageEntry <span class="cov8" title="1">{
        flagGroups := make(map[string][]config.PackageEntry)

        for _, pkg := range packages </span><span class="cov8" title="1">{
                flags := sm.resolvePackageFlags(pkg, packageDefaults)
                flagKey := strings.Join(flags, "|")
                flagGroups[flagKey] = append(flagGroups[flagKey], pkg)
        }</span>

        <span class="cov8" title="1">var groups [][]config.PackageEntry
        for _, group := range flagGroups </span><span class="cov8" title="1">{
                groups = append(groups, group)
        }</span>

        <span class="cov8" title="1">return groups</span>
}

// resolvePackageFlags implements the three-tier flag resolution system
func (sm *SnapManager) resolvePackageFlags(pkg config.PackageEntry, packageDefaults map[string][]string) []string <span class="cov8" title="1">{
        // Tier 3: Per-package flags (highest priority)
        if pkg.Flags != nil </span><span class="cov8" title="1">{
                return pkg.Flags
        }</span>

        // Tier 2: User package defaults
        <span class="cov8" title="1">if userDefaults, exists := packageDefaults["snap"]; exists </span><span class="cov8" title="1">{
                return userDefaults
        }</span>

        // Tier 1: Internal defaults
        <span class="cov8" title="1">return config.GetDefaultFlags("snap")</span>
}

// installPackageGroup installs a group of packages with the same flags
func (sm *SnapManager) installPackageGroup(packages []config.PackageEntry, packageDefaults map[string][]string) error <span class="cov8" title="1">{
        if len(packages) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get flags from the first package (all packages in group have same flags)
        <span class="cov8" title="1">flags := sm.resolvePackageFlags(packages[0], packageDefaults)

        // Check if packages are already installed to avoid reinstalling
        var packagesToInstall []string
        for _, pkg := range packages </span><span class="cov8" title="1">{
                if sm.dryRun </span><span class="cov8" title="1">{
                        // In dry-run, assume package needs installation
                        packagesToInstall = append(packagesToInstall, pkg.Name)
                }</span> else<span class="cov0" title="0"> {
                        installed, err := sm.isPackageInstalled(pkg.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                sm.logger.Warn("Failed to check if Snap package is installed", "package", pkg.Name, "error", err)
                                // Assume not installed and try to install
                                packagesToInstall = append(packagesToInstall, pkg.Name)
                        }</span> else<span class="cov0" title="0"> if !installed </span><span class="cov0" title="0">{
                                packagesToInstall = append(packagesToInstall, pkg.Name)
                        }</span> else<span class="cov0" title="0"> {
                                sm.logger.Debug("Snap package already installed", "package", pkg.Name)
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(packagesToInstall) == 0 </span><span class="cov0" title="0">{
                sm.logger.Debug("All Snap packages in group already installed")
                return nil
        }</span>

        // Install packages one by one (snap install doesn't support multiple packages in one command)
        <span class="cov8" title="1">for _, packageName := range packagesToInstall </span><span class="cov8" title="1">{
                if err := sm.installSinglePackage(packageName, flags); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to install Snap package '%s': %w", packageName, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// installSinglePackage installs a single Snap package
func (sm *SnapManager) installSinglePackage(packageName string, flags []string) error <span class="cov8" title="1">{
        args := []string{"snap", "install"}
        args = append(args, flags...)
        args = append(args, packageName)

        sm.logger.Info("Installing Snap package", "package", packageName, "flags", flags)

        if sm.dryRun </span><span class="cov8" title="1">{
                sm.logger.Info("  [DRY RUN] Would run:", "command", strings.Join(args, " "))
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Failed to install Snap package", "package", packageName, "error", err, "output", string(output))
                return fmt.Errorf("snap install failed: %w", err)
        }</span>

        <span class="cov0" title="0">sm.logger.Debug("Snap package installed successfully", "package", packageName, "output", string(output))
        return nil</span>
}

// isPackageInstalled checks if a Snap package is already installed
func (sm *SnapManager) isPackageInstalled(packageName string) (bool, error) <span class="cov8" title="1">{
        args := []string{"snap", "list", packageName}
        cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov8" title="1">{
                // If snap list fails, the package is likely not installed
                // snap list returns non-zero exit code for non-installed packages
                return false, nil
        }</span>

        // Check if the output contains the package name
        <span class="cov0" title="0">outputStr := string(output)
        lines := strings.Split(outputStr, "\n")
        for _, line := range lines </span><span class="cov0" title="0">{
                if strings.HasPrefix(strings.TrimSpace(line), packageName+" ") || 
                   strings.TrimSpace(line) == packageName </span><span class="cov0" title="0">{
                        return true, nil
                }</span>
        }

        <span class="cov0" title="0">return false, nil</span>
}

// UninstallPackage removes a Snap package
func (sm *SnapManager) UninstallPackage(packageName string, flags []string) error <span class="cov8" title="1">{
        args := []string{"snap", "remove"}
        args = append(args, flags...)
        args = append(args, packageName)

        sm.logger.Info("Uninstalling Snap package", "package", packageName, "flags", flags)

        if sm.dryRun </span><span class="cov8" title="1">{
                sm.logger.Info("  [DRY RUN] Would run:", "command", strings.Join(args, " "))
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Failed to uninstall Snap package", "package", packageName, "error", err, "output", string(output))
                return fmt.Errorf("snap remove failed: %w", err)
        }</span>

        <span class="cov0" title="0">sm.logger.Debug("Snap package uninstalled successfully", "package", packageName, "output", string(output))
        return nil</span>
}

// ListInstalledPackages returns a list of installed Snap packages
func (sm *SnapManager) ListInstalledPackages() ([]string, error) <span class="cov8" title="1">{
        if sm.dryRun </span><span class="cov8" title="1">{
                sm.logger.Info("  [DRY RUN] Would run:", "command", "snap list")
                return []string{}, nil
        }</span>

        <span class="cov0" title="0">args := []string{"snap", "list"}
        cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Failed to list Snap packages", "error", err, "output", string(output))
                return nil, fmt.Errorf("snap list failed: %w", err)
        }</span>

        <span class="cov0" title="0">var packages []string
        lines := strings.Split(string(output), "\n")
        for i, line := range lines </span><span class="cov0" title="0">{
                // Skip header line and empty lines
                if i == 0 || strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Extract package name (first column)
                <span class="cov0" title="0">fields := strings.Fields(line)
                if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                        packages = append(packages, fields[0])
                }</span>
        }

        <span class="cov0" title="0">sm.logger.Debug("Listed Snap packages", "count", len(packages))
        return packages, nil</span>
}

// RefreshPackages updates all installed Snap packages
func (sm *SnapManager) RefreshPackages(flags []string) error <span class="cov8" title="1">{
        args := []string{"snap", "refresh"}
        args = append(args, flags...)

        sm.logger.Info("Refreshing Snap packages", "flags", flags)

        if sm.dryRun </span><span class="cov8" title="1">{
                sm.logger.Info("  [DRY RUN] Would run:", "command", strings.Join(args, " "))
                return nil
        }</span>

        <span class="cov0" title="0">cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Failed to refresh Snap packages", "error", err, "output", string(output))
                return fmt.Errorf("snap refresh failed: %w", err)
        }</span>

        <span class="cov0" title="0">sm.logger.Debug("Snap packages refreshed successfully", "output", string(output))
        return nil</span>
}

// InfoPackage gets information about a Snap package
func (sm *SnapManager) InfoPackage(packageName string) (string, error) <span class="cov8" title="1">{
        if sm.dryRun </span><span class="cov8" title="1">{
                sm.logger.Info("  [DRY RUN] Would run:", "command", fmt.Sprintf("snap info %s", packageName))
                return "", nil
        }</span>

        <span class="cov0" title="0">args := []string{"snap", "info", packageName}
        cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Failed to get Snap package info", "package", packageName, "error", err, "output", string(output))
                return "", fmt.Errorf("snap info failed: %w", err)
        }</span>

        <span class="cov0" title="0">return string(output), nil</span>
}

// FindPackage searches for Snap packages
func (sm *SnapManager) FindPackage(packageName string) ([]string, error) <span class="cov8" title="1">{
        if sm.dryRun </span><span class="cov8" title="1">{
                sm.logger.Info("  [DRY RUN] Would run:", "command", fmt.Sprintf("snap find %s", packageName))
                return []string{}, nil
        }</span>

        <span class="cov0" title="0">args := []string{"snap", "find", packageName}
        cmd := exec.Command(args[0], args[1:]...)
        output, err := cmd.CombinedOutput()

        if err != nil </span><span class="cov0" title="0">{
                sm.logger.Error("Failed to find Snap packages", "search", packageName, "error", err, "output", string(output))
                return nil, fmt.Errorf("snap find failed: %w", err)
        }</span>

        <span class="cov0" title="0">var packages []string
        lines := strings.Split(string(output), "\n")
        for i, line := range lines </span><span class="cov0" title="0">{
                // Skip header line and empty lines
                if i == 0 || strings.TrimSpace(line) == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                // Extract package name (first column)
                <span class="cov0" title="0">fields := strings.Fields(line)
                if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                        packages = append(packages, fields[0])
                }</span>
        }

        <span class="cov0" title="0">sm.logger.Debug("Found Snap packages", "search", packageName, "count", len(packages))
        return packages, nil</span>
}

// checkSnapAvailable checks if snap command is available
func (sm *SnapManager) checkSnapAvailable() error <span class="cov8" title="1">{
        if _, err := exec.LookPath("snap"); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("snap command not found - install snapd package")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// RemovePackages removes multiple Snap packages that are no longer in the configuration
func (sm *SnapManager) RemovePackages(packagesToRemove []string) error <span class="cov0" title="0">{
        if len(packagesToRemove) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">sm.logger.Info("Removing Snap packages no longer in configuration", "packages", packagesToRemove)

        // Filter to only remove packages that are actually installed
        installedToRemove := make([]string, 0, len(packagesToRemove))
        for _, pkg := range packagesToRemove </span><span class="cov0" title="0">{
                if installed, err := sm.isPackageInstalled(pkg); err != nil </span><span class="cov0" title="0">{
                        sm.logger.Warn("Could not check if Snap package is installed", "package", pkg, "error", err)
                }</span> else<span class="cov0" title="0"> if installed </span><span class="cov0" title="0">{
                        installedToRemove = append(installedToRemove, pkg)
                }</span>
        }

        <span class="cov0" title="0">if len(installedToRemove) == 0 </span><span class="cov0" title="0">{
                sm.logger.Info("No installed Snap packages to remove")
                return nil
        }</span>

        // Remove packages one by one (snap remove works on individual packages)
        <span class="cov0" title="0">for _, pkg := range installedToRemove </span><span class="cov0" title="0">{
                if err := sm.UninstallPackage(pkg, []string{}); err != nil </span><span class="cov0" title="0">{
                        sm.logger.Error("Failed to remove Snap package", "package", pkg, "error", err)
                        return fmt.Errorf("failed to remove Snap package %s: %w", pkg, err)
                }</span>
                <span class="cov0" title="0">config.Success("Removed Snap package: %s", pkg)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidatePackageNames validates Snap package names
func (sm *SnapManager) ValidatePackageNames(packages []config.PackageEntry) error <span class="cov8" title="1">{
        sm.logger.Debug("Validating Snap package names", "count", len(packages))

        for _, pkg := range packages </span><span class="cov8" title="1">{
                if err := sm.validatePackageName(pkg.Name); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("invalid Snap package name '%s': %w", pkg.Name, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// validatePackageName validates a single Snap package name
func (sm *SnapManager) validatePackageName(packageName string) error <span class="cov8" title="1">{
        if packageName == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("package name cannot be empty")
        }</span>

        // Snap package names should be lowercase and can contain letters, numbers, and hyphens
        // They must start with a letter and cannot end with a hyphen
        <span class="cov8" title="1">if len(packageName) &lt; 2 </span><span class="cov8" title="1">{
                return fmt.Errorf("package name must be at least 2 characters long")
        }</span>

        <span class="cov8" title="1">if len(packageName) &gt; 40 </span><span class="cov8" title="1">{
                return fmt.Errorf("package name cannot be longer than 40 characters")
        }</span>

        // Must start with a lowercase letter
        <span class="cov8" title="1">if packageName[0] &lt; 'a' || packageName[0] &gt; 'z' </span><span class="cov8" title="1">{
                return fmt.Errorf("package name must start with a lowercase letter")
        }</span>

        // Cannot end with a hyphen
        <span class="cov8" title="1">if packageName[len(packageName)-1] == '-' </span><span class="cov8" title="1">{
                return fmt.Errorf("package name cannot end with a hyphen")
        }</span>

        // Check all characters are valid
        <span class="cov8" title="1">for i, char := range packageName </span><span class="cov8" title="1">{
                if !((char &gt;= 'a' &amp;&amp; char &lt;= 'z') || (char &gt;= '0' &amp;&amp; char &lt;= '9') || char == '-') </span><span class="cov8" title="1">{
                        return fmt.Errorf("package name contains invalid character at position %d: %c", i, char)
                }</span>
        }

        // Cannot have consecutive hyphens
        <span class="cov8" title="1">if strings.Contains(packageName, "--") </span><span class="cov8" title="1">{
                return fmt.Errorf("package name cannot contain consecutive hyphens")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SearchPackages is an alias for FindPackage to maintain consistency with other managers
func (sm *SnapManager) SearchPackages(searchTerm string) ([]string, error) <span class="cov0" title="0">{
        return sm.FindPackage(searchTerm)
}</span>

// GetPackageInfo is an alias for InfoPackage to maintain consistency with other managers
func (sm *SnapManager) GetPackageInfo(packageName string) (string, error) <span class="cov0" title="0">{
        return sm.InfoPackage(packageName)
}</span>

// UpgradePackages is an alias for RefreshPackages to maintain consistency with other managers
func (sm *SnapManager) UpgradePackages(packageNames []string, flags []string) error <span class="cov0" title="0">{
        if len(packageNames) == 0 </span><span class="cov0" title="0">{
                // Refresh all packages
                return sm.RefreshPackages(flags)
        }</span>
        
        // Snap doesn't support upgrading specific packages, so refresh all
        <span class="cov0" title="0">sm.logger.Info("Snap doesn't support upgrading specific packages, refreshing all packages", "requested", packageNames)
        return sm.RefreshPackages(flags)</span>
}</pre>
		
		<pre class="file" id="file33" style="display: none">package pkg

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/charmbracelet/log"
)

// StateManager handles tracking of packages managed by configr
type StateManager struct {
        logger   *log.Logger
        statePath string
}

// PackageState represents the state of packages and files managed by configr
type PackageState struct {
        Version     string            `json:"version"`
        LastUpdated time.Time         `json:"last_updated"`
        Packages    ManagedPackages   `json:"packages"`
        Files       []ManagedFile     `json:"files"`
}

// ManagedPackages tracks packages by manager type
type ManagedPackages struct {
        Apt     []string `json:"apt"`
        Flatpak []string `json:"flatpak"`
        Snap    []string `json:"snap"`
}

// ManagedFile represents a file managed by configr
type ManagedFile struct {
        Name        string `json:"name"`        // File identifier from YAML
        Destination string `json:"destination"` // Where the file was deployed
        IsSymlink   bool   `json:"is_symlink"`  // Whether it was deployed as symlink or copy
        BackupPath  string `json:"backup_path,omitempty"` // Path to backup file if created
}

// NewStateManager creates a new state manager
func NewStateManager(logger *log.Logger) *StateManager <span class="cov8" title="1">{
        // Default state file location: ~/.config/configr/state.json
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Could not determine home directory, using /tmp for state file", "error", err)
                homeDir = "/tmp"
        }</span>
        
        <span class="cov8" title="1">configDir := filepath.Join(homeDir, ".config", "configr")
        statePath := filepath.Join(configDir, "state.json")
        
        return &amp;StateManager{
                logger:    logger,
                statePath: statePath,
        }</span>
}

// NewStateManagerWithPath creates a state manager with a custom state file path
func NewStateManagerWithPath(logger *log.Logger, statePath string) *StateManager <span class="cov8" title="1">{
        return &amp;StateManager{
                logger:    logger,
                statePath: statePath,
        }
}</span>

// LoadState loads the current package state from disk
func (sm *StateManager) LoadState() (*PackageState, error) <span class="cov8" title="1">{
        sm.logger.Debug("Loading package state", "path", sm.statePath)
        
        // If state file doesn't exist, return empty state
        if _, err := os.Stat(sm.statePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                sm.logger.Debug("State file does not exist, returning empty state")
                return &amp;PackageState{
                        Version:     "1.0",
                        LastUpdated: time.Now(),
                        Packages:    ManagedPackages{},
                        Files:       []ManagedFile{},
                }, nil
        }</span>
        
        <span class="cov8" title="1">data, err := os.ReadFile(sm.statePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read state file: %w", err)
        }</span>
        
        <span class="cov8" title="1">var state PackageState
        if err := json.Unmarshal(data, &amp;state); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse state file: %w", err)
        }</span>
        
        <span class="cov8" title="1">sm.logger.Debug("Loaded package state", "apt_count", len(state.Packages.Apt), 
                "flatpak_count", len(state.Packages.Flatpak), "snap_count", len(state.Packages.Snap),
                "files_count", len(state.Files))
        
        return &amp;state, nil</span>
}

// SaveState saves the current package state to disk
func (sm *StateManager) SaveState(state *PackageState) error <span class="cov8" title="1">{
        sm.logger.Debug("Saving package state", "path", sm.statePath)
        
        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(sm.statePath), 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>
        
        // Update timestamp
        <span class="cov8" title="1">state.LastUpdated = time.Now()
        
        data, err := json.MarshalIndent(state, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal state: %w", err)
        }</span>
        
        <span class="cov8" title="1">if err := os.WriteFile(sm.statePath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write state file: %w", err)
        }</span>
        
        <span class="cov8" title="1">sm.logger.Debug("Saved package state successfully")
        return nil</span>
}

// UpdateState updates the state with current configuration packages and files
func (sm *StateManager) UpdateState(cfg *config.Config, deployedFiles []ManagedFile) error <span class="cov8" title="1">{
        state, err := sm.LoadState()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load current state: %w", err)
        }</span>
        
        // Extract package names from configuration
        <span class="cov8" title="1">state.Packages.Apt = extractPackageNames(cfg.Packages.Apt)
        state.Packages.Flatpak = extractPackageNames(cfg.Packages.Flatpak)
        state.Packages.Snap = extractPackageNames(cfg.Packages.Snap)
        
        // Update file state
        state.Files = deployedFiles
        
        return sm.SaveState(state)</span>
}

// UpdatePackageState updates only the package state (for backward compatibility)
func (sm *StateManager) UpdatePackageState(cfg *config.Config) error <span class="cov8" title="1">{
        return sm.UpdateState(cfg, []ManagedFile{})
}</span>

// GetPackagesToRemove compares current state with new configuration and returns packages to remove
func (sm *StateManager) GetPackagesToRemove(cfg *config.Config) (*ManagedPackages, error) <span class="cov8" title="1">{
        currentState, err := sm.LoadState()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load current state: %w", err)
        }</span>
        
        // Get package names from new configuration
        <span class="cov8" title="1">newApt := extractPackageNames(cfg.Packages.Apt)
        newFlatpak := extractPackageNames(cfg.Packages.Flatpak)
        newSnap := extractPackageNames(cfg.Packages.Snap)
        
        // Find packages to remove (in old state but not in new config)
        toRemove := &amp;ManagedPackages{
                Apt:     stringSliceDiff(currentState.Packages.Apt, newApt),
                Flatpak: stringSliceDiff(currentState.Packages.Flatpak, newFlatpak),
                Snap:    stringSliceDiff(currentState.Packages.Snap, newSnap),
        }
        
        sm.logger.Debug("Determined packages to remove", 
                "apt", len(toRemove.Apt), "flatpak", len(toRemove.Flatpak), "snap", len(toRemove.Snap))
        
        if len(toRemove.Apt) &gt; 0 </span><span class="cov8" title="1">{
                sm.logger.Debug("APT packages to remove", "packages", toRemove.Apt)
        }</span>
        <span class="cov8" title="1">if len(toRemove.Flatpak) &gt; 0 </span><span class="cov8" title="1">{
                sm.logger.Debug("Flatpak packages to remove", "packages", toRemove.Flatpak)
        }</span>
        <span class="cov8" title="1">if len(toRemove.Snap) &gt; 0 </span><span class="cov8" title="1">{
                sm.logger.Debug("Snap packages to remove", "packages", toRemove.Snap)
        }</span>
        
        <span class="cov8" title="1">return toRemove, nil</span>
}

// GetFilesToRemove compares current state with new configuration and returns files to remove
func (sm *StateManager) GetFilesToRemove(cfg *config.Config) ([]ManagedFile, error) <span class="cov8" title="1">{
        currentState, err := sm.LoadState()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load current state: %w", err)
        }</span>
        
        // Create a map of current configuration file names for quick lookup
        <span class="cov8" title="1">currentFiles := make(map[string]bool)
        for fileName := range cfg.Files </span><span class="cov8" title="1">{
                currentFiles[fileName] = true
        }</span>
        
        // Find files in state that are not in current configuration
        <span class="cov8" title="1">var filesToRemove []ManagedFile
        for _, file := range currentState.Files </span><span class="cov8" title="1">{
                if !currentFiles[file.Name] </span><span class="cov8" title="1">{
                        filesToRemove = append(filesToRemove, file)
                }</span>
        }
        
        <span class="cov8" title="1">sm.logger.Debug("Determined files to remove", "count", len(filesToRemove))
        if len(filesToRemove) &gt; 0 </span><span class="cov8" title="1">{
                fileNames := make([]string, len(filesToRemove))
                for i, file := range filesToRemove </span><span class="cov8" title="1">{
                        fileNames[i] = file.Name
                }</span>
                <span class="cov8" title="1">sm.logger.Debug("Files to remove", "files", fileNames)</span>
        }
        
        <span class="cov8" title="1">return filesToRemove, nil</span>
}

// extractPackageNames extracts package names from PackageEntry slices
func extractPackageNames(packages []config.PackageEntry) []string <span class="cov8" title="1">{
        names := make([]string, len(packages))
        for i, pkg := range packages </span><span class="cov8" title="1">{
                names[i] = pkg.Name
        }</span>
        <span class="cov8" title="1">return names</span>
}

// stringSliceDiff returns elements in slice1 that are not in slice2
func stringSliceDiff(slice1, slice2 []string) []string <span class="cov8" title="1">{
        set2 := make(map[string]bool)
        for _, item := range slice2 </span><span class="cov8" title="1">{
                set2[item] = true
        }</span>
        
        <span class="cov8" title="1">var diff []string
        for _, item := range slice1 </span><span class="cov8" title="1">{
                if !set2[item] </span><span class="cov8" title="1">{
                        diff = append(diff, item)
                }</span>
        }
        
        <span class="cov8" title="1">return diff</span>
}</pre>
		
		<pre class="file" id="file34" style="display: none">package pkg

import (
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/bashfulrobot/configr/internal/config"
        "github.com/charmbracelet/bubbles/progress"
        "github.com/charmbracelet/bubbles/spinner"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        "github.com/charmbracelet/log"
)

// UXManager handles user experience enhancements like progress bars and spinners
type UXManager struct {
        logger *log.Logger
        dryRun bool
        
        // Styles
        progressStyle   lipgloss.Style
        spinnerStyle    lipgloss.Style
        successStyle    lipgloss.Style
        errorStyle      lipgloss.Style
        warningStyle    lipgloss.Style
        noteStyle       lipgloss.Style
        lineNumberStyle lipgloss.Style
}

// NewUXManager creates a new UX manager
func NewUXManager(logger *log.Logger, dryRun bool) *UXManager <span class="cov8" title="1">{
        return &amp;UXManager{
                logger: logger,
                dryRun: dryRun,
                
                // Initialize styles
                progressStyle:   lipgloss.NewStyle().Foreground(lipgloss.Color("205")),
                spinnerStyle:    lipgloss.NewStyle().Foreground(lipgloss.Color("69")),
                successStyle:    lipgloss.NewStyle().Foreground(lipgloss.Color("46")).Bold(true),
                errorStyle:      lipgloss.NewStyle().Foreground(lipgloss.Color("196")).Bold(true),
                warningStyle:    lipgloss.NewStyle().Foreground(lipgloss.Color("214")).Bold(true),
                noteStyle:       lipgloss.NewStyle().Foreground(lipgloss.Color("39")).Bold(true),
                lineNumberStyle: lipgloss.NewStyle().Foreground(lipgloss.Color("243")),
        }
}</span>

// ProgressModel represents a progress bar with a title and current step
type ProgressModel struct {
        title    string
        progress progress.Model
        current  int
        total    int
        done     bool
        err      error
}

func (m ProgressModel) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

func (m ProgressModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                if msg.String() == "ctrl+c" </span><span class="cov0" title="0">{
                        return m, tea.Quit
                }</span>
        case ProgressUpdateMsg:<span class="cov0" title="0">
                m.current = msg.Current
                m.total = msg.Total
                if m.current &gt;= m.total </span><span class="cov0" title="0">{
                        m.done = true
                        return m, tea.Quit
                }</span>
                <span class="cov0" title="0">return m, m.progress.SetPercent(float64(m.current) / float64(m.total))</span>
        case ProgressErrorMsg:<span class="cov0" title="0">
                m.err = msg.Error
                return m, tea.Quit</span>
        }
        
        <span class="cov0" title="0">var cmd tea.Cmd
        progressModel, progressCmd := m.progress.Update(msg)
        m.progress = progressModel.(progress.Model)
        return m, tea.Batch(cmd, progressCmd)</span>
}

func (m ProgressModel) View() string <span class="cov0" title="0">{
        if m.err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("✗ %s: %v\n", m.title, m.err)
        }</span>
        
        <span class="cov0" title="0">if m.done </span><span class="cov0" title="0">{
                return fmt.Sprintf("✓ %s completed\n", m.title)
        }</span>
        
        <span class="cov0" title="0">return fmt.Sprintf("%s (%d/%d)\n%s\n", 
                m.title, m.current, m.total, 
                m.progress.View(),
        )</span>
}

// SpinnerModel represents a spinner with a message
type SpinnerModel struct {
        spinner  spinner.Model
        message  string
        done     bool
        success  bool
        err      error
}

func (m SpinnerModel) Init() tea.Cmd <span class="cov0" title="0">{
        return m.spinner.Tick
}</span>

func (m SpinnerModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                if msg.String() == "ctrl+c" </span><span class="cov0" title="0">{
                        return m, tea.Quit
                }</span>
        case SpinnerDoneMsg:<span class="cov0" title="0">
                m.done = true
                m.success = msg.Success
                m.err = msg.Error
                return m, tea.Quit</span>
        case SpinnerUpdateMsg:<span class="cov0" title="0">
                m.message = msg.Message
                var cmd tea.Cmd
                m.spinner, cmd = m.spinner.Update(msg)
                return m, cmd</span>
        }
        
        <span class="cov0" title="0">var cmd tea.Cmd
        m.spinner, cmd = m.spinner.Update(msg)
        return m, cmd</span>
}

func (m SpinnerModel) View() string <span class="cov0" title="0">{
        if m.done </span><span class="cov0" title="0">{
                if m.err != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("✗ %s: %v\n", m.message, m.err)
                }</span>
                <span class="cov0" title="0">if m.success </span><span class="cov0" title="0">{
                        return fmt.Sprintf("✓ %s\n", m.message)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("- %s\n", m.message)</span>
        }
        
        <span class="cov0" title="0">return fmt.Sprintf("%s %s", m.spinner.View(), m.message)</span>
}

// Progress bar messages
type ProgressUpdateMsg struct {
        Current int
        Total   int
}

type ProgressErrorMsg struct {
        Error error
}

// Spinner messages
type SpinnerDoneMsg struct {
        Success bool
        Error   error
}

type SpinnerUpdateMsg struct {
        Message string
}

// ShowProgressBar displays a progress bar for multi-step operations
func (ux *UXManager) ShowProgressBar(title string, steps int) (*tea.Program, chan ProgressUpdateMsg, chan error) <span class="cov8" title="1">{
        if !ux.IsInteractiveTerminal() </span><span class="cov0" title="0">{
                // Fallback for non-interactive terminals
                ux.logger.Info(title, "steps", steps)
                return nil, make(chan ProgressUpdateMsg, 10), make(chan error, 1)
        }</span>

        <span class="cov8" title="1">prog := progress.New(progress.WithDefaultGradient())
        prog.Width = 60
        prog.ShowPercentage = true
        
        model := ProgressModel{
                title:    title,
                progress: prog,
                current:  0,
                total:    steps,
        }
        
        p := tea.NewProgram(model, tea.WithOutput(os.Stderr))
        updateChan := make(chan ProgressUpdateMsg, 10)
        errorChan := make(chan error, 1)
        
        // Start the program in a goroutine
        go func() </span><span class="cov8" title="1">{
                if _, err := p.Run(); err != nil </span><span class="cov8" title="1">{
                        ux.logger.Error("Progress bar error", "error", err)
                }</span>
        }()
        
        // Handle updates
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case update := &lt;-updateChan:<span class="cov8" title="1">
                                p.Send(update)
                                if update.Current &gt;= update.Total </span><span class="cov8" title="1">{
                                        return
                                }</span>
                        case err := &lt;-errorChan:<span class="cov0" title="0">
                                p.Send(ProgressErrorMsg{Error: err})
                                return</span>
                        }
                }
        }()
        
        <span class="cov8" title="1">return p, updateChan, errorChan</span>
}

// ShowPackageProgress displays a specialized progress bar for package operations
func (ux *UXManager) ShowPackageProgress(manager string, packages []string) (*tea.Program, chan ProgressUpdateMsg, chan error) <span class="cov0" title="0">{
        title := fmt.Sprintf("Installing %s packages", manager)
        if len(packages) &gt; 0 </span><span class="cov0" title="0">{
                title = fmt.Sprintf("Installing %d %s packages", len(packages), manager)
        }</span>
        <span class="cov0" title="0">return ux.ShowProgressBar(title, len(packages))</span>
}

// ShowFileProgress displays a specialized progress bar for file operations
func (ux *UXManager) ShowFileProgress(operation string, files map[string]interface{}) (*tea.Program, chan ProgressUpdateMsg, chan error) <span class="cov0" title="0">{
        title := fmt.Sprintf("%s files", operation)
        if len(files) &gt; 0 </span><span class="cov0" title="0">{
                title = fmt.Sprintf("%s %d files", operation, len(files))
        }</span>
        <span class="cov0" title="0">return ux.ShowProgressBar(title, len(files))</span>
}

// ShowSpinner displays a spinner for single operations
func (ux *UXManager) ShowSpinner(message string) (*tea.Program, chan string, chan SpinnerDoneMsg) <span class="cov8" title="1">{
        if !ux.IsInteractiveTerminal() </span><span class="cov0" title="0">{
                // Fallback for non-interactive terminals
                ux.logger.Info(message)
                return nil, make(chan string, 10), make(chan SpinnerDoneMsg, 1)
        }</span>

        <span class="cov8" title="1">s := spinner.New()
        s.Spinner = spinner.Line
        s.Style = ux.spinnerStyle
        
        model := SpinnerModel{
                spinner: s,
                message: message,
        }
        
        p := tea.NewProgram(model, tea.WithOutput(os.Stderr))
        updateChan := make(chan string, 10)
        doneChan := make(chan SpinnerDoneMsg, 1)
        
        // Start the program in a goroutine
        go func() </span><span class="cov8" title="1">{
                if _, err := p.Run(); err != nil </span><span class="cov8" title="1">{
                        ux.logger.Error("Spinner error", "error", err)
                }</span>
        }()
        
        // Handle updates
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case msg := &lt;-updateChan:<span class="cov0" title="0">
                                p.Send(SpinnerUpdateMsg{Message: msg})</span>
                        case done := &lt;-doneChan:<span class="cov8" title="1">
                                p.Send(done)
                                return</span>
                        }
                }
        }()
        
        <span class="cov8" title="1">return p, updateChan, doneChan</span>
}

// ShowValidationSpinner displays a spinner specifically for validation operations
func (ux *UXManager) ShowValidationSpinner() (*tea.Program, chan SpinnerDoneMsg) <span class="cov0" title="0">{
        _, _, doneChan := ux.ShowSpinner("Validating configuration...")
        p, _, doneChan2 := ux.ShowSpinner("Validating configuration...")
        
        // Merge channels for simplified interface
        go func() </span><span class="cov0" title="0">{
                select </span>{
                case msg := &lt;-doneChan2:<span class="cov0" title="0">
                        doneChan &lt;- msg</span>
                }
        }()
        
        <span class="cov0" title="0">return p, doneChan</span>
}

// ShowRepositorySpinner displays a spinner for repository operations
func (ux *UXManager) ShowRepositorySpinner(operation string) (*tea.Program, chan string, chan SpinnerDoneMsg) <span class="cov0" title="0">{
        message := fmt.Sprintf("%s repositories...", operation)
        return ux.ShowSpinner(message)
}</span>

// ShowConfigLoadSpinner displays a spinner for configuration loading
func (ux *UXManager) ShowConfigLoadSpinner(optimized bool) (*tea.Program, chan SpinnerDoneMsg) <span class="cov0" title="0">{
        message := "Loading configuration..."
        if optimized </span><span class="cov0" title="0">{
                message = "Loading configuration (optimized)..."
        }</span>
        <span class="cov0" title="0">_, _, doneChan := ux.ShowSpinner(message)
        p, _, doneChan2 := ux.ShowSpinner(message)
        
        // Merge channels for simplified interface
        go func() </span><span class="cov0" title="0">{
                select </span>{
                case msg := &lt;-doneChan2:<span class="cov0" title="0">
                        doneChan &lt;- msg</span>
                }
        }()
        
        <span class="cov0" title="0">return p, doneChan</span>
}

// ShowConfigPreview displays a comprehensive preview of the configuration changes
func (ux *UXManager) ShowConfigPreview(cfg *config.Config) string <span class="cov0" title="0">{
        var preview strings.Builder
        
        // Header with enhanced styling
        headerTitle := ux.successStyle.Render("📋 Configuration Preview")
        preview.WriteString(headerTitle + "\n")
        preview.WriteString(ux.lineNumberStyle.Render(strings.Repeat("═", 60)) + "\n\n")
        
        // Version and metadata
        if cfg.Version != "" </span><span class="cov0" title="0">{
                preview.WriteString(ux.noteStyle.Render("📌 Version: ") + cfg.Version + "\n")
        }</span>
        
        // Includes summary
        <span class="cov0" title="0">if len(cfg.Includes) &gt; 0 </span><span class="cov0" title="0">{
                preview.WriteString(ux.noteStyle.Render("📁 Includes: ") + fmt.Sprintf("%d files\n", len(cfg.Includes)))
                for _, include := range cfg.Includes </span><span class="cov0" title="0">{
                        if include.Path != "" </span><span class="cov0" title="0">{
                                preview.WriteString(fmt.Sprintf("   ↳ %s", include.Path))
                                if include.Optional </span><span class="cov0" title="0">{
                                        preview.WriteString(ux.warningStyle.Render(" (optional)"))
                                }</span>
                                <span class="cov0" title="0">preview.WriteString("\n")</span>
                        }
                }
        }
        <span class="cov0" title="0">preview.WriteString("\n")
        
        // Repositories with enhanced details
        totalRepos := len(cfg.Repositories.Apt) + len(cfg.Repositories.Flatpak)
        if totalRepos &gt; 0 </span><span class="cov0" title="0">{
                preview.WriteString(ux.warningStyle.Render("📦 Repositories ") + fmt.Sprintf("(%d total)", totalRepos) + "\n")
                
                if len(cfg.Repositories.Apt) &gt; 0 </span><span class="cov0" title="0">{
                        preview.WriteString(ux.noteStyle.Render("  APT:") + "\n")
                        for _, repo := range cfg.Repositories.Apt </span><span class="cov0" title="0">{
                                if repo.PPA != "" </span><span class="cov0" title="0">{
                                        preview.WriteString(fmt.Sprintf("    • PPA: %s", repo.PPA))
                                        if repo.Key != "" </span><span class="cov0" title="0">{
                                                preview.WriteString(ux.lineNumberStyle.Render(" (with GPG key)"))
                                        }</span>
                                        <span class="cov0" title="0">preview.WriteString("\n")</span>
                                } else<span class="cov0" title="0"> if repo.URI != "" </span><span class="cov0" title="0">{
                                        preview.WriteString(fmt.Sprintf("    • Custom: %s", repo.URI))
                                        if repo.Key != "" </span><span class="cov0" title="0">{
                                                preview.WriteString(ux.lineNumberStyle.Render(" (with GPG key)"))
                                        }</span>
                                        <span class="cov0" title="0">preview.WriteString("\n")</span>
                                }
                        }
                }
                
                <span class="cov0" title="0">if len(cfg.Repositories.Flatpak) &gt; 0 </span><span class="cov0" title="0">{
                        preview.WriteString(ux.noteStyle.Render("  Flatpak:") + "\n")
                        for _, repo := range cfg.Repositories.Flatpak </span><span class="cov0" title="0">{
                                preview.WriteString(fmt.Sprintf("    • %s: %s", repo.Name, repo.URL))
                                if repo.User </span><span class="cov0" title="0">{
                                        preview.WriteString(ux.lineNumberStyle.Render(" (user scope)"))
                                }</span> else<span class="cov0" title="0"> {
                                        preview.WriteString(ux.lineNumberStyle.Render(" (system scope)"))
                                }</span>
                                <span class="cov0" title="0">preview.WriteString("\n")</span>
                        }
                }
                <span class="cov0" title="0">preview.WriteString("\n")</span>
        }
        
        // Packages with enhanced breakdown
        <span class="cov0" title="0">totalPackages := len(cfg.Packages.Apt) + len(cfg.Packages.Flatpak) + len(cfg.Packages.Snap)
        if totalPackages &gt; 0 </span><span class="cov0" title="0">{
                preview.WriteString(ux.warningStyle.Render("📱 Packages ") + fmt.Sprintf("(%d total)", totalPackages) + "\n")
                
                if len(cfg.Packages.Apt) &gt; 0 </span><span class="cov0" title="0">{
                        preview.WriteString(fmt.Sprintf("  • APT: %s packages", ux.successStyle.Render(fmt.Sprintf("%d", len(cfg.Packages.Apt)))))
                        debFiles := 0
                        for _, pkg := range cfg.Packages.Apt </span><span class="cov0" title="0">{
                                if strings.HasSuffix(pkg.Name, ".deb") </span><span class="cov0" title="0">{
                                        debFiles++
                                }</span>
                        }
                        <span class="cov0" title="0">if debFiles &gt; 0 </span><span class="cov0" title="0">{
                                preview.WriteString(fmt.Sprintf(" (%d local .deb files)", debFiles))
                        }</span>
                        <span class="cov0" title="0">preview.WriteString("\n")</span>
                }
                
                <span class="cov0" title="0">if len(cfg.Packages.Flatpak) &gt; 0 </span><span class="cov0" title="0">{
                        preview.WriteString(fmt.Sprintf("  • Flatpak: %s packages\n", ux.successStyle.Render(fmt.Sprintf("%d", len(cfg.Packages.Flatpak)))))
                }</span>
                
                <span class="cov0" title="0">if len(cfg.Packages.Snap) &gt; 0 </span><span class="cov0" title="0">{
                        preview.WriteString(fmt.Sprintf("  • Snap: %s packages", ux.successStyle.Render(fmt.Sprintf("%d", len(cfg.Packages.Snap)))))
                        classicSnaps := 0
                        for _, pkg := range cfg.Packages.Snap </span><span class="cov0" title="0">{
                                for _, flag := range pkg.Flags </span><span class="cov0" title="0">{
                                        if flag == "--classic" </span><span class="cov0" title="0">{
                                                classicSnaps++
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov0" title="0">if classicSnaps &gt; 0 </span><span class="cov0" title="0">{
                                preview.WriteString(fmt.Sprintf(" (%d classic mode)", classicSnaps))
                        }</span>
                        <span class="cov0" title="0">preview.WriteString("\n")</span>
                }
                <span class="cov0" title="0">preview.WriteString("\n")</span>
        }
        
        // Files with enhanced details
        <span class="cov0" title="0">if len(cfg.Files) &gt; 0 </span><span class="cov0" title="0">{
                preview.WriteString(ux.warningStyle.Render("📄 Files ") + fmt.Sprintf("(%d total)", len(cfg.Files)) + "\n")
                
                symlinkCount := 0
                copyCount := 0
                interactiveCount := 0
                
                for name, file := range cfg.Files </span><span class="cov0" title="0">{
                        mode := ux.noteStyle.Render("symlink")
                        if file.Copy </span><span class="cov0" title="0">{
                                mode = ux.warningStyle.Render("copy")
                                copyCount++
                        }</span> else<span class="cov0" title="0"> {
                                symlinkCount++
                        }</span>
                        
                        <span class="cov0" title="0">if file.Interactive </span><span class="cov0" title="0">{
                                interactiveCount++
                        }</span>
                        
                        <span class="cov0" title="0">preview.WriteString(fmt.Sprintf("  • %s: %s → %s (%s)", 
                                name, file.Source, file.Destination, mode))
                        
                        if file.Mode != "" || file.Owner != "" || file.Group != "" </span><span class="cov0" title="0">{
                                permissions := []string{}
                                if file.Mode != "" </span><span class="cov0" title="0">{
                                        permissions = append(permissions, fmt.Sprintf("mode:%s", file.Mode))
                                }</span>
                                <span class="cov0" title="0">if file.Owner != "" </span><span class="cov0" title="0">{
                                        permissions = append(permissions, fmt.Sprintf("owner:%s", file.Owner))
                                }</span>
                                <span class="cov0" title="0">if file.Group != "" </span><span class="cov0" title="0">{
                                        permissions = append(permissions, fmt.Sprintf("group:%s", file.Group))
                                }</span>
                                <span class="cov0" title="0">preview.WriteString(ux.lineNumberStyle.Render(fmt.Sprintf(" [%s]", strings.Join(permissions, " "))))</span>
                        }
                        
                        <span class="cov0" title="0">if file.Interactive </span><span class="cov0" title="0">{
                                preview.WriteString(ux.warningStyle.Render(" (interactive)"))
                        }</span>
                        
                        <span class="cov0" title="0">preview.WriteString("\n")</span>
                }
                
                // Summary
                <span class="cov0" title="0">preview.WriteString(ux.lineNumberStyle.Render(fmt.Sprintf("    Summary: %d symlinks, %d copies", symlinkCount, copyCount)))
                if interactiveCount &gt; 0 </span><span class="cov0" title="0">{
                        preview.WriteString(ux.lineNumberStyle.Render(fmt.Sprintf(", %d interactive", interactiveCount)))
                }</span>
                <span class="cov0" title="0">preview.WriteString("\n\n")</span>
        }
        
        // DConf settings with enhanced details
        <span class="cov0" title="0">if len(cfg.DConf.Settings) &gt; 0 </span><span class="cov0" title="0">{
                preview.WriteString(ux.warningStyle.Render("⚙️  DConf Settings ") + fmt.Sprintf("(%d settings)", len(cfg.DConf.Settings)) + "\n")
                
                // Show a few example settings
                count := 0
                for path, value := range cfg.DConf.Settings </span><span class="cov0" title="0">{
                        if count &lt; 3 </span><span class="cov0" title="0">{
                                truncatedValue := value
                                if len(value) &gt; 40 </span><span class="cov0" title="0">{
                                        truncatedValue = value[:37] + "..."
                                }</span>
                                <span class="cov0" title="0">preview.WriteString(fmt.Sprintf("  • %s = %s\n", path, truncatedValue))
                                count++</span>
                        } else<span class="cov0" title="0"> {
                                remaining := len(cfg.DConf.Settings) - 3
                                preview.WriteString(ux.lineNumberStyle.Render(fmt.Sprintf("  ... and %d more settings\n", remaining)))
                                break</span>
                        }
                }
                <span class="cov0" title="0">preview.WriteString("\n")</span>
        }
        
        // Package defaults summary
        <span class="cov0" title="0">if cfg.PackageDefaults != nil &amp;&amp; len(cfg.PackageDefaults) &gt; 0 </span><span class="cov0" title="0">{
                preview.WriteString(ux.noteStyle.Render("🔧 Package Defaults:") + "\n")
                for manager, flags := range cfg.PackageDefaults </span><span class="cov0" title="0">{
                        preview.WriteString(fmt.Sprintf("  • %s: %s\n", manager, strings.Join(flags, " ")))
                }</span>
                <span class="cov0" title="0">preview.WriteString("\n")</span>
        }
        
        // Footer with status and next steps
        <span class="cov0" title="0">preview.WriteString(ux.lineNumberStyle.Render(strings.Repeat("─", 60)) + "\n")
        if ux.dryRun </span><span class="cov0" title="0">{
                preview.WriteString(ux.spinnerStyle.Render("🔍 DRY RUN MODE") + " - No changes will be made to your system\n")
        }</span> else<span class="cov0" title="0"> {
                preview.WriteString(ux.errorStyle.Render("🚀 READY TO APPLY") + " - Configuration will be applied to your system\n")
        }</span>
        
        <span class="cov0" title="0">return preview.String()</span>
}

// FormatValidationSummary creates a comprehensive visual summary of validation results
func (ux *UXManager) FormatValidationSummary(result *config.ValidationResult) string <span class="cov8" title="1">{
        if result == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">var output strings.Builder
        
        // Header for validation results
        if len(result.Errors) &gt; 0 || len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString(ux.errorStyle.Render("🔍 Configuration Validation Report") + "\n")
                output.WriteString(ux.lineNumberStyle.Render(strings.Repeat("═", 60)) + "\n\n")
        }</span>
        
        // Summary statistics
        <span class="cov8" title="1">totalIssues := len(result.Errors) + len(result.Warnings)
        if totalIssues &gt; 0 </span><span class="cov0" title="0">{
                summaryParts := []string{}
                if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        summaryParts = append(summaryParts, ux.errorStyle.Render(fmt.Sprintf("%d error(s)", len(result.Errors))))
                }</span>
                <span class="cov0" title="0">if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                        summaryParts = append(summaryParts, ux.warningStyle.Render(fmt.Sprintf("%d warning(s)", len(result.Warnings))))
                }</span>
                
                <span class="cov0" title="0">output.WriteString(ux.noteStyle.Render("📊 Summary: ") + strings.Join(summaryParts, ", ") + " found\n\n")</span>
        }

        // Use enhanced Rust-style formatting for detailed errors
        <span class="cov8" title="1">enhancedOutput := config.FormatValidationResultEnhanced(result)
        if enhancedOutput != "" </span><span class="cov8" title="1">{
                output.WriteString(enhancedOutput)
        }</span>
        
        // Add quick fixes section
        <span class="cov8" title="1">quickFixes := config.FormatQuickFixEnhanced(result)
        if quickFixes != "" </span><span class="cov0" title="0">{
                output.WriteString(quickFixes)
        }</span>
        
        // Footer with next steps
        <span class="cov8" title="1">if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString("\n" + ux.lineNumberStyle.Render(strings.Repeat("─", 60)) + "\n")
                output.WriteString(ux.errorStyle.Render("❌ Validation failed") + " - Please fix the above errors before applying configuration\n")
        }</span> else<span class="cov8" title="1"> if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString("\n" + ux.lineNumberStyle.Render(strings.Repeat("─", 60)) + "\n")
                output.WriteString(ux.warningStyle.Render("⚠️  Warnings detected") + " - Configuration is valid but consider addressing these issues\n")
        }</span>
        
        <span class="cov8" title="1">return output.String()</span>
}

// FormatValidationSummaryCompact creates a compact validation summary for quick feedback
func (ux *UXManager) FormatValidationSummaryCompact(result *config.ValidationResult) string <span class="cov8" title="1">{
        if result == nil || (len(result.Errors) == 0 &amp;&amp; len(result.Warnings) == 0) </span><span class="cov8" title="1">{
                return ux.successStyle.Render("✓ Configuration is valid")
        }</span>
        
        <span class="cov0" title="0">var summary strings.Builder
        
        if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                summary.WriteString(ux.errorStyle.Render(fmt.Sprintf("✗ %d error(s)", len(result.Errors))))
                if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                        summary.WriteString(", ")
                }</span>
        }
        
        <span class="cov0" title="0">if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                summary.WriteString(ux.warningStyle.Render(fmt.Sprintf("⚠ %d warning(s)", len(result.Warnings))))
        }</span>
        
        <span class="cov0" title="0">return summary.String()</span>
}

// IsInteractiveTerminal checks if we're running in an interactive terminal
func (ux *UXManager) IsInteractiveTerminal() bool <span class="cov8" title="1">{
        // Check if we're in a TTY
        if fileInfo, _ := os.Stdin.Stat(); (fileInfo.Mode() &amp; os.ModeCharDevice) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // Check for CI environment variables
        <span class="cov8" title="1">ciVars := []string{"CI", "GITHUB_ACTIONS", "GITLAB_CI", "JENKINS_URL", "TRAVIS"}
        for _, ciVar := range ciVars </span><span class="cov8" title="1">{
                if os.Getenv(ciVar) != "" </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        
        <span class="cov8" title="1">return true</span>
}

// SimulateProgress simulates a progress bar for demonstration
func (ux *UXManager) SimulateProgress(title string, steps int, duration time.Duration) <span class="cov8" title="1">{
        if !ux.IsInteractiveTerminal() </span><span class="cov0" title="0">{
                ux.logger.Info(title)
                return
        }</span>
        
        <span class="cov8" title="1">p, updateChan, _ := ux.ShowProgressBar(title, steps)
        defer p.Kill()
        
        stepDuration := duration / time.Duration(steps)
        
        go func() </span><span class="cov8" title="1">{
                for i := 0; i &lt;= steps; i++ </span><span class="cov8" title="1">{
                        select </span>{
                        case updateChan &lt;- ProgressUpdateMsg{Current: i, Total: steps}:<span class="cov8" title="1"></span>
                        case &lt;-time.After(time.Second):<span class="cov0" title="0">
                                // Timeout protection
                                return</span>
                        }
                        
                        <span class="cov8" title="1">if i &lt; steps </span><span class="cov8" title="1">{
                                time.Sleep(stepDuration)
                        }</span>
                }
        }()
        
        // Let the progress bar finish
        <span class="cov8" title="1">time.Sleep(duration + time.Millisecond*500)</span>
}

// SimulateSpinner simulates a spinner for demonstration
func (ux *UXManager) SimulateSpinner(message string, duration time.Duration, success bool) <span class="cov8" title="1">{
        if !ux.IsInteractiveTerminal() </span><span class="cov0" title="0">{
                ux.logger.Info(message)
                return
        }</span>
        
        <span class="cov8" title="1">p, _, doneChan := ux.ShowSpinner(message)
        defer p.Kill()
        
        go func() </span><span class="cov8" title="1">{
                time.Sleep(duration)
                doneChan &lt;- SpinnerDoneMsg{Success: success}
        }</span>()
        
        // Let the spinner finish
        <span class="cov8" title="1">time.Sleep(duration + time.Millisecond*500)</span>
}</pre>
		
		<pre class="file" id="file35" style="display: none">package main

import (
        "context"
        "os"

        "github.com/bashfulrobot/configr/cmd/configr"
        "github.com/charmbracelet/fang"
)

func main() <span class="cov0" title="0">{
        cmd := configr.NewRootCmd()
        if err := fang.Execute(context.Background(), cmd); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
